#+TITLE: Auction Smartcontract
#+AUTHOR: Lasse Letager Hansen

# Use org-tanglesync !
# lentic

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file
# C-c C-v s   -  create results / run subtree

* General information
:PROPERTIES:
:header-args: sh :eval never :results output silent
:END:
** Resulting output
#+begin_src sh
  cargo clean
#+end_src

#+begin_src sh
  cargo install --path language
#+end_src

#+begin_src sh
  cargo build
#+end_src

#+begin_src sh
cargo hacspec -e v -dir coq/src -o Auction --org-file auction.org hacspec-auction
#+end_src

* Auction smart contract specification
** Config
#+begin_src toml :tangle ../../examples/auction/Cargo.toml :mkdirp yes :eval never
[package]
name = "hacspec-auction"
version = "0.1.0"
authors = [""]
edition = "2018"

[lib]
path = "src/auction.rs"

[dependencies]
hacspec-lib = { path = "../../lib" }
# hacspec-attributes = { path = "../../utils/attributes", version = "0.1.0-beta.1" , features = ["print_attributes"] } # , features = ["hacspec_unsafe"] , , optional = true
# pearlite-syn = { path = "../../../../creusot/pearlite-syn" }
creusot-contracts = { git = "https://github.com/xldenis/creusot", rev = "7763b3ae77205fba83182b9a6c3e69ad0b12fec7" }
# hacspec = {optional = true}
concordium-contracts-common = { path = "../../../../concordium-rust-smart-contracts/concordium-contracts-common" }
hacspec-concordium = { path = "../concordium" }
hacspec-concordium-derive = { path = "../concordium-derive" }

[features]
hacspec = []
# use_attributes = ["hacspec-attributes", "hacspec-attributes/print_attributes"]

[dev-dependencies]
hacspec-dev = { path = "../../utils/dev" }
criterion = "0.3"
rand = "0.8"
quickcheck = "1"
quickcheck_macros = "1"
#+end_src

** Rust code
:PROPERTIES:
:header-args: :tangle ../../examples/auction/src/auction.rs :mkdirp yes
:END:

*** Imports
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
extern crate hacspec_lib;

use hacspec_lib::*;

// #[cfg(feature = "hacspec_attributes")]
// #[cfg(feature = "hacspec")]
// use hacspec_attributes::*;
// #[cfg(not(feature = "hacspec"))]
// #[cfg(test)]
// use hacspec_attributes::proof;

// #[cfg(not(feature = "hacspec"))]
// extern crate creusot_contracts;
#[cfg(test)]
#[cfg(not(feature = "hacspec"))]
use creusot_contracts::{ensures, requires};

#+end_src

#+begin_src rust :eval never
  // // Rust-hacspec Interface
  #[cfg(not(feature = "hacspec"))]
  use hacspec_concordium::{collections::BTreeMap, *};
#+end_src

*** Types
#+begin_src rust :eval never
  array!(UserAddress, 32, u8); // U8

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_account_address(ua: UserAddress) -> AccountAddress {
      AccountAddress([
	  ua[0], ua[1], ua[2], ua[3], ua[4], ua[5], ua[6], ua[7], ua[8], ua[9], ua[10], ua[11],
	  ua[12], ua[13], ua[14], ua[15], ua[16], ua[17], ua[18], ua[19], ua[20], ua[21], ua[22],
	  ua[23], ua[24], ua[25], ua[26], ua[27], ua[28], ua[29], ua[30], ua[31],
      ])
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_account_address(aa: &AccountAddress) -> UserAddress {
      UserAddress::from_native_slice(&aa.0)
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// The state in which an auction can be.
  #[derive(Debug, Eq, PartialEq, PartialOrd, Serialize, SchemaType)] // TODO: Debug with creusot 
  pub enum AuctionState {
      /// The auction is either
      /// - still accepting bids or
      /// - not accepting bids because it's past the auction end, but nobody has
      ///   finalized the auction yet.
      NotSoldYet,
      /// The auction is over and the item has been sold to the indicated address.
      Sold(AccountAddress), // winning account's address
  }

  /// The state in which an auction can be.
  #[derive(Clone, PartialEq)]
  pub enum AuctionStateHacspec {
      /// The auction is either
      /// - still accepting bids or
      /// - not accepting bids because it's past the auction end, but nobody has
      ///   finalized the auction yet.
      NotSoldYet,
      /// The auction is over and the item has been sold to the indicated address.
      Sold(UserAddress), // winning account's address
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_auction_state(s : AuctionStateHacspec) -> AuctionState {
      match s {
	  AuctionStateHacspec::NotSoldYet => AuctionState::NotSoldYet,
	  AuctionStateHacspec::Sold(ua) => AuctionState::Sold(coerce_hacspec_to_rust_account_address(ua))
      }
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_auction_state(s : &AuctionState) -> AuctionStateHacspec {
      match s {
	  AuctionState::NotSoldYet => AuctionStateHacspec::NotSoldYet,
	  AuctionState::Sold(aa) => AuctionStateHacspec::Sold(coerce_rust_to_hacspec_account_address(aa))
      }
  }

#+end_src

#+begin_src rust :eval never
  #[derive(Clone, PartialEq)]
  pub struct SeqMap(pub PublicByteSeq, pub PublicByteSeq);

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_b_tree_map(m: SeqMap) -> BTreeMap<AccountAddress, Amount> {
      let m1prime =
	  (0..m.0.len() / 32).map(|x| UserAddress::from_seq(&m.0.clone().slice(x * 32, 32)));
      let m2prime =
	  (0..m.1.len() / 8).map(|x| u64_from_be_bytes(u64Word::from_seq(&m.1.slice(x * 8, 8))));

      (m1prime.zip(m2prime)).fold(BTreeMap::new(), |mut t, (x, y)| {
	  t.insert(
	      coerce_hacspec_to_rust_account_address(x),
	      Amount { micro_ccd: y },
	  );
	  t
      })
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_b_tree_map(m: &BTreeMap<AccountAddress, Amount>) -> SeqMap {
      SeqMap(
	  m.keys()
	      .map(|x| coerce_rust_to_hacspec_account_address(x))
	      .fold(PublicByteSeq::new(0_usize), |v, x| v.concat(&x)),
	  m.values()
	      .map(|x| x.micro_ccd)
	      .fold(PublicSeq::new(0_usize), |v, x| {
		  v.concat(&u64_to_be_bytes(x))
	      }),
      )
  }
#+end_src

#+begin_src rust :eval never

  #[cfg(not(feature = "hacspec"))]
  /// The state of the smart contract.
  /// This is the state that will be shown when the contract is queried using
  /// `concordium-client contract show`.
  #[contract_state(contract = "auction")]
  #[derive(Debug, Eq, PartialEq, Serialize, SchemaType)] // TODO: Debug, 
  pub struct State {
      /// Has the item been sold?
      auction_state: AuctionState,
      /// The highest bid so far (stored explicitly so that bidders can quickly
      /// see it)
      highest_bid:   Amount,
      /// The sold item (to be displayed to the auction participants), encoded in
      /// ASCII
      item:          Vec<u8>,
      /// Expiration time of the auction at which bids will be closed (to be
      /// displayed to the auction participants)
      expiry:        Timestamp,
      /// Keeping track of which account bid how much money
      // #[concordium(size_length = 2)] // TODO
      bids:          BTreeMap<AccountAddress, Amount>,
  }

  #[derive(Clone, PartialEq)]
  pub struct StateHacspec(
      pub AuctionStateHacspec,
      pub u64, // amount
      pub PublicByteSeq,
      pub u64, // timestamp
      pub SeqMap,
  );

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_state(s : StateHacspec) -> State {
      let StateHacspec(auction_state_hacspec, amount, item_seq, time, bid_map) = s;
      let auction_state = coerce_hacspec_to_rust_auction_state(auction_state_hacspec);
      let highest_bid = Amount { micro_ccd: amount };
      let item = item_seq.native_slice().to_vec();
      let expiry = Timestamp::from_timestamp_millis(time);
      let bids = coerce_hacspec_to_rust_b_tree_map(bid_map);

      State {
	  auction_state,
	  highest_bid,
	  item,
	  expiry,
	  bids,
      }
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_state(s : &State) -> StateHacspec {
      let auction_state = coerce_rust_to_hacspec_auction_state(&s.auction_state);
      let highest_bid = s.highest_bid.micro_ccd;
      let item = PublicByteSeq::from_native_slice(&s.item);
      let expiry = s.expiry.timestamp_millis();
      let bids = coerce_rust_to_hacspec_b_tree_map(&s.bids);

      StateHacspec (
	  auction_state,
	  highest_bid,
	  item,
	  expiry,
	  bids,
      )
  }

#+end_src

*** Fresh state function
#+begin_src rust :eval never
  pub fn fresh_state_hacspec(itm: PublicByteSeq, exp: u64) -> StateHacspec {
      StateHacspec(
	  AuctionStateHacspec::NotSoldYet,
	  0_u64,
	  itm,
	  exp,
	  SeqMap(PublicByteSeq::new(0_usize), PublicByteSeq::new(0_usize)),
      )
  }

  #[cfg(not(feature = "hacspec"))]
  /// A helper function to create a state for a new auction.
  fn fresh_state(itm: Vec<u8>, exp: Timestamp) -> State {
      coerce_hacspec_to_rust_state(fresh_state_hacspec(
	  PublicByteSeq::from_vec(itm),
	  exp.timestamp_millis(),
      ))
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Type of the parameter to the `init` function.
  #[derive(Serialize, SchemaType)]
  struct InitParameter {
      /// The item to be sold, as a sequence of ASCII codes.
      item: Vec<u8>,
      /// Time of the auction end in the RFC 3339 format (https://tools.ietf.org/html/rfc3339)
      expiry: Timestamp,
  }

#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Init function that creates a new auction
  #[init(contract = "auction", parameter = "InitParameter")]
  fn auction_init(ctx: &impl HasInitContext) -> InitResult<State> {
      let parameter: InitParameter = ctx.parameter_cursor().get()?;
      Ok(fresh_state(parameter.item, parameter.expiry))
  }
#+end_src

*** Seq map entry
#+begin_src rust :eval never  
  fn seq_map_entry(m: SeqMap, sender_address: UserAddress) -> (u64, SeqMap) {
      let SeqMap(m0, m1) = m;

      let mut res = // MapEntry::Entry
	  (
	  0_u64,
	  SeqMap(
	      m0.clone().concat(&sender_address),
	      m1.clone().concat(&u64_to_be_bytes(0_u64)),
	  ),
      );
      
      // TODO: use chunks instead of doing the math yourself
      for x in 0..m0.clone().len() / 32 {
	  if UserAddress::from_seq(&m0.clone().slice(x * 32, 32)) == sender_address {
	      res = // MapEntry::Entry
		  (
		  u64_from_be_bytes(u64Word::from_seq(&m1.clone().slice(x * 8, 8))),
		  SeqMap(m0.clone(), m1.clone()),
	      );
	  }
      }

      res
  }
#+end_src
*** Map Update and result type
#+begin_src rust :eval never
  #[derive(Clone, PartialEq)]
  pub enum MapUpdate {
      Update(u64, SeqMap),
  }

  fn seq_map_update_entry(m: SeqMap, sender_address: UserAddress, amount: u64) -> MapUpdate {
      let SeqMap(m0, m1) = m;

      let mut res = MapUpdate::Update(
	  amount,
	  SeqMap(
	      m0.clone().concat(&sender_address),
	      m1.clone().concat(&u64_to_be_bytes(amount)),
	  ),
      );

      // TODO: use chunks instead of doing the math yourself
      // !! Issue in for loop !! (update, updates the reference!)
      for x in 0..m0.clone().len() / 32 {
	  if UserAddress::from_seq(&m0.clone().slice(x * 32, 32)) == sender_address {
	      res = MapUpdate::Update(
		  amount,
		  SeqMap(
		      m0.clone().update(x * 32, &sender_address),
		      m1.clone().update(x * 8, &u64_to_be_bytes(amount)),
		  ),
	      );
	  }
      }

      res
  }
#+end_src
*** Auction bid and intermediate types
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// For errors in which the `bid` function can result
#[derive(Debug, PartialEq, Eq, Clone, Reject)]
enum BidError {
    ContractSender, // raised if a contract, as opposed to account, tries to bid
    BidTooLow,      /* { bid: Amount, highest_bid: Amount } */
    // raised if bid is lower than highest amount
    BidsOverWaitingForAuctionFinalization, // raised if bid is placed after auction expiry time
    AuctionFinalized,                      /* raised if bid is placed after auction has been
					    ,* finalized */
}

#[derive(Clone, PartialEq)]
pub enum BidErrorHacspec {
    ContractSender, // raised if a contract, as opposed to account, tries to bid
    BidTooLow,      /* { bid: Amount, highest_bid: Amount } */
    // raised if bid is lower than highest amount
    BidsOverWaitingForAuctionFinalization, // raised if bid is placed after auction expiry time
    AuctionIsFinalized,                    /* raised if bid is placed after auction has been
					    ,* finalized */
}

// TODO: Never used?
// #[cfg(not(feature = "hacspec"))]
// fn coerce_rust_to_hacspec_bid_error(b: BidError) -> BidErrorHacspec {
//     match b {
// 	BidError::ContractSender => BidErrorHacspec::ContractSender,
// 	BidError::BidTooLow => BidErrorHacspec::BidTooLow,
// 	BidError::BidsOverWaitingForAuctionFinalization => {
// 	    BidErrorHacspec::BidsOverWaitingForAuctionFinalization
// 	}
// 	BidError::AuctionFinalized => BidErrorHacspec::AuctionIsFinalized,
//     }
// }

#[cfg(not(feature = "hacspec"))]
fn coerce_hacspec_to_rust_bid_error(b: BidErrorHacspec) -> BidError {
    match b {
	BidErrorHacspec::ContractSender => BidError::ContractSender,
	BidErrorHacspec::BidTooLow => BidError::BidTooLow,
	BidErrorHacspec::BidsOverWaitingForAuctionFinalization => {
	    BidError::BidsOverWaitingForAuctionFinalization
	}
	BidErrorHacspec::AuctionIsFinalized => BidError::AuctionFinalized,
    }
}
#+end_src

#+begin_src rust
// pub type UserAddressSet = Option<UserAddress>;
#[derive(Clone, PartialEq)]
pub enum UserAddressSet {
    UserAddressSome(UserAddress),
    UserAddressNone,
}
pub type Context = (u64, UserAddressSet);
pub type AuctionBidResult = Result<StateHacspec, BidErrorHacspec>;

pub fn auction_bid_hacspec(ctx: Context, amount: u64, state: StateHacspec) -> AuctionBidResult {
    let StateHacspec(auction_state, highest_bid, st2, expiry, st4) = state.clone();

    if !(auction_state == AuctionStateHacspec::NotSoldYet) {
	AuctionBidResult::Err(BidErrorHacspec::AuctionIsFinalized)?;
    }

    let (slot_time, sender) = ctx;
    if !(slot_time <= expiry) {
	AuctionBidResult::Err(BidErrorHacspec::BidsOverWaitingForAuctionFinalization)?;
    }

    if sender == UserAddressSet::UserAddressNone {
	AuctionBidResult::Err(BidErrorHacspec::ContractSender)?;
    }

    let sender_address = match sender {
	UserAddressSet::UserAddressNone => UserAddress([
	    5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8,
	    5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8,
	    5_u8, 5_u8, 5_u8, 5_u8,
	]), // should never happen
	UserAddressSet::UserAddressSome(account_address) => account_address,
    };

    let (bid_to_update, _new_map) = // match
	  seq_map_entry(st4.clone(), sender_address) // {
      //     MapEntry::Entry(bid_to_update, new_map) => (bid_to_update, new_map),
      // }
      ;

    let (updated_bid, updated_map) =
	match seq_map_update_entry(st4.clone(), sender_address, bid_to_update + amount) {
	    MapUpdate::Update(updated_bid, updated_map) => (updated_bid, updated_map),
	};

    if !(updated_bid > highest_bid) {
	AuctionBidResult::Err(BidErrorHacspec::BidTooLow)?;
    }

    AuctionBidResult::Ok(StateHacspec(
	auction_state,
	updated_bid,
	st2,
	expiry,
	updated_map,
    ))
}

#[cfg(not(feature = "hacspec"))]
pub fn coerce_rust_to_hacspec_context(ctx: &impl HasReceiveContext) -> Context {
    (
	ctx.metadata().slot_time().timestamp_millis(),
	match ctx.sender() {
	    Address::Contract(_) => UserAddressSet::UserAddressNone,
	    Address::Account(account_address) => {
		UserAddressSet::UserAddressSome(coerce_rust_to_hacspec_account_address(&account_address))
	    }
	},
    )
}

#[cfg(not(feature = "hacspec"))]
/// Receive function in which accounts can bid before the auction end time
#[receive(contract = "auction", name = "bid", payable)]
fn auction_bid<A: HasActions>(
    ctx: &impl HasReceiveContext,
    amount: Amount,
    state: &mut State,
) -> Result<A, BidError> {
    let hacspec_state = coerce_rust_to_hacspec_state(state);

    let new_state = match auction_bid_hacspec(
	coerce_rust_to_hacspec_context(ctx),
	amount.micro_ccd,
	hacspec_state,
    ) {
	Ok (a) => a,
	Err (e) => return Err (coerce_hacspec_to_rust_bid_error(e)),
    };

    ,*state = coerce_hacspec_to_rust_state(new_state);

    Ok (A::accept())
}
#+end_src

*** Finalize function and types
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// For errors in which the `finalize` function can result
#[derive(Debug, PartialEq, Eq, Clone, Reject)]
enum FinalizeError {
    BidMapError,        /* raised if there is a mistake in the bid map that keeps track of all
			 ,* accounts' bids */
    AuctionStillActive, // raised if there is an attempt to finalize the auction before its expiry
    AuctionFinalized,   // raised if there is an attempt to finalize an already finalized auction
}

/// For errors in which the `finalize` function can result
#[derive(Clone, PartialEq)]
pub enum FinalizeErrorHacspec {
    BidMapError,
    AuctionStillActive,
    AuctionFinalized,
}

// TODO: never used
// #[cfg(not(feature = "hacspec"))]
// fn coerce_rust_to_hacspec_finalize_error(fe: FinalizeError) -> FinalizeErrorHacspec {
//     match fe {
// 	FinalizeError::BidMapError => FinalizeErrorHacspec::BidMapError,
// 	FinalizeError::AuctionStillActive => FinalizeErrorHacspec::AuctionStillActive,
// 	FinalizeError::AuctionFinalized => FinalizeErrorHacspec::AuctionFinalized,
//     }
// }

#[cfg(not(feature = "hacspec"))]
fn coerce_hacspec_to_rust_finalize_error(fe: FinalizeErrorHacspec) -> FinalizeError {
    match fe {
	FinalizeErrorHacspec::BidMapError => FinalizeError::BidMapError,
	FinalizeErrorHacspec::AuctionStillActive => FinalizeError::AuctionStillActive,
	FinalizeErrorHacspec::AuctionFinalized => FinalizeError::AuctionFinalized,
    }
}

#+end_src

#+begin_src rust :eval never
  pub type FinalizeContext = (u64, UserAddress, u64);

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_finalize_context(ctx: &impl HasReceiveContext) -> FinalizeContext {
    (
	ctx.metadata().slot_time().timestamp_millis(),
	coerce_rust_to_hacspec_account_address(&ctx.owner()),
	ctx.self_balance().micro_ccd,
    )
  }

    // let slot_time = ctx.metadata().slot_time();
    // ensure!(slot_time > state.expiry, FinalizeError::AuctionStillActive);

    // let owner = ctx.owner();

    // let balance = ctx.self_balance();

#+end_src

#+begin_src rust :eval never
#[derive(Clone, PartialEq)]
pub enum FinalizeAction {
    Accept,
    SimpleTransfer(PublicByteSeq),
}

#[derive(Clone, PartialEq)]
pub enum BidRemain {
    BidNone,
    BidSome(u64),
}

pub type AuctionFinalizeResult = Result<(StateHacspec, FinalizeAction), FinalizeErrorHacspec>;
// pub type BidRemain = Option<(UserAddress, u64)>;

pub fn auction_finalize_hacspec(
    ctx: FinalizeContext,
    state: StateHacspec,
) -> AuctionFinalizeResult {
    let StateHacspec(mut auction_state, highest_bid, st2, expiry, SeqMap(m0, m1)) = state.clone();

    let mut result = AuctionFinalizeResult::Ok((state.clone(), FinalizeAction::Accept));

    if !(auction_state == AuctionStateHacspec::NotSoldYet) {
        AuctionFinalizeResult::Err(FinalizeErrorHacspec::AuctionFinalized)?;
    }

    let (slot_time, owner, balance) = ctx;

    if !(slot_time > expiry) {
        AuctionFinalizeResult::Err(FinalizeErrorHacspec::AuctionStillActive)?;
    }

    if balance != 0_u64 {
        let mut return_action = FinalizeAction::SimpleTransfer(
            PublicByteSeq::new(0_usize)
                .concat(&owner)
                .concat(&u64_to_be_bytes(highest_bid)),
        );
        let mut remaining_bid = BidRemain::BidNone;
        // Return bids that are smaller than highest
        // let x = 0;
        for x in 0..m0.clone().len() / 32 {
            let addr = UserAddress::from_seq(&m0.clone().slice(x * 32, 32));
            let amnt = u64_from_be_bytes(u64Word::from_seq(&m1.clone().slice(x * 8, 8)));
            if amnt < highest_bid {
                return_action = match return_action {
                    FinalizeAction::Accept => FinalizeAction::Accept, // TODO: What error (should never happen)..
                    FinalizeAction::SimpleTransfer(m) => FinalizeAction::SimpleTransfer(
                        m.concat(&addr).concat(&u64_to_be_bytes(amnt)),
                    ),
                };
            } else {
                // ensure!(remaining_bid.is_none(), FinalizeErrorHacspec::BidMapError);
                if !(remaining_bid == BidRemain::BidNone) {
                    AuctionFinalizeResult::Err(FinalizeErrorHacspec::BidMapError)?;
                }
                auction_state = AuctionStateHacspec::Sold(addr);
                remaining_bid = BidRemain::BidSome(amnt);
            }
        }

        // ensure that the only bidder left in the map is the one with the highest bid
        result = match remaining_bid {
            BidRemain::BidSome(amount) =>
            // ensure!(amount == state.highest_bid, FinalizeErrorHacspec::BidMapError);
            {
                if !(amount == highest_bid) {
                    AuctionFinalizeResult::Err(FinalizeErrorHacspec::BidMapError)
                } else {
                    AuctionFinalizeResult::Ok((
                        StateHacspec(
                            auction_state,
                            highest_bid,
                            st2,
                            expiry,
                            SeqMap(m0.clone(), m1.clone()),
                        ),
                        return_action,
                    ))
                }
            }
            BidRemain::BidNone => AuctionFinalizeResult::Err(FinalizeErrorHacspec::BidMapError),
        };

        result.clone()?;
    }

    result
}

#[cfg(not(feature = "hacspec"))]
fn simple_transfer_from_index_and_seq<A: HasActions>(x: usize, s: PublicByteSeq) -> A {
    A::simple_transfer(
        &coerce_hacspec_to_rust_account_address(UserAddress::from_seq(
            &s.slice(x * (32 + 8), 32), // TODO: use chunks instead of doing the math yourself
        )),
        Amount {
            micro_ccd: u64_from_be_bytes(u64Word::from_seq(&s.slice(x * (32 + 8) + 32, 8))),
        },
    )
}

#[cfg(not(feature = "hacspec"))]
/// Receive function used to finalize the auction, returning all bids to their
/// senders, except for the winning bid
#[receive(contract = "auction", name = "finalize")]
fn auction_finalize<A: HasActions>(
    ctx: &impl HasReceiveContext,
    state: &mut State,
) -> Result<A, FinalizeError> {
    let hacspec_state = coerce_rust_to_hacspec_state(state);

    let (new_state, fa) =
        match auction_finalize_hacspec(coerce_rust_to_hacspec_finalize_context(ctx), hacspec_state)
        {
            Ok(a) => a,
            Err(e) => return Err(coerce_hacspec_to_rust_finalize_error(e)),
        };

    ,*state = coerce_hacspec_to_rust_state(new_state);

    match fa {
        FinalizeAction::Accept => Ok(A::accept()),
        FinalizeAction::SimpleTransfer(s) => Ok((1..s.len() / (32 + 8))
            .fold(simple_transfer_from_index_and_seq(0, s.clone()), |t, x| {
                t.and_then(simple_transfer_from_index_and_seq(x, s.clone()))
            })),
    }
}
#+end_src
*** Rust Tests
#+begin_src rust :eval never
#[cfg(test)]
extern crate quickcheck;
#[cfg(test)]
#[macro_use(quickcheck)]
extern crate quickcheck_macros;

#[cfg(test)]
use quickcheck::*;

#[ensures(result == true)]
#[cfg(test)]
#[proof]
#[quickcheck]
/// Test that the smart-contract initialization sets the state correctly
/// (no bids, active state, indicated auction-end time and item name).
pub fn auction_test_init(item: PublicByteSeq, time : u64) -> bool {
    fresh_state_hacspec(item.clone(), time)
	== StateHacspec(
	    AuctionStateHacspec::NotSoldYet,
	    0_u64,
	    item.clone(),
	    time,
	    SeqMap(PublicByteSeq::new(0_usize), PublicByteSeq::new(0_usize)),
	)
}


#[cfg(test)]
#[proof]
fn verify_bid(
    item: PublicByteSeq,
    state: StateHacspec,
    account: UserAddress,
    ctx: Context,
    amount: u64,
    bid_map: SeqMap,
    highest_bid: u64,
    time : u64,
) -> (StateHacspec, SeqMap, bool, bool) {
    let t = auction_bid_hacspec(ctx, amount, state.clone());

    let (state, res) = match t {
	AuctionBidResult::Err(_e) => (state, false),
	AuctionBidResult::Ok(s) => (s, true),
    };

    let bid_map = match seq_map_update_entry(bid_map.clone(), account, highest_bid) {
	MapUpdate::Update(_, updated_map) => updated_map,
    };

    (
	state.clone(),
	bid_map.clone(),
	res,
	state.clone()
	    == StateHacspec(
		AuctionStateHacspec::NotSoldYet,
		highest_bid,
		item.clone(),
		time,
		bid_map.clone(),
	    ),
    )
}


#[cfg(test)]
#[proof]
fn useraddress_from_u8(i : u8) -> UserAddress {
    UserAddress([
	i, i, i, i, i, i, i, i, i, i, i, i, i, i, i,
	i, i, i, i, i, i, i, i, i, i, i, i, i, i, i,
	i, i,
    ])
}


#[cfg(test)]
#[proof]
  fn new_account(time : u64, i : u8) -> (UserAddress, Context) {
    let addr = useraddress_from_u8(i);
    let ctx = (time, UserAddressSet::UserAddressSome(addr));
    (addr, ctx)
}

#[cfg(test)]
#[proof]
// #[quickcheck]
// #[test]
/// Test a sequence of bids and finalizations:
/// 0. Auction is initialized.
/// 1. Alice successfully bids 0.1 GTU.
/// 2. Alice successfully bids another 0.1 GTU, highest bid becomes 0.2 GTU
/// (the sum of her two bids). 3. Bob successfully bids 0.3 GTU, highest
/// bid becomes 0.3 GTU. 4. Someone tries to finalize the auction before
/// its end time. Attempt fails. 5. Dave successfully finalizes the
/// auction after its end time.    Alice gets her money back, while
/// Carol (the owner of the contract) collects the highest bid amount.
/// 6. Attempts to subsequently bid or finalize fail.
// TODO: Requires
// #[requires(18446744073709551615u64 > time)]
// #[requires(18446744073709551615u64 / 5u64 - 1u64 > input_amount)]
#[ensures(result == true)]
#[quickcheck]
fn test_auction_bid_and_finalize(item: PublicByteSeq, time : u64, input_amount : u64) -> bool {
    let time = if time == 18446744073709551615u64 { 18446744073709551614u64 } else { time }; // Can overflow !
    let input_amount : u64 = if input_amount > 18446744073709551615u64 / 5u64 - 1u64 { 100u64 } else { input_amount };

    let amount = input_amount + 1_u64;
    let winning_amount = amount * 3_u64; // 300_u64;
    let big_amount = amount * 5_u64; // 500_u64;

    let bid_map = SeqMap(PublicByteSeq::new(0_usize), PublicByteSeq::new(0_usize));

    // initializing auction
    let state = fresh_state_hacspec(item.clone(), time); // mut

    // 1st bid: account1 bids amount1
    let (alice, alice_ctx) = new_account(time, 0_u8);

    let (ac0, ac1) = alice_ctx;

    let (state, bid_map, _res_0, result_0) = verify_bid(
	item.clone(),
	state,
	alice,
	(ac0.clone(), ac1.clone()),
	amount,
	bid_map,
	amount,
	time,
    );

    // // 2nd bid: account1 bids `amount` again
    // // should work even though it's the same amount because account1 simply
    // // increases their bid
    let (state, bid_map, _res_1, result_1) = verify_bid(
	item.clone(),
	state,
	alice,
	(ac0.clone(), ac1.clone()),
	amount,
	bid_map,
	amount + amount,
	time,
    );

    // // 3rd bid: second account
    let (bob, bob_ctx) = new_account(time, 1_u8); // first argument is slot time
    let (bc1, bc2) = bob_ctx;

    let (state, bid_map, _res_2, result_2) = verify_bid(
	item.clone(),
	state,
	bob,
	(bc1.clone(), bc2.clone()),
	winning_amount,
	bid_map,
	winning_amount,
	time,
    );

    let owner = useraddress_from_u8(0_u8);

    // let sender = owner;
    let balance = 100_u64;
    let ctx4 = (time, owner, balance);

    let finres = auction_finalize_hacspec(ctx4, state.clone());
    let (state, result_3) = match finres {
	AuctionFinalizeResult::Err(err) => (
	    state.clone(),
	    err == FinalizeErrorHacspec::AuctionStillActive
	),
	AuctionFinalizeResult::Ok((state, _)) => (state, false),
    };

    // // finalizing auction
    // let carol = new_account();
    let (carol, _carol_ctx) = new_account(time, 2_u8);

    let ctx5 = (time + 1_u64, carol, winning_amount);
    let finres2 = auction_finalize_hacspec(ctx5, state.clone());

    let (state, result_4) = match finres2 {
	AuctionFinalizeResult::Err(_) => (state.clone(), false),
	AuctionFinalizeResult::Ok((state, action)) => (
	    state,
	    action
		== FinalizeAction::SimpleTransfer(
		    PublicByteSeq::new(0_usize)
			.concat(&carol)
			.concat(&u64_to_be_bytes(winning_amount))
			.concat(&alice)
			.concat(&u64_to_be_bytes(amount + amount)),
		),
	),
    };

    let result_5 = state.clone()
	== StateHacspec(
	    AuctionStateHacspec::Sold(bob),
	    winning_amount,
	    item.clone(),
	    time,
	    bid_map.clone(),
	);

    // attempting to finalize auction again should fail
    let finres3 = auction_finalize_hacspec(ctx5, state.clone());

    let (state, result_6) = match finres3 {
	AuctionFinalizeResult::Err(err) => (state, err == FinalizeErrorHacspec::AuctionFinalized),
	AuctionFinalizeResult::Ok((state, _action)) => (state, false),
    };

    let t = auction_bid_hacspec((bc1.clone(), bc2.clone()), big_amount, state.clone());

    // let result_7 = t == AuctionBidResult::Err (BidErrorHacspec::AuctionIsFinalized);
    let result_7 = match t {
	AuctionBidResult::Err(e) => e == BidErrorHacspec::AuctionIsFinalized,
	AuctionBidResult::Ok(_) => false,
    };

    result_0 && result_1 && result_2 && result_3 && result_4 && result_5 && result_6 && result_7
}
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  #[cfg(test)]
  mod tests {
      use super::*;
      use std::sync::atomic::{AtomicU8, Ordering};
      use test_infrastructure::*;

      // A counter for generating new account addresses
      static ADDRESS_COUNTER: AtomicU8 = AtomicU8::new(0);
      const AUCTION_END: u64 = 1;
      const ITEM: &str = "Starry night by Van Gogh";

      fn dummy_fresh_state() -> State {
	  dummy_active_state(Amount::zero(), BTreeMap::new())
      }

      fn dummy_active_state(highest: Amount, bids: BTreeMap<AccountAddress, Amount>) -> State {
	  State {
	      auction_state: AuctionState::NotSoldYet,
	      highest_bid: highest,
	      item: ITEM.as_bytes().to_vec(),
	      expiry: Timestamp::from_timestamp_millis(AUCTION_END),
	      bids,
	  }
      }

      fn expect_error<E, T>(expr: Result<T, E>, err: E, msg: &str)
      where
	  E: Eq + Debug,
	  T: Debug,
      {
	  let actual = expr.expect_err(msg);
	  assert_eq!(actual, err);
      }

      fn item_expiry_parameter() -> InitParameter {
	  InitParameter {
	      item: ITEM.as_bytes().to_vec(),
	      expiry: Timestamp::from_timestamp_millis(AUCTION_END),
	  }
      }

      fn create_parameter_bytes(parameter: &InitParameter) -> Vec<u8> {
	  to_bytes(parameter)
      }

      fn parametrized_init_ctx<'a>(parameter_bytes: &'a Vec<u8>) -> InitContextTest<'a> {
	  let mut ctx = InitContextTest::empty();
	  ctx.set_parameter(parameter_bytes);
	  ctx
      }

      fn new_account() -> AccountAddress {
	  let account = AccountAddress([ADDRESS_COUNTER.load(Ordering::SeqCst); 32]);
	  ADDRESS_COUNTER.fetch_add(1, Ordering::SeqCst);
	  account
      }

      fn new_account_ctx<'a>() -> (AccountAddress, ReceiveContextTest<'a>) {
	  let account = new_account();
	  let ctx = new_ctx(account, account, AUCTION_END);
	  (account, ctx)
      }

      fn new_ctx<'a>(
	  owner: AccountAddress,
	  sender: AccountAddress,
	  slot_time: u64,
      ) -> ReceiveContextTest<'a> {
	  let mut ctx = ReceiveContextTest::empty();
	  ctx.set_sender(Address::Account(sender));
	  ctx.set_owner(owner);
	  ctx.set_metadata_slot_time(Timestamp::from_timestamp_millis(slot_time));
	  ctx
      }

      #[test]
      /// Test that the smart-contract initialization sets the state correctly
      /// (no bids, active state, indicated auction-end time and item name).
      fn test_init() {
	  let parameter_bytes = create_parameter_bytes(&item_expiry_parameter());
	  let ctx = parametrized_init_ctx(&parameter_bytes);

	  let state_result = auction_init(&ctx);
	  let state = state_result.expect("Contract initialization results in error");
	  assert_eq!(
	      state,
	      dummy_fresh_state(),
	      "Auction state should be new after initialization"
	  );
      }

      #[test]
      /// Test a sequence of bids and finalizations:
      /// 0. Auction is initialized.
      /// 1. Alice successfully bids 0.1 GTU.
      /// 2. Alice successfully bids another 0.1 GTU, highest bid becomes 0.2 GTU
      /// (the sum of her two bids). 3. Bob successfully bids 0.3 GTU, highest
      /// bid becomes 0.3 GTU. 4. Someone tries to finalize the auction before
      /// its end time. Attempt fails. 5. Dave successfully finalizes the
      /// auction after its end time.    Alice gets her money back, while
      /// Carol (the owner of the contract) collects the highest bid amount.
      /// 6. Attempts to subsequently bid or finalize fail.
      fn test_auction_bid_and_finalize() {
	  let parameter_bytes = create_parameter_bytes(&item_expiry_parameter());
	  let ctx0 = parametrized_init_ctx(&parameter_bytes);

	  let amount = Amount::from_micro_ccd(100);
	  let winning_amount = Amount::from_micro_ccd(300);
	  let big_amount = Amount::from_micro_ccd(500);

	  let mut bid_map = BTreeMap::new();

	  // initializing auction
	  let mut state = auction_init(&ctx0).expect("Initialization should pass");

	  // 1st bid: account1 bids amount1
	  let (alice, alice_ctx) = new_account_ctx();
	  verify_bid(&mut state, alice, &alice_ctx, amount, &mut bid_map, amount);

	  // 2nd bid: account1 bids `amount` again
	  // should work even though it's the same amount because account1 simply
	  // increases their bid
	  verify_bid(
	      &mut state,
	      alice,
	      &alice_ctx,
	      amount,
	      &mut bid_map,
	      amount + amount,
	  );


	  // 3rd bid: second account
	  let (bob, bob_ctx) = new_account_ctx();
	  verify_bid(
	      &mut state,
	      bob,
	      &bob_ctx,
	      winning_amount,
	      &mut bid_map,
	      winning_amount,
	  );

	  // trying to finalize auction that is still active
	  // (specifically, the bid is submitted at the last moment, at the AUCTION_END
	  // time)
	  let mut ctx4 = ReceiveContextTest::empty();
	  ctx4.set_metadata_slot_time(Timestamp::from_timestamp_millis(AUCTION_END));
	  ctx4.set_owner(bob); // TODO: If not set fails in coercion value never used because it fails early. Is this a bug in the implementation or a feature that needs to be mimiced in hacspec.
	  ctx4.set_self_balance(winning_amount); // TODO: If not set fails in coercion value never used because it fails early. Is this a bug in the implementation or a feature that needs to be mimiced in hacspec.
	  let finres: Result<ActionsTree, _> = auction_finalize(&ctx4, &mut state);
	  expect_error(
	      finres,
	      FinalizeError::AuctionStillActive,
	      "Finalizing auction should fail when it's before auction-end time",
	  );

	  // finalizing auction
	  let carol = new_account();
	  let dave = new_account();
	  let mut ctx5 = new_ctx(carol, dave, AUCTION_END + 1);
	  ctx5.set_self_balance(winning_amount);
	  let finres2: Result<ActionsTree, _> = auction_finalize(&ctx5, &mut state);
	  let actions = finres2.expect("Finalizing auction should work");
	  assert_eq!(
	      actions,
	      ActionsTree::simple_transfer(&carol, winning_amount)
		  .and_then(ActionsTree::simple_transfer(&alice, amount + amount))
	  );

	  assert_eq!(
	      state,
	      State {
		  auction_state: AuctionState::Sold(bob),
		  highest_bid: winning_amount,
		  item: ITEM.as_bytes().to_vec(),
		  expiry: Timestamp::from_timestamp_millis(AUCTION_END),
		  bids: bid_map,
	      }
	  );


	  // attempting to finalize auction again should fail
	  let finres3: Result<ActionsTree, _> = auction_finalize(&ctx5, &mut state);
	  expect_error(
	      finres3,
	      FinalizeError::AuctionFinalized,
	      "Finalizing auction a second time should fail",
	  );

	  // attempting to bid again should fail
	  let res4: Result<ActionsTree, _> = auction_bid(&bob_ctx, big_amount, &mut state);
	  expect_error(
	      res4,
	      BidError::AuctionFinalized,
	      "Bidding should fail because the auction is finalized",
	  );
      }

      fn verify_bid(
	  mut state: &mut State,
	  account: AccountAddress,
	  ctx: &ContextTest<ReceiveOnlyDataTest>,
	  amount: Amount,
	  bid_map: &mut BTreeMap<AccountAddress, Amount>,
	  highest_bid: Amount,
      ) {
	  let res: Result<ActionsTree, _> = auction_bid(ctx, amount, &mut state);
	  res.expect("Bidding should pass");
	  bid_map.insert(account, highest_bid);
	  assert_eq!(*state, dummy_active_state(highest_bid, bid_map.clone()));
      }

      #[test]
      /// Bids for amounts lower or equal to the highest bid should be rejected.
      fn test_auction_bid_repeated_bid() {
	  let (account1, ctx1) = new_account_ctx();
	  let ctx2 = new_account_ctx().1;

	  let parameter_bytes = create_parameter_bytes(&item_expiry_parameter());
	  let ctx0 = parametrized_init_ctx(&parameter_bytes);

	  let amount = Amount::from_micro_ccd(100);

	  let mut bid_map = BTreeMap::new();

	  // initializing auction
	  let mut state = auction_init(&ctx0).expect("Init results in error");

	  // 1st bid: account1 bids amount1
	  verify_bid(&mut state, account1, &ctx1, amount, &mut bid_map, amount);

	  // 2nd bid: account2 bids amount1
	  // should fail because amount is equal to highest bid
	  let res2: Result<ActionsTree, _> = auction_bid(&ctx2, amount, &mut state);
	  expect_error(
	      res2,
	      BidError::BidTooLow, /* { bid: amount, highest_bid: amount } */
	      "Bidding 2 should fail because bid amount must be higher than highest bid",
	  );
      }

      #[test]
      /// Bids for 0 GTU should be rejected.
      fn test_auction_bid_zero() {
	  let ctx1 = new_account_ctx().1;
	  let parameter_bytes = create_parameter_bytes(&item_expiry_parameter());
	  let ctx = parametrized_init_ctx(&parameter_bytes);

	  let mut state = auction_init(&ctx).expect("Init results in error");

	  let res: Result<ActionsTree, _> = auction_bid(&ctx1, Amount::zero(), &mut state);
	  expect_error(
	      res,
	      BidError::BidTooLow, /* { bid: Amount::zero(), highest_bid: Amount::zero()} */
	      "Bidding zero should fail",
	  );
      }
  }
#+end_src

** Generation of backend output

#+begin_src elisp :var SOURCE-CODE-FILE="Auction.v" :results output silent :tangle no
(org-babel-detangle SOURCE-CODE-FILE)
#+end_src

***  - Coq code
:PROPERTIES:
:header-args: coq :tangle Auction.v :mkdirp yes :comments link
:header-args: coq :eval never :results output silent
:END:

#+begin_src coq
(** This file was automatically generated using Hacspec **)
Require Import Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.
From QuickChick Require Import QuickChick.
Require Import QuickChickLib.
#+end_src

#+begin_src coq
Require Import Hacspec.Lib.
#+end_src

#+begin_src coq
Definition user_address_t := nseq (int8) (usize 32).
#+end_src

#+begin_src coq
Inductive auction_state_hacspec_t :=
| NotSoldYet : auction_state_hacspec_t
| Sold : user_address_t -> auction_state_hacspec_t.

Definition eqb_auction_state_hacspec_t (x y : auction_state_hacspec_t) : bool :=
match x with
   | NotSoldYet => match y with | NotSoldYet=> true | _ => false end
   | Sold a => match y with | Sold b => a =.? b | _ => false end
   end.

Definition eqb_leibniz_auction_state_hacspec_t (x y : auction_state_hacspec_t) : eqb_auction_state_hacspec_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_auction_state_hacspec_t : EqDec (auction_state_hacspec_t) :=
Build_EqDec (auction_state_hacspec_t) (eqb_auction_state_hacspec_t) (eqb_leibniz_auction_state_hacspec_t).

Global Instance show_auction_state_hacspec_t : Show (auction_state_hacspec_t) :=
 @Build_Show (auction_state_hacspec_t) (fun x =>
 match x with
 NotSoldYet => ("NotSoldYet")%string
 | Sold a => ("Sold" ++ show a)%string
 end).
Definition g_auction_state_hacspec_t : G (auction_state_hacspec_t) := oneOf_ (returnGen NotSoldYet) [returnGen NotSoldYet;bindGen arbitrary (fun a => returnGen (Sold a))].
Global Instance gen_auction_state_hacspec_t : Gen (auction_state_hacspec_t) := Build_Gen auction_state_hacspec_t g_auction_state_hacspec_t.
#+end_src

#+begin_src coq
Inductive seq_map_t :=
| SeqMap : (public_byte_seq × public_byte_seq) -> seq_map_t.

Definition eqb_seq_map_t (x y : seq_map_t) : bool :=
match x with
   | SeqMap a => match y with | SeqMap b => a =.? b end
   end.

Definition eqb_leibniz_seq_map_t (x y : seq_map_t) : eqb_seq_map_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_seq_map_t : EqDec (seq_map_t) :=
Build_EqDec (seq_map_t) (eqb_seq_map_t) (eqb_leibniz_seq_map_t).

Global Instance show_seq_map_t : Show (seq_map_t) :=
 @Build_Show (seq_map_t) (fun x =>
 match x with
 SeqMap a => ("SeqMap" ++ show a)%string
 end).
Definition g_seq_map_t : G (seq_map_t) := oneOf_ (bindGen arbitrary (fun a => returnGen (SeqMap a))) [bindGen arbitrary (fun a => returnGen (SeqMap a))].
Global Instance gen_seq_map_t : Gen (seq_map_t) := Build_Gen seq_map_t g_seq_map_t.
#+end_src

#+begin_src coq
Inductive state_hacspec_t :=
| StateHacspec : (
  auction_state_hacspec_t ×
  int64 ×
  public_byte_seq ×
  int64 ×
  seq_map_t
) -> state_hacspec_t.

Definition eqb_state_hacspec_t (x y : state_hacspec_t) : bool :=
match x with
   | StateHacspec a => match y with | StateHacspec b => a =.? b end
   end.

Definition eqb_leibniz_state_hacspec_t (x y : state_hacspec_t) : eqb_state_hacspec_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_state_hacspec_t : EqDec (state_hacspec_t) :=
Build_EqDec (state_hacspec_t) (eqb_state_hacspec_t) (eqb_leibniz_state_hacspec_t).

Global Instance show_state_hacspec_t : Show (state_hacspec_t) :=
 @Build_Show (state_hacspec_t) (fun x =>
 match x with
 StateHacspec a => ("StateHacspec" ++ show a)%string
 end).
Definition g_state_hacspec_t : G (state_hacspec_t) := oneOf_ (bindGen arbitrary (fun a => returnGen (StateHacspec a))) [bindGen arbitrary (fun a => returnGen (StateHacspec a))].
Global Instance gen_state_hacspec_t : Gen (state_hacspec_t) := Build_Gen state_hacspec_t g_state_hacspec_t.
#+end_src

#+begin_src coq
Definition fresh_state_hacspec
  (itm_0 : public_byte_seq)
  (exp_1 : int64)
  : state_hacspec_t :=
  StateHacspec ((
      NotSoldYet,
      @repr WORDSIZE64 0,
      itm_0,
      exp_1,
      SeqMap ((seq_new_ (default) (usize 0), seq_new_ (default) (usize 0)))
    )).
#+end_src

#+begin_src coq
Definition seq_map_entry
  (m_2 : seq_map_t)
  (sender_address_3 : user_address_t)
  : (int64 × seq_map_t) :=
  let 'SeqMap ((m0_4, m1_5)) :=
    m_2 in 
  let res_6 : (int64 × seq_map_t) :=
    (
      @repr WORDSIZE64 0,
      SeqMap ((
	  seq_concat ((m0_4)) (sender_address_3),
	  seq_concat ((m1_5)) (u64_to_be_bytes (@repr WORDSIZE64 0))
	))
    ) in 
  let res_6 :=
    foldi (usize 0) ((seq_len ((m0_4))) / (usize 32)) (fun x_7 res_6 =>
      let '(res_6) :=
	if (array_from_seq (32) (seq_slice ((m0_4)) ((x_7) * (usize 32)) (
	      usize 32))) array_eq (sender_address_3):bool then (let res_6 :=
	    (
	      u64_from_be_bytes (array_from_seq (8) (seq_slice ((m1_5)) ((
		      x_7) * (usize 8)) (usize 8))),
	      SeqMap (((m0_4), (m1_5)))
	    ) in 
	  (res_6)) else ((res_6)) in 
      (res_6))
    res_6 in 
  res_6.
#+end_src

#+begin_src coq
Inductive map_update_t :=
| Update : (int64 × seq_map_t) -> map_update_t.

Definition eqb_map_update_t (x y : map_update_t) : bool :=
match x with
   | Update a => match y with | Update b => a =.? b end
   end.

Definition eqb_leibniz_map_update_t (x y : map_update_t) : eqb_map_update_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_map_update_t : EqDec (map_update_t) :=
Build_EqDec (map_update_t) (eqb_map_update_t) (eqb_leibniz_map_update_t).

Global Instance show_map_update_t : Show (map_update_t) :=
 @Build_Show (map_update_t) (fun x =>
 match x with
 Update a => ("Update" ++ show a)%string
 end).
Definition g_map_update_t : G (map_update_t) := oneOf_ (bindGen arbitrary (fun a => returnGen (Update a))) [bindGen arbitrary (fun a => returnGen (Update a))].
Global Instance gen_map_update_t : Gen (map_update_t) := Build_Gen map_update_t g_map_update_t.
#+end_src

#+begin_src coq
Definition seq_map_update_entry
  (m_8 : seq_map_t)
  (sender_address_9 : user_address_t)
  (amount_10 : int64)
  : map_update_t :=
  let 'SeqMap ((m0_11, m1_12)) :=
    m_8 in 
  let res_13 : map_update_t :=
    Update ((
	amount_10,
	SeqMap ((
	    seq_concat ((m0_11)) (sender_address_9),
	    seq_concat ((m1_12)) (u64_to_be_bytes (amount_10))
	  ))
      )) in 
  let res_13 :=
    foldi (usize 0) ((seq_len ((m0_11))) / (usize 32)) (fun x_14 res_13 =>
      let '(res_13) :=
	if (array_from_seq (32) (seq_slice ((m0_11)) ((x_14) * (usize 32)) (
	      usize 32))) array_eq (sender_address_9):bool then (let res_13 :=
	    Update ((
		amount_10,
		SeqMap ((
		    seq_update ((m0_11)) ((x_14) * (usize 32)) (
		      sender_address_9),
		    seq_update ((m1_12)) ((x_14) * (usize 8)) (u64_to_be_bytes (
			amount_10))
		  ))
	      )) in 
	  (res_13)) else ((res_13)) in 
      (res_13))
    res_13 in 
  res_13.
#+end_src

#+begin_src coq
Inductive bid_error_hacspec_t :=
| ContractSender : bid_error_hacspec_t
| BidTooLow : bid_error_hacspec_t
| BidsOverWaitingForAuctionFinalization : bid_error_hacspec_t
| AuctionIsFinalized : bid_error_hacspec_t.

Definition eqb_bid_error_hacspec_t (x y : bid_error_hacspec_t) : bool :=
match x with
   | ContractSender => match y with | ContractSender=> true | _ => false end
   | BidTooLow => match y with | BidTooLow=> true | _ => false end
   | BidsOverWaitingForAuctionFinalization =>
       match y with
       | BidsOverWaitingForAuctionFinalization=> true
       | _ => false
       end
   | AuctionIsFinalized =>
       match y with
       | AuctionIsFinalized=> true
       | _ => false
       end
   end.

Definition eqb_leibniz_bid_error_hacspec_t (x y : bid_error_hacspec_t) : eqb_bid_error_hacspec_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_bid_error_hacspec_t : EqDec (bid_error_hacspec_t) :=
Build_EqDec (bid_error_hacspec_t) (eqb_bid_error_hacspec_t) (eqb_leibniz_bid_error_hacspec_t).

Global Instance show_bid_error_hacspec_t : Show (bid_error_hacspec_t) :=
 @Build_Show (bid_error_hacspec_t) (fun x =>
 match x with
 ContractSender => ("ContractSender")%string
 | BidTooLow => ("BidTooLow")%string
 | BidsOverWaitingForAuctionFinalization => (
   "BidsOverWaitingForAuctionFinalization")%string
 | AuctionIsFinalized => ("AuctionIsFinalized")%string
 end).
Definition g_bid_error_hacspec_t : G (bid_error_hacspec_t) := oneOf_ (returnGen ContractSender) [returnGen ContractSender;returnGen BidTooLow;returnGen BidsOverWaitingForAuctionFinalization;returnGen AuctionIsFinalized].
Global Instance gen_bid_error_hacspec_t : Gen (bid_error_hacspec_t) := Build_Gen bid_error_hacspec_t g_bid_error_hacspec_t.
#+end_src

#+begin_src coq
Inductive user_address_set_t :=
| UserAddressSome : user_address_t -> user_address_set_t
| UserAddressNone : user_address_set_t.

Definition eqb_user_address_set_t (x y : user_address_set_t) : bool :=
match x with
   | UserAddressSome a =>
       match y with
       | UserAddressSome b => a =.? b
       | _ => false
       end
   | UserAddressNone => match y with | UserAddressNone=> true | _ => false end
   end.

Definition eqb_leibniz_user_address_set_t (x y : user_address_set_t) : eqb_user_address_set_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_user_address_set_t : EqDec (user_address_set_t) :=
Build_EqDec (user_address_set_t) (eqb_user_address_set_t) (eqb_leibniz_user_address_set_t).

Global Instance show_user_address_set_t : Show (user_address_set_t) :=
 @Build_Show (user_address_set_t) (fun x =>
 match x with
 UserAddressSome a => ("UserAddressSome" ++ show a)%string
 | UserAddressNone => ("UserAddressNone")%string
 end).
Definition g_user_address_set_t : G (user_address_set_t) := oneOf_ (bindGen arbitrary (fun a => returnGen (UserAddressSome a))) [bindGen arbitrary (fun a => returnGen (UserAddressSome a));returnGen UserAddressNone].
Global Instance gen_user_address_set_t : Gen (user_address_set_t) := Build_Gen user_address_set_t g_user_address_set_t.
#+end_src

#+begin_src coq
Notation "'context_t'" := ((int64 × user_address_set_t)) : hacspec_scope.
Instance show_context_t : Show (context_t) :=
Build_Show context_t (fun x =>
  let (x, x0) := x in
  (("(") ++ ((show x) ++ ((",") ++ ((show x0) ++ (")"))))))%string.
Definition g_context_t : G (context_t) :=
bindGen arbitrary (fun x0 : int64 =>
  bindGen arbitrary (fun x1 : user_address_set_t =>
  returnGen (x0,x1))).
Instance gen_context_t : Gen (context_t) := Build_Gen context_t g_context_t.
#+end_src

#+begin_src coq
Notation "'auction_bid_result_t'" := ((
  result state_hacspec_t bid_error_hacspec_t)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition auction_bid_hacspec
  (ctx_15 : context_t)
  (amount_16 : int64)
  (state_17 : state_hacspec_t)
  : auction_bid_result_t :=
  let 'StateHacspec ((
	auction_state_18,
	highest_bid_19,
	st2_20,
	expiry_21,
	st4_22
      )) :=
    (state_17) in 
  ifbnd negb ((auction_state_18) =.? (NotSoldYet)) : bool
  thenbnd (bind (@Err state_hacspec_t bid_error_hacspec_t (
	AuctionIsFinalized)) (fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  let '(slot_time_23, sender_24) :=
    ctx_15 in 
  ifbnd negb ((slot_time_23) <=.? (expiry_21)) : bool
  thenbnd (bind (@Err state_hacspec_t bid_error_hacspec_t (
	BidsOverWaitingForAuctionFinalization)) (fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  ifbnd (sender_24) =.? (UserAddressNone) : bool
  thenbnd (bind (@Err state_hacspec_t bid_error_hacspec_t (ContractSender)) (
      fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  let sender_address_25 : user_address_t :=
    match sender_24 with
    | UserAddressNone => array_from_list int8 (let l :=
	[
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5;
	  @repr WORDSIZE8 5
	] in  l)
    | UserAddressSome account_address_26 => account_address_26
    end in 
  let '(bid_to_update_27, new_map_28) :=
    seq_map_entry ((st4_22)) (sender_address_25) in 
  let '(updated_bid_29, updated_map_30) :=
    match seq_map_update_entry ((st4_22)) (sender_address_25) ((
	bid_to_update_27) .+ (amount_16)) with
    | Update (updated_bid_31, updated_map_32) => (updated_bid_31, updated_map_32
    )
    end in 
  ifbnd negb ((updated_bid_29) >.? (highest_bid_19)) : bool
  thenbnd (bind (@Err state_hacspec_t bid_error_hacspec_t (BidTooLow)) (
      fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  @Ok state_hacspec_t bid_error_hacspec_t (StateHacspec ((
	auction_state_18,
	updated_bid_29,
	st2_20,
	expiry_21,
	updated_map_30
      ))))))).
#+end_src

#+begin_src coq
Inductive finalize_error_hacspec_t :=
| BidMapError : finalize_error_hacspec_t
| AuctionStillActive : finalize_error_hacspec_t
| AuctionFinalized : finalize_error_hacspec_t.

Definition eqb_finalize_error_hacspec_t (x y : finalize_error_hacspec_t) : bool :=
match x with
   | BidMapError => match y with | BidMapError=> true | _ => false end
   | AuctionStillActive =>
       match y with
       | AuctionStillActive=> true
       | _ => false
       end
   | AuctionFinalized => match y with | AuctionFinalized=> true | _ => false end
   end.

Definition eqb_leibniz_finalize_error_hacspec_t (x y : finalize_error_hacspec_t) : eqb_finalize_error_hacspec_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_finalize_error_hacspec_t : EqDec (finalize_error_hacspec_t) :=
Build_EqDec (finalize_error_hacspec_t) (eqb_finalize_error_hacspec_t) (eqb_leibniz_finalize_error_hacspec_t).

Global Instance show_finalize_error_hacspec_t : Show (finalize_error_hacspec_t) :=
 @Build_Show (finalize_error_hacspec_t) (fun x =>
 match x with
 BidMapError => ("BidMapError")%string
 | AuctionStillActive => ("AuctionStillActive")%string
 | AuctionFinalized => ("AuctionFinalized")%string
 end).
Definition g_finalize_error_hacspec_t : G (finalize_error_hacspec_t) := oneOf_ (returnGen BidMapError) [returnGen BidMapError;returnGen AuctionStillActive;returnGen AuctionFinalized].
Global Instance gen_finalize_error_hacspec_t : Gen (finalize_error_hacspec_t) := Build_Gen finalize_error_hacspec_t g_finalize_error_hacspec_t.
#+end_src

#+begin_src coq
Notation "'finalize_context_t'" := ((int64 × user_address_t × int64
)) : hacspec_scope.
Instance show_finalize_context_t : Show (finalize_context_t) :=
Build_Show finalize_context_t (fun x =>
  let (x, x0) := x in
  let (x, x1) := x in
  (
    ("(") ++ ((show x) ++ ((",") ++ ((show x0) ++ ((",") ++ ((show x1) ++ (")"))))))))%string.
Definition g_finalize_context_t : G (finalize_context_t) :=
bindGen arbitrary (fun x0 : int64 =>
  bindGen arbitrary (fun x1 : user_address_t =>
  bindGen arbitrary (fun x2 : int64 =>
  returnGen (x0,x1,x2)))).
Instance gen_finalize_context_t : Gen (finalize_context_t) := Build_Gen finalize_context_t g_finalize_context_t.
#+end_src

#+begin_src coq
Inductive finalize_action_t :=
| Accept : finalize_action_t
| SimpleTransfer : public_byte_seq -> finalize_action_t.

Definition eqb_finalize_action_t (x y : finalize_action_t) : bool :=
match x with
   | Accept => match y with | Accept=> true | _ => false end
   | SimpleTransfer a =>
       match y with
       | SimpleTransfer b => a =.? b
       | _ => false
       end
   end.

Definition eqb_leibniz_finalize_action_t (x y : finalize_action_t) : eqb_finalize_action_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_finalize_action_t : EqDec (finalize_action_t) :=
Build_EqDec (finalize_action_t) (eqb_finalize_action_t) (eqb_leibniz_finalize_action_t).

Global Instance show_finalize_action_t : Show (finalize_action_t) :=
 @Build_Show (finalize_action_t) (fun x =>
 match x with
 Accept => ("Accept")%string
 | SimpleTransfer a => ("SimpleTransfer" ++ show a)%string
 end).
Definition g_finalize_action_t : G (finalize_action_t) := oneOf_ (returnGen Accept) [returnGen Accept;bindGen arbitrary (fun a => returnGen (SimpleTransfer a))].
Global Instance gen_finalize_action_t : Gen (finalize_action_t) := Build_Gen finalize_action_t g_finalize_action_t.
#+end_src

#+begin_src coq
Inductive bid_remain_t :=
| BidNone : bid_remain_t
| BidSome : int64 -> bid_remain_t.

Definition eqb_bid_remain_t (x y : bid_remain_t) : bool :=
match x with
   | BidNone => match y with | BidNone=> true | _ => false end
   | BidSome a => match y with | BidSome b => a =.? b | _ => false end
   end.

Definition eqb_leibniz_bid_remain_t (x y : bid_remain_t) : eqb_bid_remain_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_bid_remain_t : EqDec (bid_remain_t) :=
Build_EqDec (bid_remain_t) (eqb_bid_remain_t) (eqb_leibniz_bid_remain_t).

Global Instance show_bid_remain_t : Show (bid_remain_t) :=
 @Build_Show (bid_remain_t) (fun x =>
 match x with
 BidNone => ("BidNone")%string
 | BidSome a => ("BidSome" ++ show a)%string
 end).
Definition g_bid_remain_t : G (bid_remain_t) := oneOf_ (returnGen BidNone) [returnGen BidNone;bindGen arbitrary (fun a => returnGen (BidSome a))].
Global Instance gen_bid_remain_t : Gen (bid_remain_t) := Build_Gen bid_remain_t g_bid_remain_t.
#+end_src

#+begin_src coq
Notation "'auction_finalize_result_t'" := ((result (
    state_hacspec_t ×
    finalize_action_t
  ) finalize_error_hacspec_t)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition auction_finalize_hacspec
  (ctx_33 : finalize_context_t)
  (state_34 : state_hacspec_t)
  : auction_finalize_result_t :=
  let 'StateHacspec ((
	auction_state_35,
	highest_bid_36,
	st2_37,
	expiry_38,
	SeqMap ((m0_39, m1_40))
      )) :=
    (state_34) in 
  let result_41 : (result (state_hacspec_t × finalize_action_t
      ) finalize_error_hacspec_t) :=
    @Ok (state_hacspec_t × finalize_action_t) finalize_error_hacspec_t ((
	(state_34),
	Accept
      )) in 
  ifbnd negb ((auction_state_35) =.? (NotSoldYet)) : bool
  thenbnd (bind (@Err (state_hacspec_t × finalize_action_t
      ) finalize_error_hacspec_t (AuctionFinalized)) (fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  let '(slot_time_42, owner_43, balance_44) :=
    ctx_33 in 
  ifbnd negb ((slot_time_42) >.? (expiry_38)) : bool
  thenbnd (bind (@Err (state_hacspec_t × finalize_action_t
      ) finalize_error_hacspec_t (AuctionStillActive)) (fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  ifbnd (balance_44) !=.? (@repr WORDSIZE64 0) : bool
  thenbnd (let return_action_45 : finalize_action_t :=
      SimpleTransfer (seq_concat (seq_concat (seq_new_ (default) (usize 0)) (
	    owner_43)) (u64_to_be_bytes (highest_bid_36))) in 
    let remaining_bid_46 : bid_remain_t :=
      BidNone in 
    bind (foldibnd (usize 0) to ((seq_len ((m0_39))) / (usize 32)) for (
	auction_state_35,
	return_action_45,
	remaining_bid_46
      ) >> (fun x_47 '(auction_state_35, return_action_45, remaining_bid_46) =>
      let addr_48 : user_address_t :=
	array_from_seq (32) (seq_slice ((m0_39)) ((x_47) * (usize 32)) (
	    usize 32)) in 
      let amnt_49 : int64 :=
	u64_from_be_bytes (array_from_seq (8) (seq_slice ((m1_40)) ((x_47) * (
		usize 8)) (usize 8))) in 
      ifbnd (amnt_49) <.? (highest_bid_36) : bool
      then (let return_action_45 :=
	  match return_action_45 with
	  | Accept => Accept
	  | SimpleTransfer m_50 => SimpleTransfer (seq_concat (seq_concat (
		m_50) (addr_48)) (u64_to_be_bytes (amnt_49)))
	  end in 
	(auction_state_35, return_action_45, remaining_bid_46))
      elsebnd(ifbnd negb ((remaining_bid_46) =.? (BidNone)) : bool
	thenbnd (bind (@Err (state_hacspec_t × finalize_action_t
	    ) finalize_error_hacspec_t (BidMapError)) (fun _ =>  Ok (tt)))
	else (tt) >> (fun 'tt =>
	let auction_state_35 :=
	  Sold (addr_48) in 
	let remaining_bid_46 :=
	  BidSome (amnt_49) in 
	Ok ((auction_state_35, return_action_45, remaining_bid_46)))) >> (fun '(
	auction_state_35,
	return_action_45,
	remaining_bid_46
      ) =>
      Ok ((auction_state_35, return_action_45, remaining_bid_46))))) (fun '(
	auction_state_35,
	return_action_45,
	remaining_bid_46
      ) => let result_41 :=
	match remaining_bid_46 with
	| BidSome amount_51 => (if (negb ((amount_51) =.? (
		highest_bid_36))):bool then (@Err (
	      state_hacspec_t ×
	      finalize_action_t
	    ) finalize_error_hacspec_t (BidMapError)) else (@Ok (
	      state_hacspec_t ×
	      finalize_action_t
	    ) finalize_error_hacspec_t ((
		StateHacspec ((
		    auction_state_35,
		    highest_bid_36,
		    st2_37,
		    expiry_38,
		    SeqMap (((m0_39), (m1_40)))
		  )),
		return_action_45
	      ))))
	| BidNone => @Err (state_hacspec_t × finalize_action_t
	) finalize_error_hacspec_t (BidMapError)
	end in 
      bind ((result_41)) (fun _ =>  Ok ((auction_state_35, result_41)))))
  else ((auction_state_35, result_41)) >> (fun '(auction_state_35, result_41) =>
  result_41))).
#+end_src

#+begin_src coq
Definition auction_test_init
  (item_52 : public_byte_seq)
  (time_53 : int64)
  : bool :=
  (fresh_state_hacspec ((item_52)) (time_53)) =.? (StateHacspec ((
	NotSoldYet,
	@repr WORDSIZE64 0,
	(item_52),
	time_53,
	SeqMap ((seq_new_ (default) (usize 0), seq_new_ (default) (usize 0)))
      ))).

Theorem ensures_auction_test_init : forall result_54 (
  item_52 : public_byte_seq) (time_53 : int64),
 @auction_test_init item_52 time_53 = result_54 ->
 result_54 = true.
 Proof. Admitted.
QuickChick (
  forAll g_public_byte_seq (fun item_52 : public_byte_seq => forAll g_int64 (fun time_53 : int64 => auction_test_init item_52 time_53))).
#+end_src

#+begin_src coq
Definition verify_bid
  (item_55 : public_byte_seq)
  (state_56 : state_hacspec_t)
  (account_57 : user_address_t)
  (ctx_58 : context_t)
  (amount_59 : int64)
  (bid_map_60 : seq_map_t)
  (highest_bid_61 : int64)
  (time_62 : int64)
  : (state_hacspec_t × seq_map_t × bool × bool) :=
  let t_63 : (result state_hacspec_t bid_error_hacspec_t) :=
    auction_bid_hacspec (ctx_58) (amount_59) ((state_56)) in 
  let '(state_64, res_65) :=
    match t_63 with
    | Err e_66 => (state_56, false)
    | Ok s_67 => (s_67, true)
    end in 
  let bid_map_68 : seq_map_t :=
    match seq_map_update_entry ((bid_map_60)) (account_57) (highest_bid_61) with
    | Update (_, updated_map_69) => updated_map_69
    end in 
  (
    (state_64),
    (bid_map_68),
    res_65,
    ((state_64)) =.? (StateHacspec ((
	  NotSoldYet,
	  highest_bid_61,
	  (item_55),
	  time_62,
	  (bid_map_68)
	)))
  ).
#+end_src

#+begin_src coq
Definition useraddress_from_u8 (i_70 : int8) : user_address_t :=
  array_from_list int8 (let l :=
      [
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70;
	i_70
      ] in  l).
#+end_src

#+begin_src coq
Definition new_account
  (time_71 : int64)
  (i_72 : int8)
  : (user_address_t × context_t) :=
  let addr_73 : user_address_t :=
    useraddress_from_u8 (i_72) in 
  let ctx_74 : (int64 × user_address_set_t) :=
    (time_71, UserAddressSome (addr_73)) in 
  (addr_73, ctx_74).
#+end_src

#+begin_src coq
Definition test_auction_bid_and_finalize
  (item_75 : public_byte_seq)
  (time_76 : int64)
  (input_amount_77 : int64)
  `{(@repr WORDSIZE64 18446744073709551615) >.? (time_76)}
  `{(((@repr WORDSIZE64 18446744073709551615) ./ (@repr WORDSIZE64 5)) .- (
      @repr WORDSIZE64 1)) >.? (input_amount_77)}
  : bool :=
  let time_78 : int64 :=
    (if ((time_76) =.? (@repr WORDSIZE64 18446744073709551615)):bool then (
	@repr WORDSIZE64 18446744073709551614) else (time_76)) in 
  let input_amount_79 : int64 :=
    (if ((input_amount_77) >.? (((@repr WORDSIZE64 18446744073709551615) ./ (
	      @repr WORDSIZE64 5)) .- (@repr WORDSIZE64 1))):bool then (
	@repr WORDSIZE64 100) else (input_amount_77)) in 
  let amount_80 : int64 :=
    (input_amount_79) .+ (@repr WORDSIZE64 1) in 
  let winning_amount_81 : int64 :=
    (amount_80) .* (@repr WORDSIZE64 3) in 
  let big_amount_82 : int64 :=
    (amount_80) .* (@repr WORDSIZE64 5) in 
  let bid_map_83 : seq_map_t :=
    SeqMap ((seq_new_ (default) (usize 0), seq_new_ (default) (usize 0))) in 
  let state_84 : state_hacspec_t :=
    fresh_state_hacspec ((item_75)) (time_78) in 
  let '(alice_85, alice_ctx_86) :=
    new_account (time_78) (@repr WORDSIZE8 0) in 
  let '(ac0_87, ac1_88) :=
    alice_ctx_86 in 
  let '(state_89, bid_map_90, res_0_91, result_0_92) :=
    verify_bid ((item_75)) (state_84) (alice_85) (((ac0_87), (ac1_88))) (
      amount_80) (bid_map_83) (amount_80) (time_78) in 
  let '(state_93, bid_map_94, res_1_95, result_1_96) :=
    verify_bid ((item_75)) (state_89) (alice_85) (((ac0_87), (ac1_88))) (
      amount_80) (bid_map_90) ((amount_80) .+ (amount_80)) (time_78) in 
  let '(bob_97, bob_ctx_98) :=
    new_account (time_78) (@repr WORDSIZE8 1) in 
  let '(bc1_99, bc2_100) :=
    bob_ctx_98 in 
  let '(state_101, bid_map_102, res_2_103, result_2_104) :=
    verify_bid ((item_75)) (state_93) (bob_97) (((bc1_99), (bc2_100))) (
      winning_amount_81) (bid_map_94) (winning_amount_81) (time_78) in 
  let owner_105 : user_address_t :=
    useraddress_from_u8 (@repr WORDSIZE8 0) in 
  let balance_106 : int64 :=
    @repr WORDSIZE64 100 in 
  let ctx4_107 : (int64 × user_address_t × int64) :=
    (time_78, owner_105, balance_106) in 
  let finres_108 : (result (state_hacspec_t × finalize_action_t
      ) finalize_error_hacspec_t) :=
    auction_finalize_hacspec (ctx4_107) ((state_101)) in 
  let '(state_109, result_3_110) :=
    match finres_108 with
    | Err err_111 => ((state_101), (err_111) =.? (AuctionStillActive))
    | Ok (state_112, _) => (state_112, false)
    end in 
  let '(carol_113, carol_ctx_114) :=
    new_account (time_78) (@repr WORDSIZE8 2) in 
  let ctx5_115 : (int64 × user_address_t × int64) :=
    ((time_78) .+ (@repr WORDSIZE64 1), carol_113, winning_amount_81) in 
  let finres2_116 : (result (state_hacspec_t × finalize_action_t
      ) finalize_error_hacspec_t) :=
    auction_finalize_hacspec (ctx5_115) ((state_109)) in 
  let '(state_117, result_4_118) :=
    match finres2_116 with
    | Err _ => ((state_109), false)
    | Ok (state_119, action_120) => (
      state_119,
      (action_120) =.? (SimpleTransfer (seq_concat (seq_concat (seq_concat (
		seq_concat (seq_new_ (default) (usize 0)) (carol_113)) (
		u64_to_be_bytes (winning_amount_81))) (alice_85)) (
	    u64_to_be_bytes ((amount_80) .+ (amount_80)))))
    )
    end in 
  let result_5_121 : bool :=
    ((state_117)) =.? (StateHacspec ((
	  Sold (bob_97),
	  winning_amount_81,
	  (item_75),
	  time_78,
	  (bid_map_102)
	))) in 
  let finres3_122 : (result (state_hacspec_t × finalize_action_t
      ) finalize_error_hacspec_t) :=
    auction_finalize_hacspec (ctx5_115) ((state_117)) in 
  let '(state_123, result_6_124) :=
    match finres3_122 with
    | Err err_125 => (state_117, (err_125) =.? (AuctionFinalized))
    | Ok (state_126, action_127) => (state_126, false)
    end in 
  let t_128 : (result state_hacspec_t bid_error_hacspec_t) :=
    auction_bid_hacspec (((bc1_99), (bc2_100))) (big_amount_82) ((
	state_123)) in 
  let result_7_129 : bool :=
    match t_128 with
    | Err e_130 => (e_130) =.? (AuctionIsFinalized)
    | Ok _ => false
    end in 
  (((((((result_0_92) && (result_1_96)) && (result_2_104)) && (
	    result_3_110)) && (result_4_118)) && (result_5_121)) && (
      result_6_124)) && (result_7_129).

Theorem ensures_test_auction_bid_and_finalize : forall result_54 (
  item_75 : public_byte_seq) (time_76 : int64) (input_amount_77 : int64),
 forall {H_0 : (@repr WORDSIZE64 18446744073709551615) >.? (time_76)},
 forall {H_1 : (((@repr WORDSIZE64 18446744073709551615) ./ (
       @repr WORDSIZE64 5)) .- (@repr WORDSIZE64 1)) >.? (input_amount_77)},
 @test_auction_bid_and_finalize item_75 time_76 input_amount_77 H_0 H_1 = result_54 ->
 result_54 = true.
 Proof. Admitted.
QuickChick (
  forAll g_public_byte_seq (fun item_75 : public_byte_seq => forAll g_int64 (fun time_76 : int64 => forAll g_int64 (fun input_amount_77 : int64 => test_auction_bid_and_finalize item_75 time_76 input_amount_77)))).
#+end_src

