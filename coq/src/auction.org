
#+TITLE: Auction Smartcontract
#+AUTHOR: Lasse Letager Hansen

# Use org-tanglesync !
# lentic

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file
# C-c C-v s   -  create results / run subtree

* General information
:PROPERTIES:
:header-args: sh :eval never :results output silent
:END:
** Resulting output
#+begin_src sh
cargo clean
#+end_src

#+begin_src sh
cargo install --path language
#+end_src

#+begin_src sh
cargo build
#+end_src

#+begin_src sh
cargo hacspec -e v --dir coq/src -o Auction --org-file auction.org hacspec-auction
#+end_src

* Auction smart contract specification
** Config
#+begin_src toml :tangle ../../examples/auction/Cargo.toml :mkdirp yes :eval never
[package]
name = "hacspec-auction"
version = "0.1.0"
authors = [""]
edition = "2018"

[lib]
path = "src/auction.rs"

[dependencies]
hacspec-lib = { path = "../../lib" }
# pearlite-syn = { path = "../../../../creusot/pearlite-syn" }
creusot-contracts = { git = "https://github.com/xldenis/creusot", rev = "7763b3ae77205fba83182b9a6c3e69ad0b12fec7" }
# hacspec = {optional = true}
concordium-contracts-common = { path = "../../../../concordium-rust-smart-contracts/concordium-contracts-common" }
hacspec-concordium = { path = "../concordium" }
hacspec-concordium-derive = { path = "../concordium-derive" }

[features]
hacspec = []
# use_attributes = ["hacspec-attributes", "hacspec-attributes/print_attributes"]

[dev-dependencies]
hacspec-dev = { path = "../../utils/dev" }
criterion = "0.3"
rand = "0.8"
quickcheck = "1"
quickcheck_macros = "1"
#+end_src

** Rust code
:PROPERTIES:
:header-args: :tangle ../../examples/auction/src/auction.rs :mkdirp yes
:END:

*** Imports
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
extern crate hacspec_lib;

use hacspec_lib::*;

// #[cfg(not(feature = "hacspec"))]
// extern crate creusot_contracts;
#[cfg(test)]
#[cfg(not(feature = "hacspec"))]
use creusot_contracts::{ensures, requires};

#+end_src

#+begin_src rust :eval never
// // Rust-hacspec Interface
#[cfg(not(feature = "hacspec"))]
use hacspec_concordium::{collections::BTreeMap, *};

#[cfg(feature = "hacspec")]
use concert_lib::*;

#+end_src

*** Types
#+begin_src rust :eval never
  array!(UserAddress, 32, u8); // U8

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_account_address(ua: UserAddress) -> AccountAddress {
      AccountAddress([
	  ua[0], ua[1], ua[2], ua[3], ua[4], ua[5], ua[6], ua[7], ua[8], ua[9], ua[10], ua[11],
	  ua[12], ua[13], ua[14], ua[15], ua[16], ua[17], ua[18], ua[19], ua[20], ua[21], ua[22],
	  ua[23], ua[24], ua[25], ua[26], ua[27], ua[28], ua[29], ua[30], ua[31],
      ])
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_account_address(aa: &AccountAddress) -> UserAddress {
      UserAddress::from_native_slice(&aa.0)
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// The state in which an auction can be.
  #[derive(Debug, Eq, PartialEq, PartialOrd, Serialize, SchemaType)] // TODO: Debug with creusot 
  pub enum AuctionState {
      /// The auction is either
      /// - still accepting bids or
      /// - not accepting bids because it's past the auction end, but nobody has
      ///   finalized the auction yet.
      NotSoldYet,
      /// The auction is over and the item has been sold to the indicated address.
      Sold(AccountAddress), // winning account's address
  }

  /// The state in which an auction can be.
  #[derive(Clone, PartialEq)]
  pub enum AuctionStateHacspec {
      /// The auction is either
      /// - still accepting bids or
      /// - not accepting bids because it's past the auction end, but nobody has
      ///   finalized the auction yet.
      NotSoldYet,
      /// The auction is over and the item has been sold to the indicated address.
      Sold(UserAddress), // winning account's address
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_auction_state(s : AuctionStateHacspec) -> AuctionState {
      match s {
	  AuctionStateHacspec::NotSoldYet => AuctionState::NotSoldYet,
	  AuctionStateHacspec::Sold(ua) => AuctionState::Sold(coerce_hacspec_to_rust_account_address(ua))
      }
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_auction_state(s : &AuctionState) -> AuctionStateHacspec {
      match s {
	  AuctionState::NotSoldYet => AuctionStateHacspec::NotSoldYet,
	  AuctionState::Sold(aa) => AuctionStateHacspec::Sold(coerce_rust_to_hacspec_account_address(aa))
      }
  }

#+end_src

#+begin_src rust :eval never
  #[derive(Clone, PartialEq)]
  pub struct SeqMap(pub PublicByteSeq, pub PublicByteSeq);

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_b_tree_map(m: SeqMap) -> BTreeMap<AccountAddress, Amount> {
      let m1prime =
	  (0..m.0.len() / 32).map(|x| UserAddress::from_seq(&m.0.clone().slice(x * 32, 32)));
      let m2prime =
	  (0..m.1.len() / 8).map(|x| u64_from_be_bytes(u64Word::from_seq(&m.1.slice(x * 8, 8))));

      (m1prime.zip(m2prime)).fold(BTreeMap::new(), |mut t, (x, y)| {
	  t.insert(
	      coerce_hacspec_to_rust_account_address(x),
	      Amount { micro_ccd: y },
	  );
	  t
      })
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_b_tree_map(m: &BTreeMap<AccountAddress, Amount>) -> SeqMap {
      SeqMap(
	  m.keys()
	      .map(|x| coerce_rust_to_hacspec_account_address(x))
	      .fold(PublicByteSeq::new(0_usize), |v, x| v.concat(&x)),
	  m.values()
	      .map(|x| x.micro_ccd)
	      .fold(PublicSeq::new(0_usize), |v, x| {
		  v.concat(&u64_to_be_bytes(x))
	      }),
      )
  }
#+end_src

#+begin_src rust :eval never

  #[cfg(not(feature = "hacspec"))]
  /// The state of the smart contract.
  /// This is the state that will be shown when the contract is queried using
  /// `concordium-client contract show`.
  #[contract_state(contract = "auction")]
  #[derive(Debug, Eq, PartialEq, Serialize, SchemaType)] // TODO: Debug, 
  pub struct State {
      /// Has the item been sold?
      auction_state: AuctionState,
      /// The highest bid so far (stored explicitly so that bidders can quickly
      /// see it)
      highest_bid:   Amount,
      /// The sold item (to be displayed to the auction participants), encoded in
      /// ASCII
      item:          Vec<u8>,
      /// Expiration time of the auction at which bids will be closed (to be
      /// displayed to the auction participants)
      expiry:        Timestamp,
      /// Keeping track of which account bid how much money
      // #[concordium(size_length = 2)] // TODO
      bids:          BTreeMap<AccountAddress, Amount>,
  }

  #[derive(Clone, PartialEq)]
  pub struct StateHacspec(
      pub AuctionStateHacspec,
      pub u64, // amount
      pub PublicByteSeq,
      pub u64, // timestamp
      pub SeqMap,
  );

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_state(s : StateHacspec) -> State {
      let StateHacspec(auction_state_hacspec, amount, item_seq, time, bid_map) = s;
      let auction_state = coerce_hacspec_to_rust_auction_state(auction_state_hacspec);
      let highest_bid = Amount { micro_ccd: amount };
      let item = item_seq.native_slice().to_vec();
      let expiry = Timestamp::from_timestamp_millis(time);
      let bids = coerce_hacspec_to_rust_b_tree_map(bid_map);

      State {
	  auction_state,
	  highest_bid,
	  item,
	  expiry,
	  bids,
      }
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_state(s : &State) -> StateHacspec {
      let auction_state = coerce_rust_to_hacspec_auction_state(&s.auction_state);
      let highest_bid = s.highest_bid.micro_ccd;
      let item = PublicByteSeq::from_native_slice(&s.item);
      let expiry = s.expiry.timestamp_millis();
      let bids = coerce_rust_to_hacspec_b_tree_map(&s.bids);

      StateHacspec (
	  auction_state,
	  highest_bid,
	  item,
	  expiry,
	  bids,
      )
  }

#+end_src

*** Fresh state function
#+begin_src rust :eval never
pub fn fresh_state_hacspec(itm: PublicByteSeq, exp: u64) -> StateHacspec {
    StateHacspec(
	AuctionStateHacspec::NotSoldYet,
	0_u64,
	itm,
	exp,
	SeqMap(PublicByteSeq::new(0_usize), PublicByteSeq::new(0_usize)),
    )
}

#[cfg(not(feature = "hacspec"))]
/// A helper function to create a state for a new auction.
fn fresh_state(itm: Vec<u8>, exp: Timestamp) -> State {
    coerce_hacspec_to_rust_state(fresh_state_hacspec(
	PublicByteSeq::from_vec(itm),
	exp.timestamp_millis(),
    ))
}

#+end_src

#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// Type of the parameter to the `init` function.
#[derive(Serialize, SchemaType)]
struct InitParameter {
    /// The item to be sold, as a sequence of ASCII codes.
    item: Vec<u8>,
    /// Time of the auction end in the RFC 3339 format (https://tools.ietf.org/html/rfc3339)
    expiry: Timestamp,
}

#+end_src

#+begin_src rust :eval never
#[cfg(feature = "hacspec")]
struct InitParameter(
    /// The item to be sold, as a sequence of ASCII codes.
    PublicByteSeq,
    /// Time of the auction end in the RFC 3339 format (https://tools.ietf.org/html/rfc3339)
    u64,
);

#+end_src

#+begin_src rust :eval never
pub struct Context(UserAddress, UserAddress, u64, u64);
pub type ContextStateHacspec = (Context, StateHacspec);

#[cfg(feature = "hacspec")]
#[init(contract = "auction", parameter = "InitParameter")]
pub fn auction_init(ctx : Context, init_parameter: InitParameter) -> ContextStateHacspec {
    // Always succeeds
    (ctx, fresh_state_hacspec(PublicByteSeq::new(0), 0u64))
}

#+end_src

#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// Init function that creates a new auction
#[init(contract = "auction", parameter = "InitParameter")]
fn auction_init(ctx: &impl HasInitContext) -> InitResult<State> {
    let parameter: InitParameter = ctx.parameter_cursor().get()?;
    Ok(fresh_state(parameter.item, parameter.expiry))
}

#+end_src

*** Seq map entry
#+begin_src rust :eval never  
  fn seq_map_entry(m: SeqMap, sender_address: UserAddress) -> (u64, SeqMap) {
      let SeqMap(m0, m1) = m;

      let mut res = // MapEntry::Entry
	  (
	  0_u64,
	  SeqMap(
	      m0.clone().concat(&sender_address),
	      m1.clone().concat(&u64_to_be_bytes(0_u64)),
	  ),
      );
      
      // TODO: use chunks instead of doing the math yourself
      for x in 0..m0.clone().len() / 32 {
	  if UserAddress::from_seq(&m0.clone().slice(x * 32, 32)) == sender_address {
	      res = // MapEntry::Entry
		  (
		  u64_from_be_bytes(u64Word::from_seq(&m1.clone().slice(x * 8, 8))),
		  SeqMap(m0.clone(), m1.clone()),
	      );
	  }
      }

      res
  }
#+end_src
*** Map Update and result type
#+begin_src rust :eval never
  #[derive(Clone, PartialEq)]
  pub enum MapUpdate {
      Update(u64, SeqMap),
  }

  fn seq_map_update_entry(m: SeqMap, sender_address: UserAddress, amount: u64) -> MapUpdate {
      let SeqMap(m0, m1) = m;

      let mut res = MapUpdate::Update(
	  amount,
	  SeqMap(
	      m0.clone().concat(&sender_address),
	      m1.clone().concat(&u64_to_be_bytes(amount)),
	  ),
      );

      // TODO: use chunks instead of doing the math yourself
      // !! Issue in for loop !! (update, updates the reference!)
      for x in 0..m0.clone().len() / 32 {
	  if UserAddress::from_seq(&m0.clone().slice(x * 32, 32)) == sender_address {
	      res = MapUpdate::Update(
		  amount,
		  SeqMap(
		      m0.clone().update(x * 32, &sender_address),
		      m1.clone().update(x * 8, &u64_to_be_bytes(amount)),
		  ),
	      );
	  }
      }

      res
  }
#+end_src
*** Auction bid and intermediate types
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// For errors in which the `bid` function can result
#[derive(Debug, PartialEq, Eq, Clone, Reject)]
enum BidError {
    ContractSender, // raised if a contract, as opposed to account, tries to bid
    BidTooLow,      /* { bid: Amount, highest_bid: Amount } */
    // raised if bid is lower than highest amount
    BidsOverWaitingForAuctionFinalization, // raised if bid is placed after auction expiry time
    AuctionFinalized,                      /* raised if bid is placed after auction has been
					    ,* finalized */
}

#[derive(Clone, PartialEq)]
pub enum BidErrorHacspec {
    ContractSender, // raised if a contract, as opposed to account, tries to bid
    BidTooLow,      /* { bid: Amount, highest_bid: Amount } */
    // raised if bid is lower than highest amount
    BidsOverWaitingForAuctionFinalization, // raised if bid is placed after auction expiry time
    AuctionIsFinalized,                    /* raised if bid is placed after auction has been
					    ,* finalized */
}

// TODO: Never used?
// #[cfg(not(feature = "hacspec"))]
// fn coerce_rust_to_hacspec_bid_error(b: BidError) -> BidErrorHacspec {
//     match b {
// 	BidError::ContractSender => BidErrorHacspec::ContractSender,
// 	BidError::BidTooLow => BidErrorHacspec::BidTooLow,
// 	BidError::BidsOverWaitingForAuctionFinalization => {
// 	    BidErrorHacspec::BidsOverWaitingForAuctionFinalization
// 	}
// 	BidError::AuctionFinalized => BidErrorHacspec::AuctionIsFinalized,
//     }
// }

#[cfg(not(feature = "hacspec"))]
fn coerce_hacspec_to_rust_bid_error(b: BidErrorHacspec) -> BidError {
    match b {
	BidErrorHacspec::ContractSender => BidError::ContractSender,
	BidErrorHacspec::BidTooLow => BidError::BidTooLow,
	BidErrorHacspec::BidsOverWaitingForAuctionFinalization => {
	    BidError::BidsOverWaitingForAuctionFinalization
	}
	BidErrorHacspec::AuctionIsFinalized => BidError::AuctionFinalized,
    }
}
#+end_src

#+begin_src rust
// #[derive(Clone, PartialEq)]
pub type AuctionBidResult = Result<StateHacspec, BidErrorHacspec>;

pub fn auction_bid_hacspec(ctx: Context, amount: u64, state: StateHacspec) -> AuctionBidResult {
    let StateHacspec(auction_state, highest_bid, st2, expiry, st4) = state.clone();

    if !(auction_state == AuctionStateHacspec::NotSoldYet) {
	AuctionBidResult::Err(BidErrorHacspec::AuctionIsFinalized)?;
    }

    let Context(owner, sender, balance, slot_time) = ctx;
    if !(slot_time <= expiry) {
	AuctionBidResult::Err(BidErrorHacspec::BidsOverWaitingForAuctionFinalization)?;
    }

    // if sender == UserAddressSet::UserAddressNone {
    //     AuctionBidResult::Err(BidErrorHacspec::ContractSender)?;
    // }

    // let sender_address = match sender {
    //     UserAddressSet::UserAddressNone => UserAddress([
    //         5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8,
    //         5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8, 5_u8,
    //         5_u8, 5_u8, 5_u8, 5_u8,
    //     ]), // should never happen
    //     UserAddressSet::UserAddressSome(account_address) => account_address,
    // };

    let (bid_to_update, _new_map) = // match
	  seq_map_entry(st4.clone(), sender) // {
      //     MapEntry::Entry(bid_to_update, new_map) => (bid_to_update, new_map),
      // }
      ;

    let (updated_bid, updated_map) =
	match seq_map_update_entry(st4.clone(), sender, bid_to_update + amount) {
	    MapUpdate::Update(updated_bid, updated_map) => (updated_bid, updated_map),
	};

    if !(updated_bid > highest_bid) {
	AuctionBidResult::Err(BidErrorHacspec::BidTooLow)?;
    }

    AuctionBidResult::Ok(StateHacspec(
	auction_state,
	updated_bid,
	st2,
	expiry,
	updated_map,
    ))
}

#[cfg(not(feature = "hacspec"))]
pub fn coerce_rust_to_hacspec_context(ctx: &impl HasReceiveContext) -> Context {
    Context(
        coerce_rust_to_hacspec_account_address(&ctx.owner()),
	match ctx.sender() {
	    Address::Contract(_) => panic!(),
	    Address::Account(account_address) => coerce_rust_to_hacspec_account_address(&account_address),
	},
        ctx.self_balance().micro_ccd,
        ctx.metadata().slot_time().timestamp_millis(),
    )
}

#[cfg(feature = "hacspec")]
/// Receive function in which accounts can bid before the auction end time
#[receive(contract = "auction", name = "bid", payable)]
fn auction_bid(
    ctx: ContextStateHacspec,
    amount: u64,
) -> Option<(ContextStateHacspec, ListAction)> {
    let s = Seq::<HasAction>::new(0);
    Option::<(ContextStateHacspec, ListAction)>::Some((ctx, s))
}

#[cfg(not(feature = "hacspec"))]
/// Receive function in which accounts can bid before the auction end time
#[receive(contract = "auction", name = "bid", payable)]
fn auction_bid<A: HasActions>(
    ctx: &impl HasReceiveContext,
    amount: Amount,
    state: &mut State,
) -> Result<A, BidError> {
    let hacspec_state = coerce_rust_to_hacspec_state(state);

    let new_state = match auction_bid_hacspec(
	coerce_rust_to_hacspec_context(ctx),
	amount.micro_ccd,
	hacspec_state,
    ) {
	Ok (a) => a,
	Err (e) => return Err (coerce_hacspec_to_rust_bid_error(e)),
    };

    ,*state = coerce_hacspec_to_rust_state(new_state);

    Ok (A::accept())
}
#+end_src

*** Finalize function and types
#+begin_src rust :eval never
#[cfg(not(feature = "hacspec"))]
/// For errors in which the `finalize` function can result
#[derive(Debug, PartialEq, Eq, Clone, Reject)]
enum FinalizeError {
    BidMapError,        /* raised if there is a mistake in the bid map that keeps track of all
			 ,* accounts' bids */
    AuctionStillActive, // raised if there is an attempt to finalize the auction before its expiry
    AuctionFinalized,   // raised if there is an attempt to finalize an already finalized auction
}

/// For errors in which the `finalize` function can result
#[derive(Clone, PartialEq)]
pub enum FinalizeErrorHacspec {
    BidMapError,
    AuctionStillActive,
    AuctionFinalized,
}

// TODO: never used
// #[cfg(not(feature = "hacspec"))]
// fn coerce_rust_to_hacspec_finalize_error(fe: FinalizeError) -> FinalizeErrorHacspec {
//     match fe {
// 	FinalizeError::BidMapError => FinalizeErrorHacspec::BidMapError,
// 	FinalizeError::AuctionStillActive => FinalizeErrorHacspec::AuctionStillActive,
// 	FinalizeError::AuctionFinalized => FinalizeErrorHacspec::AuctionFinalized,
//     }
// }

#[cfg(not(feature = "hacspec"))]
fn coerce_hacspec_to_rust_finalize_error(fe: FinalizeErrorHacspec) -> FinalizeError {
    match fe {
	FinalizeErrorHacspec::BidMapError => FinalizeError::BidMapError,
	FinalizeErrorHacspec::AuctionStillActive => FinalizeError::AuctionStillActive,
	FinalizeErrorHacspec::AuctionFinalized => FinalizeError::AuctionFinalized,
    }
}

#+end_src

#+begin_src rust :eval never
  pub type FinalizeContext = (u64, UserAddress, u64);

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_finalize_context(ctx: &impl HasReceiveContext) -> FinalizeContext {
    (
	ctx.metadata().slot_time().timestamp_millis(),
	coerce_rust_to_hacspec_account_address(&ctx.owner()),
	ctx.self_balance().micro_ccd,
    )
  }

    // let slot_time = ctx.metadata().slot_time();
    // ensure!(slot_time > state.expiry, FinalizeError::AuctionStillActive);

    // let owner = ctx.owner();

    // let balance = ctx.self_balance();

#+end_src

#+begin_src rust :eval never
#[derive(Clone, PartialEq)]
pub enum FinalizeAction {
    Accept,
    SimpleTransfer(PublicByteSeq),
}

#[derive(Clone, PartialEq)]
pub enum BidRemain {
    BidNone,
    BidSome(u64),
}

pub type AuctionFinalizeResult = Result<(StateHacspec, FinalizeAction), FinalizeErrorHacspec>;
// pub type BidRemain = Option<(UserAddress, u64)>;

pub fn auction_finalize_hacspec(
    ctx: FinalizeContext,
    state: StateHacspec,
) -> AuctionFinalizeResult {
    let StateHacspec(mut auction_state, highest_bid, st2, expiry, SeqMap(m0, m1)) = state.clone();

    let mut result = AuctionFinalizeResult::Ok((state.clone(), FinalizeAction::Accept));

    if !(auction_state == AuctionStateHacspec::NotSoldYet) {
        AuctionFinalizeResult::Err(FinalizeErrorHacspec::AuctionFinalized)?;
    }

    let (slot_time, owner, balance) = ctx;

    if !(slot_time > expiry) {
        AuctionFinalizeResult::Err(FinalizeErrorHacspec::AuctionStillActive)?;
    }

    if balance != 0_u64 {
        let mut return_action = FinalizeAction::SimpleTransfer(
            PublicByteSeq::new(0_usize)
                .concat(&owner)
                .concat(&u64_to_be_bytes(highest_bid)),
        );
        let mut remaining_bid = BidRemain::BidNone;
        // Return bids that are smaller than highest
        // let x = 0;
        for x in 0..m0.clone().len() / 32 {
            let addr = UserAddress::from_seq(&m0.clone().slice(x * 32, 32));
            let amnt = u64_from_be_bytes(u64Word::from_seq(&m1.clone().slice(x * 8, 8)));
            if amnt < highest_bid {
                return_action = match return_action {
                    FinalizeAction::Accept => FinalizeAction::Accept, // TODO: What error (should never happen)..
                    FinalizeAction::SimpleTransfer(m) => FinalizeAction::SimpleTransfer(
                        m.concat(&addr).concat(&u64_to_be_bytes(amnt)),
                    ),
                };
            } else {
                // ensure!(remaining_bid.is_none(), FinalizeErrorHacspec::BidMapError);
                if !(remaining_bid == BidRemain::BidNone) {
                    AuctionFinalizeResult::Err(FinalizeErrorHacspec::BidMapError)?;
                }
                auction_state = AuctionStateHacspec::Sold(addr);
                remaining_bid = BidRemain::BidSome(amnt);
            }
        }

        // ensure that the only bidder left in the map is the one with the highest bid
        result = match remaining_bid {
            BidRemain::BidSome(amount) =>
            // ensure!(amount == state.highest_bid, FinalizeErrorHacspec::BidMapError);
            {
                if !(amount == highest_bid) {
                    AuctionFinalizeResult::Err(FinalizeErrorHacspec::BidMapError)
                } else {
                    AuctionFinalizeResult::Ok((
                        StateHacspec(
                            auction_state,
                            highest_bid,
                            st2,
                            expiry,
                            SeqMap(m0.clone(), m1.clone()),
                        ),
                        return_action,
                    ))
                }
            }
            BidRemain::BidNone => AuctionFinalizeResult::Err(FinalizeErrorHacspec::BidMapError),
        };

        result.clone()?;
    }

    result
}

#[cfg(not(feature = "hacspec"))]
fn simple_transfer_from_index_and_seq<A: HasActions>(x: usize, s: PublicByteSeq) -> A {
    A::simple_transfer(
        &coerce_hacspec_to_rust_account_address(UserAddress::from_seq(
            &s.slice(x * (32 + 8), 32), // TODO: use chunks instead of doing the math yourself
        )),
        Amount {
            micro_ccd: u64_from_be_bytes(u64Word::from_seq(&s.slice(x * (32 + 8) + 32, 8))),
        },
    )
}

#[cfg(feature = "hacspec")]
/// Receive function in which accounts can bid before the auction end time
#[receive(contract = "auction", name = "finalize")]
fn auction_finalize(
    ctx: ContextStateHacspec,
) -> Option<(ContextStateHacspec, ListAction)> {
    let s = Seq::<HasAction>::new(0);
    Option::<(ContextStateHacspec, ListAction)>::Some((ctx, s))
}

#[cfg(not(feature = "hacspec"))]
/// Receive function used to finalize the auction, returning all bids to their
/// senders, except for the winning bid
#[receive(contract = "auction", name = "finalize")]
fn auction_finalize<A: HasActions>(
    ctx: &impl HasReceiveContext,
    state: &mut State,
) -> Result<A, FinalizeError> {
    let hacspec_state = coerce_rust_to_hacspec_state(state);

    let (new_state, fa) =
        match auction_finalize_hacspec(coerce_rust_to_hacspec_finalize_context(ctx), hacspec_state)
        {
            Ok(a) => a,
            Err(e) => return Err(coerce_hacspec_to_rust_finalize_error(e)),
        };

    ,*state = coerce_hacspec_to_rust_state(new_state);

    match fa {
        FinalizeAction::Accept => Ok(A::accept()),
        FinalizeAction::SimpleTransfer(s) => Ok((1..s.len() / (32 + 8))
            .fold(simple_transfer_from_index_and_seq(0, s.clone()), |t, x| {
                t.and_then(simple_transfer_from_index_and_seq(x, s.clone()))
            })),
    }
}
#+end_src
*** Rust Tests
#+begin_src rust :eval never
#[cfg(test)]
extern crate quickcheck;
#[cfg(test)]
#[macro_use(quickcheck)]
extern crate quickcheck_macros;

#[cfg(test)]
use quickcheck::*;

#[ensures(result == true)]
#[cfg(test)]
#[proof]
#[quickcheck]
/// Test that the smart-contract initialization sets the state correctly
/// (no bids, active state, indicated auction-end time and item name).
pub fn auction_test_init(item: PublicByteSeq, time : u64) -> bool {
    fresh_state_hacspec(item.clone(), time)
	== StateHacspec(
	    AuctionStateHacspec::NotSoldYet,
	    0_u64,
	    item.clone(),
	    time,
	    SeqMap(PublicByteSeq::new(0_usize), PublicByteSeq::new(0_usize)),
	)
}


#[cfg(test)]
#[proof]
fn verify_bid(
    item: PublicByteSeq,
    state: StateHacspec,
    account: UserAddress,
    ctx: Context,
    amount: u64,
    bid_map: SeqMap,
    highest_bid: u64,
    time : u64,
) -> (StateHacspec, SeqMap, bool, bool) {
    let t = auction_bid_hacspec(ctx, amount, state.clone());

    let (state, res) = match t {
	AuctionBidResult::Err(_e) => (state, false),
	AuctionBidResult::Ok(s) => (s, true),
    };

    let bid_map = match seq_map_update_entry(bid_map.clone(), account, highest_bid) {
	MapUpdate::Update(_, updated_map) => updated_map,
    };

    (
	state.clone(),
	bid_map.clone(),
	res,
	state.clone()
	    == StateHacspec(
		AuctionStateHacspec::NotSoldYet,
		highest_bid,
		item.clone(),
		time,
		bid_map.clone(),
	    ),
    )
}


#[cfg(test)]
#[proof]
fn useraddress_from_u8(i : u8) -> UserAddress {
    UserAddress([
	i, i, i, i, i, i, i, i, i, i, i, i, i, i, i,
	i, i, i, i, i, i, i, i, i, i, i, i, i, i, i,
	i, i,
    ])
}

#[cfg(test)]
#[proof]
fn new_account(time : u64, i : u8) -> (UserAddress, Context) {
    let addr = useraddress_from_u8(i);
    let ctx = Context(addr, addr, 0u64, time);
    (addr, ctx)
}

#[cfg(test)]
#[proof]
// #[quickcheck]
// #[test]
/// Test a sequence of bids and finalizations:
/// 0. Auction is initialized.
/// 1. Alice successfully bids 0.1 GTU.
/// 2. Alice successfully bids another 0.1 GTU, highest bid becomes 0.2 GTU
/// (the sum of her two bids). 3. Bob successfully bids 0.3 GTU, highest
/// bid becomes 0.3 GTU. 4. Someone tries to finalize the auction before
/// its end time. Attempt fails. 5. Dave successfully finalizes the
/// auction after its end time.    Alice gets her money back, while
/// Carol (the owner of the contract) collects the highest bid amount.
/// 6. Attempts to subsequently bid or finalize fail.
// TODO: Requires
// #[requires(18446744073709551615u64 > time)]
// #[requires(18446744073709551615u64 / 5u64 - 1u64 > input_amount)]
#[ensures(result == true)]
#[quickcheck]
fn test_auction_bid_and_finalize(item: PublicByteSeq, time : u64, input_amount : u64) -> bool {
    let time = if time == 18446744073709551615u64 { 18446744073709551614u64 } else { time }; // Can overflow !
    let input_amount : u64 = if input_amount > 18446744073709551615u64 / 5u64 - 1u64 { 100u64 } else { input_amount };

    let amount = input_amount + 1_u64;
    let winning_amount = amount * 3_u64; // 300_u64;
    let big_amount = amount * 5_u64; // 500_u64;

    let bid_map = SeqMap(PublicByteSeq::new(0_usize), PublicByteSeq::new(0_usize));

    // initializing auction
    let state = fresh_state_hacspec(item.clone(), time); // mut

    // 1st bid: account1 bids amount1
    let (alice, alice_ctx) = new_account(time, 0_u8);

    let Context(_, ac0, _, ac1) = alice_ctx;

    let (state, bid_map, _res_0, result_0) = verify_bid(
	item.clone(),
	state,
	alice,
	alice_ctx,
	amount,
	bid_map,
	amount,
	time,
    );

    // // 2nd bid: account1 bids `amount` again
    // // should work even though it's the same amount because account1 simply
    // // increases their bid
    let (state, bid_map, _res_1, result_1) = verify_bid(
	item.clone(),
	state,
	alice,
	alice_ctx,
	amount,
	bid_map,
	amount + amount,
	time,
    );

    // // 3rd bid: second account
    let (bob, bob_ctx) = new_account(time, 1_u8); // first argument is slot time
    let Context(_, bc1, _, bc2) = bob_ctx;

    let (state, bid_map, _res_2, result_2) = verify_bid(
	item.clone(),
	state,
	bob,
	bob_ctx,
	winning_amount,
	bid_map,
	winning_amount,
	time,
    );

    let owner = useraddress_from_u8(0_u8);

    // let sender = owner;
    let balance = 100_u64;
    let ctx4 = (time, owner, balance);

    let finres = auction_finalize_hacspec(ctx4, state.clone());
    let (state, result_3) = match finres {
	AuctionFinalizeResult::Err(err) => (
	    state.clone(),
	    err == FinalizeErrorHacspec::AuctionStillActive
	),
	AuctionFinalizeResult::Ok((state, _)) => (state, false),
    };

    // // finalizing auction
    // let carol = new_account();
    let (carol, _carol_ctx) = new_account(time, 2_u8);

    let ctx5 = (time + 1_u64, carol, winning_amount);
    let finres2 = auction_finalize_hacspec(ctx5, state.clone());

    let (state, result_4) = match finres2 {
	AuctionFinalizeResult::Err(_) => (state.clone(), false),
	AuctionFinalizeResult::Ok((state, action)) => (
	    state,
	    action
		== FinalizeAction::SimpleTransfer(
		    PublicByteSeq::new(0_usize)
			.concat(&carol)
			.concat(&u64_to_be_bytes(winning_amount))
			.concat(&alice)
			.concat(&u64_to_be_bytes(amount + amount)),
		),
	),
    };

    let result_5 = state.clone()
	== StateHacspec(
	    AuctionStateHacspec::Sold(bob),
	    winning_amount,
	    item.clone(),
	    time,
	    bid_map.clone(),
	);

    // attempting to finalize auction again should fail
    let finres3 = auction_finalize_hacspec(ctx5, state.clone());

    let (state, result_6) = match finres3 {
	AuctionFinalizeResult::Err(err) => (state, err == FinalizeErrorHacspec::AuctionFinalized),
	AuctionFinalizeResult::Ok((state, _action)) => (state, false),
    };

    let t = auction_bid_hacspec(bob_ctx, big_amount, state.clone());

    // let result_7 = t == AuctionBidResult::Err (BidErrorHacspec::AuctionIsFinalized);
    let result_7 = match t {
	AuctionBidResult::Err(e) => e == BidErrorHacspec::AuctionIsFinalized,
	AuctionBidResult::Ok(_) => false,
    };

    result_0 && result_1 && result_2 && result_3 && result_4 && result_5 && result_6 && result_7
}
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  #[cfg(test)]
  mod tests {
      use super::*;
      use std::sync::atomic::{AtomicU8, Ordering};
      use test_infrastructure::*;

      // A counter for generating new account addresses
      static ADDRESS_COUNTER: AtomicU8 = AtomicU8::new(0);
      const AUCTION_END: u64 = 1;
      const ITEM: &str = "Starry night by Van Gogh";

      fn dummy_fresh_state() -> State {
	  dummy_active_state(Amount::zero(), BTreeMap::new())
      }

      fn dummy_active_state(highest: Amount, bids: BTreeMap<AccountAddress, Amount>) -> State {
	  State {
	      auction_state: AuctionState::NotSoldYet,
	      highest_bid: highest,
	      item: ITEM.as_bytes().to_vec(),
	      expiry: Timestamp::from_timestamp_millis(AUCTION_END),
	      bids,
	  }
      }

      fn expect_error<E, T>(expr: Result<T, E>, err: E, msg: &str)
      where
	  E: Eq + Debug,
	  T: Debug,
      {
	  let actual = expr.expect_err(msg);
	  assert_eq!(actual, err);
      }

      fn item_expiry_parameter() -> InitParameter {
	  InitParameter {
	      item: ITEM.as_bytes().to_vec(),
	      expiry: Timestamp::from_timestamp_millis(AUCTION_END),
	  }
      }

      fn create_parameter_bytes(parameter: &InitParameter) -> Vec<u8> {
	  to_bytes(parameter)
      }

      fn parametrized_init_ctx<'a>(parameter_bytes: &'a Vec<u8>) -> InitContextTest<'a> {
	  let mut ctx = InitContextTest::empty();
	  ctx.set_parameter(parameter_bytes);
	  ctx
      }

      fn new_account() -> AccountAddress {
	  let account = AccountAddress([ADDRESS_COUNTER.load(Ordering::SeqCst); 32]);
	  ADDRESS_COUNTER.fetch_add(1, Ordering::SeqCst);
	  account
      }

      fn new_account_ctx<'a>() -> (AccountAddress, ReceiveContextTest<'a>) {
	  let account = new_account();
	  let ctx = new_ctx(account, account, AUCTION_END);
	  (account, ctx)
      }

      fn new_ctx<'a>(
	  owner: AccountAddress,
	  sender: AccountAddress,
	  slot_time: u64,
      ) -> ReceiveContextTest<'a> {
	  let mut ctx = ReceiveContextTest::empty();
	  ctx.set_sender(Address::Account(sender));
	  ctx.set_owner(owner);
	  ctx.set_metadata_slot_time(Timestamp::from_timestamp_millis(slot_time));
	  ctx
      }

      #[test]
      /// Test that the smart-contract initialization sets the state correctly
      /// (no bids, active state, indicated auction-end time and item name).
      fn test_init() {
	  let parameter_bytes = create_parameter_bytes(&item_expiry_parameter());
	  let ctx = parametrized_init_ctx(&parameter_bytes);

	  let state_result = auction_init(&ctx);
	  let state = state_result.expect("Contract initialization results in error");
	  assert_eq!(
	      state,
	      dummy_fresh_state(),
	      "Auction state should be new after initialization"
	  );
      }

      #[test]
      /// Test a sequence of bids and finalizations:
      /// 0. Auction is initialized.
      /// 1. Alice successfully bids 0.1 GTU.
      /// 2. Alice successfully bids another 0.1 GTU, highest bid becomes 0.2 GTU
      /// (the sum of her two bids). 3. Bob successfully bids 0.3 GTU, highest
      /// bid becomes 0.3 GTU. 4. Someone tries to finalize the auction before
      /// its end time. Attempt fails. 5. Dave successfully finalizes the
      /// auction after its end time.    Alice gets her money back, while
      /// Carol (the owner of the contract) collects the highest bid amount.
      /// 6. Attempts to subsequently bid or finalize fail.
      fn test_auction_bid_and_finalize() {
	  let parameter_bytes = create_parameter_bytes(&item_expiry_parameter());
	  let ctx0 = parametrized_init_ctx(&parameter_bytes);

	  let amount = Amount::from_micro_ccd(100);
	  let winning_amount = Amount::from_micro_ccd(300);
	  let big_amount = Amount::from_micro_ccd(500);

	  let mut bid_map = BTreeMap::new();

	  // initializing auction
	  let mut state = auction_init(&ctx0).expect("Initialization should pass");

	  // 1st bid: account1 bids amount1
	  let (alice, alice_ctx) = new_account_ctx();
	  verify_bid(&mut state, alice, &alice_ctx, amount, &mut bid_map, amount);

	  // 2nd bid: account1 bids `amount` again
	  // should work even though it's the same amount because account1 simply
	  // increases their bid
	  verify_bid(
	      &mut state,
	      alice,
	      &alice_ctx,
	      amount,
	      &mut bid_map,
	      amount + amount,
	  );


	  // 3rd bid: second account
	  let (bob, bob_ctx) = new_account_ctx();
	  verify_bid(
	      &mut state,
	      bob,
	      &bob_ctx,
	      winning_amount,
	      &mut bid_map,
	      winning_amount,
	  );

	  // trying to finalize auction that is still active
	  // (specifically, the bid is submitted at the last moment, at the AUCTION_END
	  // time)
	  let mut ctx4 = ReceiveContextTest::empty();
	  ctx4.set_metadata_slot_time(Timestamp::from_timestamp_millis(AUCTION_END));
	  ctx4.set_owner(bob); // TODO: If not set fails in coercion value never used because it fails early. Is this a bug in the implementation or a feature that needs to be mimiced in hacspec.
	  ctx4.set_self_balance(winning_amount); // TODO: If not set fails in coercion value never used because it fails early. Is this a bug in the implementation or a feature that needs to be mimiced in hacspec.
	  let finres: Result<ActionsTree, _> = auction_finalize(&ctx4, &mut state);
	  expect_error(
	      finres,
	      FinalizeError::AuctionStillActive,
	      "Finalizing auction should fail when it's before auction-end time",
	  );

	  // finalizing auction
	  let carol = new_account();
	  let dave = new_account();
	  let mut ctx5 = new_ctx(carol, dave, AUCTION_END + 1);
	  ctx5.set_self_balance(winning_amount);
	  let finres2: Result<ActionsTree, _> = auction_finalize(&ctx5, &mut state);
	  let actions = finres2.expect("Finalizing auction should work");
	  assert_eq!(
	      actions,
	      ActionsTree::simple_transfer(&carol, winning_amount)
		  .and_then(ActionsTree::simple_transfer(&alice, amount + amount))
	  );

	  assert_eq!(
	      state,
	      State {
		  auction_state: AuctionState::Sold(bob),
		  highest_bid: winning_amount,
		  item: ITEM.as_bytes().to_vec(),
		  expiry: Timestamp::from_timestamp_millis(AUCTION_END),
		  bids: bid_map,
	      }
	  );


	  // attempting to finalize auction again should fail
	  let finres3: Result<ActionsTree, _> = auction_finalize(&ctx5, &mut state);
	  expect_error(
	      finres3,
	      FinalizeError::AuctionFinalized,
	      "Finalizing auction a second time should fail",
	  );

	  // attempting to bid again should fail
	  let res4: Result<ActionsTree, _> = auction_bid(&bob_ctx, big_amount, &mut state);
	  expect_error(
	      res4,
	      BidError::AuctionFinalized,
	      "Bidding should fail because the auction is finalized",
	  );
      }

      fn verify_bid(
	  mut state: &mut State,
	  account: AccountAddress,
	  ctx: &ContextTest<ReceiveOnlyDataTest>,
	  amount: Amount,
	  bid_map: &mut BTreeMap<AccountAddress, Amount>,
	  highest_bid: Amount,
      ) {
	  let res: Result<ActionsTree, _> = auction_bid(ctx, amount, &mut state);
	  res.expect("Bidding should pass");
	  bid_map.insert(account, highest_bid);
	  assert_eq!(*state, dummy_active_state(highest_bid, bid_map.clone()));
      }

      #[test]
      /// Bids for amounts lower or equal to the highest bid should be rejected.
      fn test_auction_bid_repeated_bid() {
	  let (account1, ctx1) = new_account_ctx();
	  let ctx2 = new_account_ctx().1;

	  let parameter_bytes = create_parameter_bytes(&item_expiry_parameter());
	  let ctx0 = parametrized_init_ctx(&parameter_bytes);

	  let amount = Amount::from_micro_ccd(100);

	  let mut bid_map = BTreeMap::new();

	  // initializing auction
	  let mut state = auction_init(&ctx0).expect("Init results in error");

	  // 1st bid: account1 bids amount1
	  verify_bid(&mut state, account1, &ctx1, amount, &mut bid_map, amount);

	  // 2nd bid: account2 bids amount1
	  // should fail because amount is equal to highest bid
	  let res2: Result<ActionsTree, _> = auction_bid(&ctx2, amount, &mut state);
	  expect_error(
	      res2,
	      BidError::BidTooLow, /* { bid: amount, highest_bid: amount } */
	      "Bidding 2 should fail because bid amount must be higher than highest bid",
	  );
      }

      #[test]
      /// Bids for 0 GTU should be rejected.
      fn test_auction_bid_zero() {
	  let ctx1 = new_account_ctx().1;
	  let parameter_bytes = create_parameter_bytes(&item_expiry_parameter());
	  let ctx = parametrized_init_ctx(&parameter_bytes);

	  let mut state = auction_init(&ctx).expect("Init results in error");

	  let res: Result<ActionsTree, _> = auction_bid(&ctx1, Amount::zero(), &mut state);
	  expect_error(
	      res,
	      BidError::BidTooLow, /* { bid: Amount::zero(), highest_bid: Amount::zero()} */
	      "Bidding zero should fail",
	  );
      }
  }
#+end_src

** Generation of backend output

#+begin_src elisp :var SOURCE-CODE-FILE="Hacspec_Auction.v" :results output silent :tangle no
(org-babel-detangle SOURCE-CODE-FILE)
#+end_src

*** auction - Coq code
:PROPERTIES:
:header-args: coq :tangle Hacspec_Auction.v :mkdirp yes :comments link
:header-args: coq :eval never :results output silent
:END:

#+begin_src coq

(** This file was automatically generated using Hacspec **)
Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
From Coq Require Import List.
Import ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.
From QuickChick Require Import QuickChick.
Require Import QuickChickLib.

From ConCert.Utils Require Import Extras.
From ConCert.Utils Require Import Automation.
From ConCert.Execution Require Import Serializable.
From ConCert.Execution Require Import Blockchain.
From ConCert.Execution Require Import ContractCommon.
From Coq Require Import Morphisms ZArith Basics.
Open Scope Z.
Set Nonrecursive Elimination Schemes.
#+end_src

#+begin_src coq
Require Import Hacspec_Lib.
Export Hacspec_Lib.
#+end_src

#+begin_src coq
Require Import Concert_Lib.
Export Concert_Lib.
#+end_src

#+begin_src coq
Definition user_address_t := nseq (int8) (usize 32).
Instance show_user_address_t : Show (user_address_t) := Build_Show (user_address_t) show.
Definition g_user_address_t : G (user_address_t) := arbitrary.
Instance gen_user_address_t : Gen (user_address_t) := Build_Gen user_address_t g_user_address_t.
#+end_src

#+begin_src coq
Inductive auction_state_hacspec_t :=
| NotSoldYet : auction_state_hacspec_t
| Sold : user_address_t -> auction_state_hacspec_t.
Global Instance serializable_auction_state_hacspec_t : Serializable auction_state_hacspec_t :=
  Derive Serializable auction_state_hacspec_t_rect<NotSoldYet,Sold>.

Definition eqb_auction_state_hacspec_t (x y : auction_state_hacspec_t) : bool :=
match x with
   | NotSoldYet => match y with | NotSoldYet=> true | _ => false end
   | Sold a => match y with | Sold b => a =.? b | _ => false end
   end.

Definition eqb_leibniz_auction_state_hacspec_t (x y : auction_state_hacspec_t) : eqb_auction_state_hacspec_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_auction_state_hacspec_t : EqDec (auction_state_hacspec_t) :=
  Build_EqDec (auction_state_hacspec_t) (eqb_auction_state_hacspec_t) (eqb_leibniz_auction_state_hacspec_t).

Global Instance show_auction_state_hacspec_t : Show (auction_state_hacspec_t) :=
 @Build_Show (auction_state_hacspec_t) (fun x =>
 match x with
 NotSoldYet => ("NotSoldYet")%string
 | Sold a => ("Sold" ++ show a)%string
 end).
Definition g_auction_state_hacspec_t : G (auction_state_hacspec_t) := oneOf_ (returnGen NotSoldYet) [returnGen NotSoldYet;bindGen arbitrary (fun a => returnGen (Sold a))].
Global Instance gen_auction_state_hacspec_t : Gen (auction_state_hacspec_t) := Build_Gen auction_state_hacspec_t g_auction_state_hacspec_t.
#+end_src

#+begin_src coq
Inductive seq_map_t :=
| SeqMap : (public_byte_seq ∏ public_byte_seq) -> seq_map_t.
Global Instance serializable_seq_map_t : Serializable seq_map_t :=
  Derive Serializable seq_map_t_rect<SeqMap>.

Definition eqb_seq_map_t (x y : seq_map_t) : bool :=
match x with
   | SeqMap a => match y with | SeqMap b => a =.? b end
   end.

Definition eqb_leibniz_seq_map_t (x y : seq_map_t) : eqb_seq_map_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_seq_map_t : EqDec (seq_map_t) :=
  Build_EqDec (seq_map_t) (eqb_seq_map_t) (eqb_leibniz_seq_map_t).

Global Instance show_seq_map_t : Show (seq_map_t) :=
 @Build_Show (seq_map_t) (fun x =>
 match x with
 SeqMap a => ("SeqMap" ++ show a)%string
 end).
Definition g_seq_map_t : G (seq_map_t) := oneOf_ (bindGen arbitrary (fun a => returnGen (SeqMap a))) [bindGen arbitrary (fun a => returnGen (SeqMap a))].
Global Instance gen_seq_map_t : Gen (seq_map_t) := Build_Gen seq_map_t g_seq_map_t.
#+end_src

#+begin_src coq
Inductive state_hacspec_t :=
| StateHacspec : (
  auction_state_hacspec_t ∏
  int64 ∏
  public_byte_seq ∏
  int64 ∏
  seq_map_t
) -> state_hacspec_t.
Global Instance serializable_state_hacspec_t : Serializable state_hacspec_t :=
  Derive Serializable state_hacspec_t_rect<StateHacspec>.

Definition eqb_state_hacspec_t (x y : state_hacspec_t) : bool :=
match x with
   | StateHacspec a => match y with | StateHacspec b => a =.? b end
   end.

Definition eqb_leibniz_state_hacspec_t (x y : state_hacspec_t) : eqb_state_hacspec_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_state_hacspec_t : EqDec (state_hacspec_t) :=
  Build_EqDec (state_hacspec_t) (eqb_state_hacspec_t) (eqb_leibniz_state_hacspec_t).

Global Instance show_state_hacspec_t : Show (state_hacspec_t) :=
 @Build_Show (state_hacspec_t) (fun x =>
 match x with
 StateHacspec a => ("StateHacspec" ++ show a)%string
 end).
Definition g_state_hacspec_t : G (state_hacspec_t) := oneOf_ (bindGen arbitrary (fun a => returnGen (StateHacspec a))) [bindGen arbitrary (fun a => returnGen (StateHacspec a))].
Global Instance gen_state_hacspec_t : Gen (state_hacspec_t) := Build_Gen state_hacspec_t g_state_hacspec_t.
#+end_src

#+begin_src coq
Definition fresh_state_hacspec
  (itm_0 : public_byte_seq)
  (exp_1 : int64): state_hacspec_t :=
  StateHacspec ((
      NotSoldYet,
      @repr WORDSIZE64 0,
      itm_0,
      exp_1,
      SeqMap ((seq_new_ (default) (usize 0), seq_new_ (default) (usize 0)))
    )).
#+end_src

#+begin_src coq
Inductive init_parameter_t :=
| InitParameter : (public_byte_seq ∏ int64) -> init_parameter_t.
Global Instance serializable_init_parameter_t : Serializable init_parameter_t :=
  Derive Serializable init_parameter_t_rect<InitParameter>.
Global Instance show_init_parameter_t : Show (init_parameter_t) :=
 @Build_Show (init_parameter_t) (fun x =>
 match x with
 InitParameter a => ("InitParameter" ++ show a)%string
 end).
Definition g_init_parameter_t : G (init_parameter_t) := oneOf_ (bindGen arbitrary (fun a => returnGen (InitParameter a))) [bindGen arbitrary (fun a => returnGen (InitParameter a))].
Global Instance gen_init_parameter_t : Gen (init_parameter_t) := Build_Gen init_parameter_t g_init_parameter_t.
#+end_src

#+begin_src coq
Inductive context_t :=
| Context : (user_address_t ∏ user_address_t ∏ int64 ∏ int64
) -> context_t.
Global Instance serializable_context_t : Serializable context_t :=
  Derive Serializable context_t_rect<Context>.
Global Instance show_context_t : Show (context_t) :=
 @Build_Show (context_t) (fun x =>
 match x with
 Context a => ("Context" ++ show a)%string
 end).
Definition g_context_t : G (context_t) := oneOf_ (bindGen arbitrary (fun a => returnGen (Context a))) [bindGen arbitrary (fun a => returnGen (Context a))].
Global Instance gen_context_t : Gen (context_t) := Build_Gen context_t g_context_t.
#+end_src

#+begin_src coq
Notation "'context_state_hacspec_t'" := ((context_t ∏ state_hacspec_t
  )) : hacspec_scope.
Instance show_context_state_hacspec_t : Show (context_state_hacspec_t) :=
Build_Show context_state_hacspec_t (fun x =>
  let (x, x0) := x in
  (("(") ++ ((show x) ++ ((",") ++ ((show x0) ++ (")"))))))%string.
Definition g_context_state_hacspec_t : G (context_state_hacspec_t) :=
bindGen arbitrary (fun x0 : context_t =>
  bindGen arbitrary (fun x1 : state_hacspec_t =>
  returnGen (x0,x1))).
Instance gen_context_state_hacspec_t : Gen (context_state_hacspec_t) := Build_Gen context_state_hacspec_t g_context_state_hacspec_t.
#+end_src

#+begin_src coq
Definition auction_init
  (ctx_2 : context_t)
  (init_parameter_3 : init_parameter_t): context_state_hacspec_t :=
  (
    ctx_2,
    fresh_state_hacspec (seq_new_ (default) (usize 0)) (@repr WORDSIZE64 0)
  ).
Definition State := context_state_hacspec_t.
  Definition Setup := init_parameter_t.
  Definition auction_State (chain : Chain) (ctx : ContractCallContext) (setup : Setup) : option State :=
  Some (auction_init (Context (ctx.(ctx_from), ctx.(ctx_origin), repr ctx.(ctx_amount), 0 (* TODO *))) setup).
#+end_src

#+begin_src coq
Definition seq_map_entry
  (m_4 : seq_map_t)
  (sender_address_5 : user_address_t): (int64 ∏ seq_map_t) :=
  let 'SeqMap ((m0_6, m1_7)) :=
    m_4 in 
  let res_8 : (int64 ∏ seq_map_t) :=
    (
      @repr WORDSIZE64 0,
      SeqMap ((
	  seq_concat ((m0_6)) (array_to_seq (sender_address_5)),
	  seq_concat ((m1_7)) (array_to_seq (u64_to_be_bytes (
	      @repr WORDSIZE64 0)))
	))
    ) in 
  let res_8 :=
    foldi (usize 0) ((seq_len ((m0_6))) / (usize 32)) (fun x_9 res_8 =>
      let '(res_8) :=
	if (array_from_seq (32) (seq_slice ((m0_6)) ((x_9) * (usize 32)) (
	      usize 32))) array_eq (sender_address_5):bool then (let res_8 :=
	    (
	      u64_from_be_bytes (array_from_seq (8) (seq_slice ((m1_7)) ((
		      x_9) * (usize 8)) (usize 8))),
	      SeqMap (((m0_6), (m1_7)))
	    ) in 
	  (res_8)) else ((res_8)) in 
      (res_8))
    res_8 in 
  res_8.
#+end_src

#+begin_src coq
Inductive map_update_t :=
| Update : (int64 ∏ seq_map_t) -> map_update_t.
Global Instance serializable_map_update_t : Serializable map_update_t :=
  Derive Serializable map_update_t_rect<Update>.

Definition eqb_map_update_t (x y : map_update_t) : bool :=
match x with
   | Update a => match y with | Update b => a =.? b end
   end.

Definition eqb_leibniz_map_update_t (x y : map_update_t) : eqb_map_update_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_map_update_t : EqDec (map_update_t) :=
  Build_EqDec (map_update_t) (eqb_map_update_t) (eqb_leibniz_map_update_t).

Global Instance show_map_update_t : Show (map_update_t) :=
 @Build_Show (map_update_t) (fun x =>
 match x with
 Update a => ("Update" ++ show a)%string
 end).
Definition g_map_update_t : G (map_update_t) := oneOf_ (bindGen arbitrary (fun a => returnGen (Update a))) [bindGen arbitrary (fun a => returnGen (Update a))].
Global Instance gen_map_update_t : Gen (map_update_t) := Build_Gen map_update_t g_map_update_t.
#+end_src

#+begin_src coq
Definition seq_map_update_entry
  (m_10 : seq_map_t)
  (sender_address_11 : user_address_t)
  (amount_12 : int64): map_update_t :=
  let 'SeqMap ((m0_13, m1_14)) :=
    m_10 in 
  let res_15 : map_update_t :=
    Update ((
	amount_12,
	SeqMap ((
	    seq_concat ((m0_13)) (array_to_seq (sender_address_11)),
	    seq_concat ((m1_14)) (array_to_seq (u64_to_be_bytes (amount_12)))
	  ))
      )) in 
  let res_15 :=
    foldi (usize 0) ((seq_len ((m0_13))) / (usize 32)) (fun x_16 res_15 =>
      let '(res_15) :=
	if (array_from_seq (32) (seq_slice ((m0_13)) ((x_16) * (usize 32)) (
	      usize 32))) array_eq (sender_address_11):bool then (let res_15 :=
	    Update ((
		amount_12,
		SeqMap ((
		    seq_update ((m0_13)) ((x_16) * (usize 32)) (
		      array_to_seq (sender_address_11)),
		    seq_update ((m1_14)) ((x_16) * (usize 8)) (
		      array_to_seq (u64_to_be_bytes (amount_12)))
		  ))
	      )) in 
	  (res_15)) else ((res_15)) in 
      (res_15))
    res_15 in 
  res_15.
#+end_src

#+begin_src coq
Inductive bid_error_hacspec_t :=
| ContractSender : bid_error_hacspec_t
| BidTooLow : bid_error_hacspec_t
| BidsOverWaitingForAuctionFinalization : bid_error_hacspec_t
| AuctionIsFinalized : bid_error_hacspec_t.
Global Instance serializable_bid_error_hacspec_t : Serializable bid_error_hacspec_t :=
  Derive Serializable bid_error_hacspec_t_rect<ContractSender,BidTooLow,BidsOverWaitingForAuctionFinalization,AuctionIsFinalized>.

Definition eqb_bid_error_hacspec_t (x y : bid_error_hacspec_t) : bool :=
match x with
   | ContractSender => match y with | ContractSender=> true | _ => false end
   | BidTooLow => match y with | BidTooLow=> true | _ => false end
   | BidsOverWaitingForAuctionFinalization =>
       match y with
       | BidsOverWaitingForAuctionFinalization=> true
       | _ => false
       end
   | AuctionIsFinalized =>
       match y with
       | AuctionIsFinalized=> true
       | _ => false
       end
   end.

Definition eqb_leibniz_bid_error_hacspec_t (x y : bid_error_hacspec_t) : eqb_bid_error_hacspec_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_bid_error_hacspec_t : EqDec (bid_error_hacspec_t) :=
  Build_EqDec (bid_error_hacspec_t) (eqb_bid_error_hacspec_t) (eqb_leibniz_bid_error_hacspec_t).

Global Instance show_bid_error_hacspec_t : Show (bid_error_hacspec_t) :=
 @Build_Show (bid_error_hacspec_t) (fun x =>
 match x with
 ContractSender => ("ContractSender")%string
 | BidTooLow => ("BidTooLow")%string
 | BidsOverWaitingForAuctionFinalization => (
   "BidsOverWaitingForAuctionFinalization")%string
 | AuctionIsFinalized => ("AuctionIsFinalized")%string
 end).
Definition g_bid_error_hacspec_t : G (bid_error_hacspec_t) := oneOf_ (returnGen ContractSender) [returnGen ContractSender;returnGen BidTooLow;returnGen BidsOverWaitingForAuctionFinalization;returnGen AuctionIsFinalized].
Global Instance gen_bid_error_hacspec_t : Gen (bid_error_hacspec_t) := Build_Gen bid_error_hacspec_t g_bid_error_hacspec_t.
#+end_src

#+begin_src coq
Notation "'auction_bid_result_t'" := ((
    result state_hacspec_t bid_error_hacspec_t)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition auction_bid_hacspec
  (ctx_17 : context_t)
  (amount_18 : int64)
  (state_19 : state_hacspec_t): auction_bid_result_t :=
  let 'StateHacspec ((
	auction_state_20,
	highest_bid_21,
	st2_22,
	expiry_23,
	st4_24
      )) :=
    (state_19) in 
  ifbnd negb ((auction_state_20) =.? (NotSoldYet)) : bool
  thenbnd (bind (@Err state_hacspec_t bid_error_hacspec_t (
	AuctionIsFinalized)) (fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  let 'Context ((owner_25, sender_26, balance_27, slot_time_28)) :=
    ctx_17 in 
  ifbnd negb ((slot_time_28) <=.? (expiry_23)) : bool
  thenbnd (bind (@Err state_hacspec_t bid_error_hacspec_t (
	BidsOverWaitingForAuctionFinalization)) (fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  let '(bid_to_update_29, new_map_30) :=
    seq_map_entry ((st4_24)) (sender_26) in 
  let '(updated_bid_31, updated_map_32) :=
    match seq_map_update_entry ((st4_24)) (sender_26) ((bid_to_update_29) .+ (
	amount_18)) with
    | Update (updated_bid_33, updated_map_34) => (updated_bid_33, updated_map_34
    )
    end in 
  ifbnd negb ((updated_bid_31) >.? (highest_bid_21)) : bool
  thenbnd (bind (@Err state_hacspec_t bid_error_hacspec_t (BidTooLow)) (
      fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  @Ok state_hacspec_t bid_error_hacspec_t (StateHacspec ((
	auction_state_20,
	updated_bid_31,
	st2_22,
	expiry_23,
	updated_map_32
      )))))).
#+end_src

#+begin_src coq
Definition auction_bid
  (ctx_35 : context_state_hacspec_t)
  (amount_36 : int64): (option (context_state_hacspec_t ∏ list_action_t)) :=
  let s_37 : seq has_action_t :=
    seq_new_ (default) (usize 0) in 
  @Some (context_state_hacspec_t ∏ list_action_t) ((ctx_35, s_37)).

Definition bid (amount : int64)(st : State) :=
  auction_bid st amount.
#+end_src

#+begin_src coq
Inductive finalize_error_hacspec_t :=
| BidMapError : finalize_error_hacspec_t
| AuctionStillActive : finalize_error_hacspec_t
| AuctionFinalized : finalize_error_hacspec_t.
Global Instance serializable_finalize_error_hacspec_t : Serializable finalize_error_hacspec_t :=
  Derive Serializable finalize_error_hacspec_t_rect<BidMapError,AuctionStillActive,AuctionFinalized>.

Definition eqb_finalize_error_hacspec_t (x y : finalize_error_hacspec_t) : bool :=
match x with
   | BidMapError => match y with | BidMapError=> true | _ => false end
   | AuctionStillActive =>
       match y with
       | AuctionStillActive=> true
       | _ => false
       end
   | AuctionFinalized => match y with | AuctionFinalized=> true | _ => false end
   end.

Definition eqb_leibniz_finalize_error_hacspec_t (x y : finalize_error_hacspec_t) : eqb_finalize_error_hacspec_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_finalize_error_hacspec_t : EqDec (finalize_error_hacspec_t) :=
  Build_EqDec (finalize_error_hacspec_t) (eqb_finalize_error_hacspec_t) (eqb_leibniz_finalize_error_hacspec_t).

Global Instance show_finalize_error_hacspec_t : Show (finalize_error_hacspec_t) :=
 @Build_Show (finalize_error_hacspec_t) (fun x =>
 match x with
 BidMapError => ("BidMapError")%string
 | AuctionStillActive => ("AuctionStillActive")%string
 | AuctionFinalized => ("AuctionFinalized")%string
 end).
Definition g_finalize_error_hacspec_t : G (finalize_error_hacspec_t) := oneOf_ (returnGen BidMapError) [returnGen BidMapError;returnGen AuctionStillActive;returnGen AuctionFinalized].
Global Instance gen_finalize_error_hacspec_t : Gen (finalize_error_hacspec_t) := Build_Gen finalize_error_hacspec_t g_finalize_error_hacspec_t.
#+end_src

#+begin_src coq
Notation "'finalize_context_t'" := ((int64 ∏ user_address_t ∏ int64
  )) : hacspec_scope.
Instance show_finalize_context_t : Show (finalize_context_t) :=
Build_Show finalize_context_t (fun x =>
  let (x, x0) := x in
  let (x, x1) := x in
  (
    ("(") ++ ((show x) ++ ((",") ++ ((show x0) ++ ((",") ++ ((show x1) ++ (")"))))))))%string.
Definition g_finalize_context_t : G (finalize_context_t) :=
bindGen arbitrary (fun x0 : int64 =>
  bindGen arbitrary (fun x1 : user_address_t =>
  bindGen arbitrary (fun x2 : int64 =>
  returnGen (x0,x1,x2)))).
Instance gen_finalize_context_t : Gen (finalize_context_t) := Build_Gen finalize_context_t g_finalize_context_t.
#+end_src

#+begin_src coq
Inductive finalize_action_t :=
| Accept : finalize_action_t
| SimpleTransfer : public_byte_seq -> finalize_action_t.
Global Instance serializable_finalize_action_t : Serializable finalize_action_t :=
  Derive Serializable finalize_action_t_rect<Accept,SimpleTransfer>.

Definition eqb_finalize_action_t (x y : finalize_action_t) : bool :=
match x with
   | Accept => match y with | Accept=> true | _ => false end
   | SimpleTransfer a =>
       match y with
       | SimpleTransfer b => a =.? b
       | _ => false
       end
   end.

Definition eqb_leibniz_finalize_action_t (x y : finalize_action_t) : eqb_finalize_action_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_finalize_action_t : EqDec (finalize_action_t) :=
  Build_EqDec (finalize_action_t) (eqb_finalize_action_t) (eqb_leibniz_finalize_action_t).

Global Instance show_finalize_action_t : Show (finalize_action_t) :=
 @Build_Show (finalize_action_t) (fun x =>
 match x with
 Accept => ("Accept")%string
 | SimpleTransfer a => ("SimpleTransfer" ++ show a)%string
 end).
Definition g_finalize_action_t : G (finalize_action_t) := oneOf_ (returnGen Accept) [returnGen Accept;bindGen arbitrary (fun a => returnGen (SimpleTransfer a))].
Global Instance gen_finalize_action_t : Gen (finalize_action_t) := Build_Gen finalize_action_t g_finalize_action_t.
#+end_src

#+begin_src coq
Inductive bid_remain_t :=
| BidNone : bid_remain_t
| BidSome : int64 -> bid_remain_t.
Global Instance serializable_bid_remain_t : Serializable bid_remain_t :=
  Derive Serializable bid_remain_t_rect<BidNone,BidSome>.

Definition eqb_bid_remain_t (x y : bid_remain_t) : bool :=
match x with
   | BidNone => match y with | BidNone=> true | _ => false end
   | BidSome a => match y with | BidSome b => a =.? b | _ => false end
   end.

Definition eqb_leibniz_bid_remain_t (x y : bid_remain_t) : eqb_bid_remain_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_bid_remain_t : EqDec (bid_remain_t) :=
  Build_EqDec (bid_remain_t) (eqb_bid_remain_t) (eqb_leibniz_bid_remain_t).

Global Instance show_bid_remain_t : Show (bid_remain_t) :=
 @Build_Show (bid_remain_t) (fun x =>
 match x with
 BidNone => ("BidNone")%string
 | BidSome a => ("BidSome" ++ show a)%string
 end).
Definition g_bid_remain_t : G (bid_remain_t) := oneOf_ (returnGen BidNone) [returnGen BidNone;bindGen arbitrary (fun a => returnGen (BidSome a))].
Global Instance gen_bid_remain_t : Gen (bid_remain_t) := Build_Gen bid_remain_t g_bid_remain_t.
#+end_src

#+begin_src coq
Notation "'auction_finalize_result_t'" := ((result (
      state_hacspec_t ∏
      finalize_action_t
    ) finalize_error_hacspec_t)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition auction_finalize_hacspec
  (ctx_38 : finalize_context_t)
  (state_39 : state_hacspec_t): auction_finalize_result_t :=
  let 'StateHacspec ((
	auction_state_40,
	highest_bid_41,
	st2_42,
	expiry_43,
	SeqMap ((m0_44, m1_45))
      )) :=
    (state_39) in 
  let result_46 : (result (state_hacspec_t ∏ finalize_action_t
      ) finalize_error_hacspec_t) :=
    @Ok (state_hacspec_t ∏ finalize_action_t) finalize_error_hacspec_t ((
	(state_39),
	Accept
      )) in 
  ifbnd negb ((auction_state_40) =.? (NotSoldYet)) : bool
  thenbnd (bind (@Err (state_hacspec_t ∏ finalize_action_t
      ) finalize_error_hacspec_t (AuctionFinalized)) (fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  let '(slot_time_47, owner_48, balance_49) :=
    ctx_38 in 
  ifbnd negb ((slot_time_47) >.? (expiry_43)) : bool
  thenbnd (bind (@Err (state_hacspec_t ∏ finalize_action_t
      ) finalize_error_hacspec_t (AuctionStillActive)) (fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  ifbnd (balance_49) !=.? (@repr WORDSIZE64 0) : bool
  thenbnd (let return_action_50 : finalize_action_t :=
      SimpleTransfer (seq_concat (seq_concat (seq_new_ (default) (usize 0)) (
	    array_to_seq (owner_48))) (array_to_seq (u64_to_be_bytes (
	    highest_bid_41)))) in 
    let remaining_bid_51 : bid_remain_t :=
      BidNone in 
    bind (foldibnd (usize 0) to ((seq_len ((m0_44))) / (usize 32)) for (
	auction_state_40,
	return_action_50,
	remaining_bid_51
      ) >> (fun x_52 '(auction_state_40, return_action_50, remaining_bid_51) =>
      let addr_53 : user_address_t :=
	array_from_seq (32) (seq_slice ((m0_44)) ((x_52) * (usize 32)) (
	    usize 32)) in 
      let amnt_54 : int64 :=
	u64_from_be_bytes (array_from_seq (8) (seq_slice ((m1_45)) ((x_52) * (
		usize 8)) (usize 8))) in 
      ifbnd (amnt_54) <.? (highest_bid_41) : bool
      then (let return_action_50 :=
	  match return_action_50 with
	  | Accept => Accept
	  | SimpleTransfer m_55 => SimpleTransfer (seq_concat (seq_concat (
		m_55) (array_to_seq (addr_53))) (array_to_seq (u64_to_be_bytes (
		amnt_54))))
	  end in 
	(auction_state_40, return_action_50, remaining_bid_51))
      elsebnd(ifbnd negb ((remaining_bid_51) =.? (BidNone)) : bool
	thenbnd (bind (@Err (state_hacspec_t ∏ finalize_action_t
	    ) finalize_error_hacspec_t (BidMapError)) (fun _ =>  Ok (tt)))
	else (tt) >> (fun 'tt =>
	let auction_state_40 :=
	  Sold (addr_53) in 
	let remaining_bid_51 :=
	  BidSome (amnt_54) in 
	Ok ((auction_state_40, return_action_50, remaining_bid_51)))) >> (fun '(
	auction_state_40,
	return_action_50,
	remaining_bid_51
      ) =>
      Ok ((auction_state_40, return_action_50, remaining_bid_51))))) (fun '(
	auction_state_40,
	return_action_50,
	remaining_bid_51
      ) => let result_46 :=
	match remaining_bid_51 with
	| BidSome amount_56 => (if (negb ((amount_56) =.? (
		highest_bid_41))):bool then (@Err (
	      state_hacspec_t ∏
	      finalize_action_t
	    ) finalize_error_hacspec_t (BidMapError)) else (@Ok (
	      state_hacspec_t ∏
	      finalize_action_t
	    ) finalize_error_hacspec_t ((
		StateHacspec ((
		    auction_state_40,
		    highest_bid_41,
		    st2_42,
		    expiry_43,
		    SeqMap (((m0_44), (m1_45)))
		  )),
		return_action_50
	      ))))
	| BidNone => @Err (state_hacspec_t ∏ finalize_action_t
	) finalize_error_hacspec_t (BidMapError)
	end in 
      bind ((result_46)) (fun _ =>  Ok ((auction_state_40, result_46)))))
  else ((auction_state_40, result_46)) >> (fun '(auction_state_40, result_46) =>
  result_46))).
#+end_src

#+begin_src coq
Definition auction_finalize
  (ctx_57 : context_state_hacspec_t): (option (
      context_state_hacspec_t ∏
      list_action_t
    )) :=
  let s_58 : seq has_action_t :=
    seq_new_ (default) (usize 0) in 
  @Some (context_state_hacspec_t ∏ list_action_t) ((ctx_57, s_58)).

Definition finalize (st : State) :=
  auction_finalize st.
#+end_src

#+begin_src coq
Definition auction_test_init
  (item_59 : public_byte_seq)
  (time_60 : int64): bool :=
  (fresh_state_hacspec ((item_59)) (time_60)) =.? (StateHacspec ((
	NotSoldYet,
	@repr WORDSIZE64 0,
	(item_59),
	time_60,
	SeqMap ((seq_new_ (default) (usize 0), seq_new_ (default) (usize 0)))
      ))).


Theorem ensures_auction_test_init : forall result_61 (
  item_59 : public_byte_seq) (time_60 : int64),
 @auction_test_init item_59 time_60 = result_61 ->
 (result_61) =.? (true).
 Proof. Admitted.
QuickChick (forAll g_public_byte_seq (fun item_59 : public_byte_seq =>
  forAll g_int64 (fun time_60 : int64 =>
  auction_test_init item_59 time_60))).
#+end_src

#+begin_src coq
Definition verify_bid
  (item_62 : public_byte_seq)
  (state_63 : state_hacspec_t)
  (account_64 : user_address_t)
  (ctx_65 : context_t)
  (amount_66 : int64)
  (bid_map_67 : seq_map_t)
  (highest_bid_68 : int64)
  (time_69 : int64): (state_hacspec_t ∏ seq_map_t ∏ bool ∏ bool) :=
  let t_70 : (result state_hacspec_t bid_error_hacspec_t) :=
    auction_bid_hacspec (ctx_65) (amount_66) ((state_63)) in 
  let '(state_71, res_72) :=
    match t_70 with
    | Err e_73 => (state_63, false)
    | Ok s_74 => (s_74, true)
    end in 
  let bid_map_75 : seq_map_t :=
    match seq_map_update_entry ((bid_map_67)) (account_64) (highest_bid_68) with
    | Update (_, updated_map_76) => updated_map_76
    end in 
  (
    (state_71),
    (bid_map_75),
    res_72,
    ((state_71)) =.? (StateHacspec ((
	  NotSoldYet,
	  highest_bid_68,
	  (item_62),
	  time_69,
	  (bid_map_75)
	)))
  ).
#+end_src

#+begin_src coq
Definition useraddress_from_u8 (i_77 : int8): user_address_t :=
  array_from_list int8 (let l :=
      [
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77;
	i_77
      ] in  l).
#+end_src

#+begin_src coq
Definition new_account
  (time_78 : int64)
  (i_79 : int8): (user_address_t ∏ context_t) :=
  let addr_80 : user_address_t :=
    useraddress_from_u8 (i_79) in 
  let ctx_81 : context_t :=
    Context ((addr_80, addr_80, @repr WORDSIZE64 0, time_78)) in 
  (addr_80, ctx_81).
#+end_src

#+begin_src coq
Definition test_auction_bid_and_finalize
  (item_82 : public_byte_seq)
  (time_83 : int64)
  (input_amount_84 : int64): bool :=
  let time_85 : int64 :=
    (if ((time_83) =.? (@repr WORDSIZE64 18446744073709551615)):bool then (
	@repr WORDSIZE64 18446744073709551614) else (time_83)) in 
  let input_amount_86 : int64 :=
    (if ((input_amount_84) >.? (((@repr WORDSIZE64 18446744073709551615) ./ (
	      @repr WORDSIZE64 5)) .- (@repr WORDSIZE64 1))):bool then (
	@repr WORDSIZE64 100) else (input_amount_84)) in 
  let amount_87 : int64 :=
    (input_amount_86) .+ (@repr WORDSIZE64 1) in 
  let winning_amount_88 : int64 :=
    (amount_87) .* (@repr WORDSIZE64 3) in 
  let big_amount_89 : int64 :=
    (amount_87) .* (@repr WORDSIZE64 5) in 
  let bid_map_90 : seq_map_t :=
    SeqMap ((seq_new_ (default) (usize 0), seq_new_ (default) (usize 0))) in 
  let state_91 : state_hacspec_t :=
    fresh_state_hacspec ((item_82)) (time_85) in 
  let '(alice_92, alice_ctx_93) :=
    new_account (time_85) (@repr WORDSIZE8 0) in 
  let 'Context ((_, ac0_94, _, ac1_95)) :=
    alice_ctx_93 in 
  let '(state_96, bid_map_97, res_0_98, result_0_99) :=
    verify_bid ((item_82)) (state_91) (alice_92) (alice_ctx_93) (amount_87) (
      bid_map_90) (amount_87) (time_85) in 
  let '(state_100, bid_map_101, res_1_102, result_1_103) :=
    verify_bid ((item_82)) (state_96) (alice_92) (alice_ctx_93) (amount_87) (
      bid_map_97) ((amount_87) .+ (amount_87)) (time_85) in 
  let '(bob_104, bob_ctx_105) :=
    new_account (time_85) (@repr WORDSIZE8 1) in 
  let 'Context ((_, bc1_106, _, bc2_107)) :=
    bob_ctx_105 in 
  let '(state_108, bid_map_109, res_2_110, result_2_111) :=
    verify_bid ((item_82)) (state_100) (bob_104) (bob_ctx_105) (
      winning_amount_88) (bid_map_101) (winning_amount_88) (time_85) in 
  let owner_112 : user_address_t :=
    useraddress_from_u8 (@repr WORDSIZE8 0) in 
  let balance_113 : int64 :=
    @repr WORDSIZE64 100 in 
  let ctx4_114 : (int64 ∏ user_address_t ∏ int64) :=
    (time_85, owner_112, balance_113) in 
  let finres_115 : (result (state_hacspec_t ∏ finalize_action_t
      ) finalize_error_hacspec_t) :=
    auction_finalize_hacspec (ctx4_114) ((state_108)) in 
  let '(state_116, result_3_117) :=
    match finres_115 with
    | Err err_118 => ((state_108), (err_118) =.? (AuctionStillActive))
    | Ok (state_119, _) => (state_119, false)
    end in 
  let '(carol_120, carol_ctx_121) :=
    new_account (time_85) (@repr WORDSIZE8 2) in 
  let ctx5_122 : (int64 ∏ user_address_t ∏ int64) :=
    ((time_85) .+ (@repr WORDSIZE64 1), carol_120, winning_amount_88) in 
  let finres2_123 : (result (state_hacspec_t ∏ finalize_action_t
      ) finalize_error_hacspec_t) :=
    auction_finalize_hacspec (ctx5_122) ((state_116)) in 
  let '(state_124, result_4_125) :=
    match finres2_123 with
    | Err _ => ((state_116), false)
    | Ok (state_126, action_127) => (
      state_126,
      (action_127) =.? (SimpleTransfer (seq_concat (seq_concat (seq_concat (
		seq_concat (seq_new_ (default) (usize 0)) (
		  array_to_seq (carol_120))) (array_to_seq (u64_to_be_bytes (
		  winning_amount_88)))) (array_to_seq (alice_92))) (
	    array_to_seq (u64_to_be_bytes ((amount_87) .+ (amount_87))))))
    )
    end in 
  let result_5_128 : bool :=
    ((state_124)) =.? (StateHacspec ((
	  Sold (bob_104),
	  winning_amount_88,
	  (item_82),
	  time_85,
	  (bid_map_109)
	))) in 
  let finres3_129 : (result (state_hacspec_t ∏ finalize_action_t
      ) finalize_error_hacspec_t) :=
    auction_finalize_hacspec (ctx5_122) ((state_124)) in 
  let '(state_130, result_6_131) :=
    match finres3_129 with
    | Err err_132 => (state_124, (err_132) =.? (AuctionFinalized))
    | Ok (state_133, action_134) => (state_133, false)
    end in 
  let t_135 : (result state_hacspec_t bid_error_hacspec_t) :=
    auction_bid_hacspec (bob_ctx_105) (big_amount_89) ((state_130)) in 
  let result_7_136 : bool :=
    match t_135 with
    | Err e_137 => (e_137) =.? (AuctionIsFinalized)
    | Ok _ => false
    end in 
  (((((((result_0_99) && (result_1_103)) && (result_2_111)) && (
	    result_3_117)) && (result_4_125)) && (result_5_128)) && (
      result_6_131)) && (result_7_136).


Theorem ensures_test_auction_bid_and_finalize : forall result_61 (
  item_82 : public_byte_seq) (time_83 : int64) (input_amount_84 : int64),
 @test_auction_bid_and_finalize item_82 time_83 input_amount_84 = result_61 ->
 (result_61) =.? (true).
 Proof. Admitted.
QuickChick (forAll g_public_byte_seq (fun item_82 : public_byte_seq =>
  forAll g_int64 (fun time_83 : int64 =>
  forAll g_int64 (fun input_amount_84 : int64 =>
  test_auction_bid_and_finalize item_82 time_83 input_amount_84)))).
#+end_src

#+begin_src coq
Inductive Msg :=
| BID
| FINALIZE.
Global Instance Msg_serializable : Serializable Msg :=
  Derive Serializable Msg_rect<BID,FINALIZE>.
Definition auction_receive (chain : Chain) (ctx : ContractCallContext) (state : State) (msg : option Msg) : option (State * list ActionBody) :=
  match msg with
  | Some BID => to_action_body_list ctx (bid (repr ctx.(ctx_amount)) state)
  | Some FINALIZE => to_action_body_list ctx (finalize state)
  | None => None
  end.

Definition auction_contract : Contract Setup Msg State :=
  build_contract auction_State auction_receive.
#+end_src
# 32 code sections
