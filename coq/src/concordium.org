#+TITLE: Concordium Smartcontract Infrastructure Implementations
#+AUTHOR: Lasse Letager Hansen

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file
# C-c C-v s   -  create results / run subtree

* General information
:PROPERTIES:
:header-args: sh :eval never :results output silent
:END:
** Resulting output
#+begin_src sh
  cargo clean
#+end_src

#+begin_src sh
  cargo install --path language
#+end_src

#+begin_src sh
  cargo build
#+end_src

#+begin_src sh
  cargo hacspec -o coq/src/Concordium.v hacspec-concordium --init --org-file concordium.org
#+end_src

#+begin_src sh
  cargo hacspec -o coq/src/Concordium.v hacspec-concordium --update --org-file concordium.org
#+end_src

* Concordium specification
** Config
#+BEGIN_SRC toml :tangle ../../examples/concordium/Cargo.toml :eval never
  [package]
  name = "hacspec-concordium"
  version = "0.1.0"
  authors = [""]
  edition = "2018"

  [lib]
  path = "src/lib.rs"

  [dependencies]
  hacspec-lib = { path = "../../lib" }
  hacspec-attributes = { path = "../../utils/attributes", version = "0.1.0-beta.1" , features = ["print_attributes", "hacspec_unsafe"] } # , features = ["hacspec_unsafe"] , , optional = true
  creusot-contracts = { path = "../../../../creusot/creusot-contracts" }
  concordium-contracts-common = { path = "../../../../concordium-rust-smart-contracts/concordium-contracts-common" ,  version = "=0.4" , default-features = false }
  hacspec-concordium-derive = { path = "../concordium-derive" }

  # Reduce code size, at the cost of performance in allocation heavy-code.
  wee_alloc="0.4.5"

  [features]
  use_attributes = ["hacspec-attributes/print_attributes", "hacspec-attributes/hacspec_unsafe"]

  [dev-dependencies]
  hacspec-dev = { path = "../../utils/dev" }
  criterion = "0.3"
  rand = "0.8"
  quickcheck = "1"
  quickcheck_macros = "1"
#+END_SRC
*** Imports
#+BEGIN_SRC rust :tangle ../../examples/concordium/src/lib.rs :eval never
#![cfg_attr(not(feature = "std"), no_std, feature(alloc_error_handler, core_intrinsics))]

#[cfg(not(feature = "hacspec"))]
#[cfg(not(feature = "std"))]
pub extern crate alloc;

// TODO:
// #[cfg(not(feature = "hacspec"))]
// #[cfg(not(feature = "std"))]
// #[alloc_error_handler]
// fn on_oom(_layout: alloc::alloc::Layout) -> ! {
//     #[cfg(target_arch = "wasm32")]
//     unsafe {
//         core::arch::wasm32::unreachable()
//     }
//     #[cfg(not(target_arch = "wasm32"))]
//     loop {}
// }

/// Terminate execution immediately without panicking.
/// When the `std` feature is enabled this is just [std::process::abort](https://doc.rust-lang.org/std/process/fn.abort.html).
/// When `std` is not present and the target architecture is `wasm32` this will
/// simply emit the [unreachable](https://doc.rust-lang.org/core/arch/wasm32/fn.unreachable.html) instruction.
#[cfg(not(feature = "hacspec"))]
#[cfg(feature = "std")]
pub use std::process::abort as trap;
#[cfg(not(feature = "hacspec"))]
#[cfg(all(not(feature = "std"), target_arch = "wasm32"))]
#[inline(always)]
pub fn trap() -> ! { unsafe { core::arch::wasm32::unreachable() } }
#[cfg(not(feature = "hacspec"))]
#[cfg(all(not(feature = "std"), not(target_arch = "wasm32")))]
#[inline(always)]
pub fn trap() -> ! { core::intrinsics::abort() }

// TODO:
// #[cfg(not(feature = "hacspec"))]
// #[cfg(not(feature = "std"))]
// #[panic_handler]
// fn abort_panic(_info: &core::panic::PanicInfo) -> ! {
//     #[cfg(target_arch = "wasm32")]
//     unsafe {
//         core::arch::wasm32::unreachable()
//     }
//     #[cfg(not(target_arch = "wasm32"))]
//     loop {}
// }

// Provide some re-exports to make it easier to use the library.
// This should be expanded in the future.
/// Re-export.
#[cfg(not(feature = "hacspec"))]
#[cfg(not(feature = "std"))]
pub use alloc::{borrow::ToOwned, string, string::String, string::ToString, vec, vec::Vec};
/// Re-export.
#[cfg(not(feature = "hacspec"))]
#[cfg(not(feature = "std"))]
pub use core::{convert, hash, marker, mem, num, result::*};
#[cfg(not(feature = "hacspec"))]
#[cfg(feature = "std")]
pub(crate) use std::vec;

/// Re-export.
#[cfg(not(feature = "hacspec"))]
#[cfg(feature = "std")]
pub use std::{convert, hash, marker, mem, num, string::String, vec::Vec};

#[cfg(not(feature = "hacspec"))]
pub mod collections {
    #[cfg(not(feature = "std"))]
    use alloc::collections;
    #[cfg(feature = "std")]
    use std::collections;

    pub use collections::*;
    pub use concordium_contracts_common::{HashMap, HashSet};
}

#[cfg(not(feature = "hacspec"))]
/// Chain constants that impose limits on various aspects of smart contract
/// execution.
pub use concordium_contracts_common::*;

#[cfg(not(feature = "hacspec"))]
pub use hacspec_concordium_derive::*;

#[cfg(not(feature = "hacspec"))]
extern crate wee_alloc;
// Use `wee_alloc` as the global allocator to reduce code size.
#[cfg(not(feature = "hacspec"))]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[cfg(not(feature = "hacspec"))]
pub mod test_infrastructure;

mod hacspec_concordium_types;
mod hacspec_concordium_traits;
mod hacspec_concordium_prims;
mod hacspec_concordium_impls;

#[cfg(not(feature = "hacspec"))]
pub use hacspec_concordium_types::*;
#[cfg(not(feature = "hacspec"))]
pub use hacspec_concordium_traits::*;
#[cfg(not(feature = "hacspec"))]
pub use hacspec_concordium_prims::*;
#[cfg(not(feature = "hacspec"))]
pub use hacspec_concordium_impls::*;
#+END_SRC

* Concordium "Types" specification
** Rust code
:PROPERTIES:
:header-args:  :tangle ../../examples/concordium/src/hacspec_concordium_types.rs
:END:

*** Imports
#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  use crate::num::NonZeroI32;
#+END_SRC

*** Types code
#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// A type representing the constract state bytes.
  #[derive(Default)]
  pub struct ContractState {
      pub(crate) current_position: u32,
  }

  #[cfg(not(feature = "hacspec"))]
  #[derive(Default)]
  /// A type representing the parameter to init and receive methods.
  pub struct Parameter {
      pub(crate) current_position: u32,
  }

  #[cfg(not(feature = "hacspec"))]
  /// A type representing the attributes, lazily acquired from the host.
  #[derive(Default)]
  pub struct AttributesCursor {
      /// Current position of the cursor, starting from 0.
      /// Note that this is only for the variable attributes.
      /// `created_at` and `valid_to` will require.
      pub(crate) current_position: u32,
      /// The number of remaining items in the policy.
      pub(crate) remaining_items:  u16,
  }

  #[cfg(not(feature = "hacspec"))]
  /// A type representing the logger.
  #[derive(Default)]
  pub struct Logger {
      pub(crate) _private: (),
  }

  // #[cfg(not(feature = "hacspec"))]
  /// Errors that can occur during logging.
  #[derive(Debug, Copy, Clone, Eq, PartialEq)]
  #[repr(u8)]
  pub enum LogError {
      /// The log is full.
      Full,
      /// The message to log was malformed (e.g., too long)
      Malformed,
  }

  #[cfg(not(feature = "hacspec"))]
  /// Actions that can be produced at the end of a contract execution. This
  /// type is deliberately not cloneable so that we can enforce that
  /// `and_then` and `or_else` can only be used when more than one event is
  /// created.
  ///
  /// This type is marked as `must_use` since functions that produce
  /// values of the type are effectful.
  #[must_use]
  pub struct Action {
      pub(crate) _private: u32,
  }

  #[cfg(not(feature = "hacspec"))]
  impl Action {
      pub fn tag(&self) -> u32 { self._private }
  }

  #[cfg(not(feature = "hacspec"))]
  /// An error message, signalling rejection of a smart contract invocation.
  /// The client will see the error code as a reject reason; if a schema is
  /// provided, the error message corresponding to the error code will be
  /// displayed. The valid range for an error code is from i32::MIN to  -1.
  #[derive(Debug, Eq, PartialEq)] // TODO: Creusot issue re-add "Debug" attribute 
  #[repr(transparent)]
  pub struct Reject {
      pub error_code: NonZeroI32,
  }

  #[cfg(not(feature = "hacspec"))]
  /// Default error is i32::MIN.
  impl Default for Reject {
      #[inline(always)]
      fn default() -> Self {
          Self {
              error_code: unsafe { NonZeroI32::new_unchecked(i32::MIN) },
          }
      }
  }

  #[cfg(not(feature = "hacspec"))]
  impl Reject {
      /// This returns `None` for all values >= 0 and `Some` otherwise.
      pub fn new(x: i32) -> Option<Self> {
          if x < 0 {
              let error_code = unsafe { NonZeroI32::new_unchecked(x) };
              Some(Reject {
                  error_code,
              })
          } else {
              None
          }
      }
  }

  // Macros for failing a contract function

  #[cfg(not(feature = "hacspec"))]
  /// The `bail` macro can be used for cleaner error handling. If the function has
  /// result type `Result` invoking `bail` will terminate execution early with an
  /// error.
  /// If an argument is supplied, this will be used as the error, otherwise it
  /// requires the type `E` in `Result<_, E>` to implement the `Default` trait.
  #[macro_export]
  macro_rules! bail {
      () => {{
          return Err(Default::default());
      }};
      ($arg:expr) => {{
          // format_err!-like formatting
          // logs are only retained in case of rejection when testing.
          return Err($arg);
      }};
  }

  #[cfg(not(feature = "hacspec"))]
  /// The `ensure` macro can be used for cleaner error handling. It is analogous
  /// to `assert`, but instead of panicking it uses `bail` to terminate execution
  /// of the function early.
  #[macro_export]
  macro_rules! ensure {
      ($p:expr) => {
          if !$p {
              $crate::bail!();
          }
      };
      ($p:expr, $arg:expr) => {{
          if !$p {
              $crate::bail!($arg);
          }
      }};
  }

  #[cfg(not(feature = "hacspec"))]
  /// ## Variants of `ensure` for ease of use in certain contexts.
  /// Ensure the first two arguments are equal, using `bail` otherwise.
  #[macro_export]
  macro_rules! ensure_eq {
      ($l:expr, $r:expr) => {
          $crate::ensure!($l == $r)
      };
      ($l:expr, $r:expr, $arg:expr) => {
          $crate::ensure!($l == $r, $arg)
      };
  }

  #[cfg(not(feature = "hacspec"))]
  #[macro_export]
  /// Ensure the first two arguments are __not__ equal, using `bail` otherwise.
  macro_rules! ensure_ne {
      ($l:expr, $r:expr) => {
          $crate::ensure!($l != $r)
      };
      ($l:expr, $r:expr, $arg:expr) => {
          $crate::ensure!($l != $r, $arg)
      };
  }

  // Macros for failing a test

  #[cfg(not(feature = "hacspec"))]
  /// The `fail` macro is used for testing as a substitute for the panic macro.
  /// It reports back error information to the host.
  /// Used only in testing.
  #[cfg(feature = "std")]
  #[macro_export]
  macro_rules! fail {
      () => {
          {
              $crate::test_infrastructure::report_error("", file!(), line!(), column!());
              panic!()
          }
      };
      ($($arg:tt),+) => {
          {
              let msg = format!($($arg),+);
              $crate::test_infrastructure::report_error(&msg, file!(), line!(), column!());
              panic!("{}", msg)
          }
      };
  }

  #[cfg(not(feature = "hacspec"))]
  /// The `fail` macro is used for testing as a substitute for the panic macro.
  /// It reports back error information to the host.
  /// Used only in testing.
  #[cfg(not(feature = "std"))]
  #[macro_export]
  macro_rules! fail {
      () => {
          {
              $crate::test_infrastructure::report_error("", file!(), line!(), column!());
              panic!()
          }
      };
      ($($arg:tt),+) => {
          {
              let msg = &$crate::alloc::format!($($arg),+);
              $crate::test_infrastructure::report_error(&msg, file!(), line!(), column!());
              panic!("{}", msg)
          }
      };
  }

  #[cfg(not(feature = "hacspec"))]
  /// The `claim` macro is used for testing as a substitute for the assert macro.
  /// It checks the condition and if false it reports back an error.
  /// Used only in testing.
  #[macro_export]
  macro_rules! claim {
      ($cond:expr) => {
          if !$cond {
              $crate::fail!()
          }
      };
      ($cond:expr,) => {
          if !$cond {
              $crate::fail!()
          }
      };
      ($cond:expr, $($arg:tt),+) => {
          if !$cond {
              $crate::fail!($($arg),+)
          }
      };
  }

  #[cfg(not(feature = "hacspec"))]
  /// Ensure the first two arguments are equal, just like `assert_eq!`, otherwise
  /// reports an error. Used only in testing.
  #[macro_export]
  macro_rules! claim_eq {
      ($left:expr, $right:expr) => {
          $crate::claim!($left == $right, "left and right are not equal\nleft: {:?}\nright: {:?}", $left, $right)
      };
      ($left:expr, $right:expr,) => {
          $crate::claim_eq!($left, $right)
      };
      ($left:expr, $right:expr, $($arg:tt),+) => {
          $crate::claim!($left == $right, $($arg),+)
      };
  }

  #[cfg(not(feature = "hacspec"))]
  /// Ensure the first two arguments are *not* equal, just like `assert_ne!`,
  /// otherwise reports an error.
  /// Used only in testing.
  #[macro_export]
  macro_rules! claim_ne {
      ($left:expr, $right:expr) => {
          $crate::claim!($left != $right)
      };
      ($left:expr, $right:expr,) => {
          $crate::claim!($left != $right)
      };
      ($left:expr, $right:expr, $($arg:tt),+) => {
          $crate::claim!($left != $right, $($arg),+)
      };
  }

  #[cfg(not(feature = "hacspec"))]
  /// The expected return type of the receive method of a smart contract.
  ///
  /// Optionally, to define a custom type for error instead of using
  /// Reject, allowing to track the reason for rejection, *but only in unit
  /// tests*.
  ///
  /// See also the documentation for [bail!](macro.bail.html) for how to use
  /// custom error types.
  ///
  /// # Example
  /// Defining a custom error type
  /// ```rust
  /// enum MyCustomError {
  ///     SomeError
  /// }
  ///
  /// #[receive(contract = "mycontract", name = "receive")]
  /// fn contract_receive<R: HasReceiveContext, L: HasLogger, A: HasActions>(
  ///     ctx: &R,
  ///     receive_amount: Amount,
  ///     logger: &mut L,
  ///     state: &mut State,
  /// ) -> Result<A, MyCustomError> { ... }
  /// ```
  pub type ReceiveResult<A> = Result<A, Reject>;

  #[cfg(not(feature = "hacspec"))]
  /// The expected return type of the init method of the smart contract,
  /// parametrized by the state type of the smart contract.
  ///
  /// Optionally, to define a custom type for error instead of using Reject,
  /// allowing the track the reason for rejection, *but only in unit tests*.
  ///
  /// See also the documentation for [bail!](macro.bail.html) for how to use
  /// custom error types.
  ///
  /// # Example
  /// Defining a custom error type
  /// ```rust
  /// enum MyCustomError {
  ///     SomeError
  /// }
  ///
  /// #[init(contract = "mycontract")]
  /// fn contract_init<R: HasReceiveContext, L: HasLogger, A: HasActions>(
  ///     ctx: &R,
  ///     receive_amount: Amount,
  ///     logger: &mut L,
  /// ) -> Result<State, MyCustomError> { ... }
  /// ```
  pub type InitResult<S> = Result<S, Reject>;


  #[cfg(not(feature = "hacspec"))]
  /// Context backed by host functions.
  #[derive(Default)]
  #[doc(hidden)]
  pub struct ExternContext<T: sealed::ContextType> {
      marker: crate::marker::PhantomData<T>,
  }

  #[cfg(not(feature = "hacspec"))]
  #[doc(hidden)]
  pub struct ChainMetaExtern {}

  #[cfg(not(feature = "hacspec"))]
  #[derive(Default)]
  #[doc(hidden)]
  pub struct InitContextExtern;
  #[cfg(not(feature = "hacspec"))]
  #[derive(Default)]
  #[doc(hidden)]
  pub struct ReceiveContextExtern;

  #[cfg(not(feature = "hacspec"))]
  pub(crate) mod sealed {
      use super::*;
      /// Marker trait intended to indicate which context type we have.
      /// This is deliberately a sealed trait, so that it is only implementable
      /// by types in this crate.
      pub trait ContextType {}
      impl ContextType for InitContextExtern {}
      impl ContextType for ReceiveContextExtern {}
  }
#+END_SRC

* Concordium "Traits" specification
** Rust code
:PROPERTIES:
:header-args:  :tangle ../../examples/concordium/src/hacspec_concordium_traits.rs
:END:
*** Imports
#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  use crate::collections::{BTreeMap, BTreeSet, HashSet, HashMap};

  #[cfg(not(feature = "hacspec"))]
  use crate::hash::Hash;
  
  #[cfg(not(feature = "hacspec"))]
  extern crate concordium_contracts_common;
  #[cfg(not(feature = "hacspec"))]
  use concordium_contracts_common::*;
#+END_SRC

#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  use crate::*;
  // #[cfg(not(feature = "hacspec"))]
  // use hacspec_concordium_types::*;
#+END_SRC

*** Traits code
#+BEGIN_SRC rust :eval never
  // //! This module implements traits for the contract interface.
  // //! This allows setting-up mock objects for testing individual
  // //! contract invocations.

  #[cfg(not(feature = "hacspec"))]
  /// Objects which can access parameters to contracts.
  ///
  /// This trait has a Read supertrait which means that structured parameters can
  /// be directly deserialized by using `.get()` function from the `Get` trait.
  ///
  /// The reuse of `Read` methods is the reason for the slightly strange choice of
  /// methods of this trait.
  pub trait HasParameter: Read {
      /// Get the size of the parameter to the method.
      fn size(&self) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Objects which can access chain metadata.
  pub trait HasChainMetadata {
      /// Get time in milliseconds at the beginning of this block.
      fn slot_time(&self) -> SlotTime;
  }

  #[cfg(not(feature = "hacspec"))]
  /// A type which has access to a policy of a credential.
  /// Since policies can be large this is deliberately written in a relatively
  /// low-level style to enable efficient traversal of all the attributes without
  /// any allocations.
  pub trait HasPolicy {
      /// Identity provider who signed the identity object the credential is
      /// derived from.
      fn identity_provider(&self) -> IdentityProvider;
      /// Beginning of the month in milliseconds since unix epoch when the
      /// credential was created.
      fn created_at(&self) -> Timestamp;
      /// Beginning of the month where the credential is no longer valid, in
      /// milliseconds since unix epoch.
      fn valid_to(&self) -> Timestamp;
      /// Get the next attribute, storing it in the provided buffer.
      /// The return value, if `Some`, is a pair of an attribute tag, and the
      /// length, `n` of the attribute value. In this case, the attribute
      /// value is written in the first `n` bytes of the provided buffer. The
      /// rest of the buffer is unchanged.
      ///
      /// The reason this function is added here, and we don't simply implement
      /// an Iterator for this type is that with the supplied buffer we can
      /// iterate through the elements more efficiently, without any allocations,
      /// the consumer being responsible for allocating the buffer.
      fn next_item(&mut self, buf: &mut [u8; 31]) -> Option<(AttributeTag, u8)>;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Common data accessible to both init and receive methods.
  pub trait HasCommonData {
      type PolicyType: HasPolicy;
      type MetadataType: HasChainMetadata;
      type ParamType: HasParameter + Read;
      type PolicyIteratorType: ExactSizeIterator<Item = Self::PolicyType>;
      /// Policies of the sender of the message.
      /// For init methods this is the would-be creator of the contract,
      /// for the receive this is the policies of the immediate sender.
      ///
      /// In the latter case, if the sender is an account then it is the policies
      /// of the account, if it is a contract then it is the policies of the
      /// creator of the contract.
      fn policies(&self) -> Self::PolicyIteratorType;
      /// Get the reference to chain metadata
      fn metadata(&self) -> &Self::MetadataType;
      /// Get the cursor to the parameter.
      fn parameter_cursor(&self) -> Self::ParamType;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Types which can act as init contexts.
  pub trait HasInitContext<Error: Default = ()>: HasCommonData {
      /// Data needed to open the context.
      type InitData;
      /// Open the init context for reading and accessing values.
      fn open(data: Self::InitData) -> Self;
      /// Who invoked this init call.
      fn init_origin(&self) -> AccountAddress;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Types which can act as receive contexts.
  pub trait HasReceiveContext<Error: Default = ()>: HasCommonData {
      type ReceiveData;

      /// Open the receive context for reading and accessing values.
      fn open(data: Self::ReceiveData) -> Self;
      /// Who is the account that initiated the top-level transaction this
      /// invocation is a part of.
      fn invoker(&self) -> AccountAddress;
      /// The address of the contract being invoked.
      fn self_address(&self) -> ContractAddress;
      /// Balance on the contract before the call was made.
      fn self_balance(&self) -> Amount;
      /// The immediate sender of the message. In general different from the
      /// invoker.
      fn sender(&self) -> Address;
      /// Account which created the contract instance.
      fn owner(&self) -> AccountAddress;
  }

  #[cfg(not(feature = "hacspec"))]
  /// A type that can serve as the contract state type.
  pub trait HasContractState<Error: Default = ()>
  where
      Self: Read,
      Self: Write<Err = Error>,
      Self: Seek<Err = Error>, {
      type ContractStateData;
      /// Open the contract state. Only one instance can be opened at the same
      /// time.
      fn open(_: Self::ContractStateData) -> Self;

      /// Get the current size of contract state.
      fn size(&self) -> u32;

      /// Truncate the state to the given size. If the given size is more than the
      /// current state size this operation does nothing. The new position is at
      /// most at the end of the stream.
      fn truncate(&mut self, new_size: u32);

      /// Make sure that the memory size is at least that many bytes in size.
      /// Returns true iff this was successful. The new bytes are initialized as
      /// 0.
      fn reserve(&mut self, len: u32) -> bool;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Objects which can serve as loggers.
  ///
  /// Logging functionality can be used by smart contracts to record events that
  /// might be of interest to external parties. These events are not used on the
  /// chain, and cannot be observed by other contracts, but they are stored by the
  /// node, and can be queried to provide information to off-chain actors.
  pub trait HasLogger {
      /// Initialize a logger.
      fn init() -> Self;

      /// Log the given slice as-is. If logging is not successful an error will be
      /// returned.
      fn log_raw(&mut self, event: &[u8]) -> Result<(), LogError>;

      #[inline(always)]
      /// Log a serializable event by serializing it with a supplied serializer.
      fn log<S: Serial>(&mut self, event: &S) -> Result<(), LogError> {
          let mut out = Vec::new();
          if event.serial(&mut out).is_err() {
              trap(); // should not happen
          }
          self.log_raw(&out)
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// An object that can serve to construct actions.
  ///
  /// The actions that a smart contract can produce as a
  /// result of its execution. These actions form a tree and are executed by
  /// the scheduler in the predefined order.
  pub trait HasActions {
      /// Default accept action.
      fn accept() -> Self;
  
      /// Send a given amount to an account.
      fn simple_transfer(acc: &AccountAddress, amount: Amount) -> Self;

      /// Send a message to a contract.
      fn send_raw(
          ca: &ContractAddress,
          receive_name: ReceiveName,
          amount: Amount,
          parameter: &[u8],
      ) -> Self;

      /// If the execution of the first action succeeds, run the second action
      /// as well.
      fn and_then(self, then: Self) -> Self;

      /// If the execution of the first action fails, try the second.
      fn or_else(self, el: Self) -> Self;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Add optimized unwrap behaviour that aborts the process instead of
  /// panicking.
  pub trait UnwrapAbort {
      /// The underlying result type of the unwrap, in case of success.
      type Unwrap;
      /// Unwrap or call [trap](./fn.trap.html). In contrast to
      /// the unwrap methods on [Option::unwrap](https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap)
      /// this method will tend to produce smaller code, at the cost of the
      /// ability to handle the panic.
      /// This is intended to be used only in `Wasm` code, where panics cannot be
      /// handled anyhow.
      fn unwrap_abort(self) -> Self::Unwrap;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Analogue of the `expect` methods on types such as [Option](https://doc.rust-lang.org/std/option/enum.Option.html),
  /// but useful in a Wasm setting.
  pub trait ExpectReport {
      type Unwrap;
      /// Like the default `expect` on, e.g., `Result`, but calling
      /// [fail](macro.fail.html) with the given message, instead of `panic`.
      fn expect_report(self, msg: &str) -> Self::Unwrap;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Analogue of the `expect_err` methods on [Result](https://doc.rust-lang.org/std/result/enum.Result.html),
  /// but useful in a Wasm setting.
  pub trait ExpectErrReport {
      type Unwrap;
      /// Like the default `expect_err` on, e.g., `Result`, but calling
      /// [fail](macro.fail.html) with the given message, instead of `panic`.
      fn expect_err_report(self, msg: &str) -> Self::Unwrap;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Analogue of the `expect_none` methods on [Option](https://doc.rust-lang.org/std/option/enum.Option.html),
  /// but useful in a Wasm setting.
  pub trait ExpectNoneReport {
      /// Like the default `expect_none_report` on, e.g., `Option`, but calling
      /// [fail](macro.fail.html) with the given message, instead of `panic`.
      fn expect_none_report(self, msg: &str);
  }

  #[cfg(not(feature = "hacspec"))]
  /// The `SerialCtx` trait provides a means of writing structures into byte-sinks
  /// (`Write`) using contextual information.
  /// The contextual information is:
  ///
  ///   - `size_length`: The number of bytes used to record the length of the
  ///     data.
  pub trait SerialCtx {
      /// Attempt to write the structure into the provided writer, failing if
      /// if the length cannot be represented in the provided `size_length` or
      /// only part of the structure could be written.
      ///
      /// NB: We use Result instead of Option for better composability with other
      /// constructs.
      fn serial_ctx<W: Write>(
          &self,
          size_length: schema::SizeLength,
          out: &mut W,
      ) -> Result<(), W::Err>;
  }

  #[cfg(not(feature = "hacspec"))]
  /// The `DeserialCtx` trait provides a means of reading structures from
  /// byte-sources (`Read`) using contextual information.
  /// The contextual information is:
  ///
  ///   - `size_length`: The expected number of bytes used for the length of the
  ///     data.
  ///   - `ensure_ordered`: Whether the ordering should be ensured, for example
  ///     that keys in `BTreeMap` and `BTreeSet` are in strictly increasing order.
  pub trait DeserialCtx: Sized {
      /// Attempt to read a structure from a given source and context, failing if
      /// an error occurs during deserialization or reading.
      fn deserial_ctx<R: Read>(
          size_length: schema::SizeLength,
          ensure_ordered: bool,
          source: &mut R,
      ) -> ParseResult<Self>;
  }
#+END_SRC

* Concordium "Prims" specification
** Rust code
:PROPERTIES:
:header-args:  :tangle ../../examples/concordium/src/hacspec_concordium_prims.rs
:END:

*** Imports
#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern crate hacspec_lib;

  use hacspec_lib::*;

  #[cfg(feature = "hacspec")]
  use hacspec_attributes::*;

  // Creusot
  #[cfg(not(feature = "hacspec"))]
  extern crate creusot_contracts;
  #[cfg(not(feature = "hacspec"))]
  use creusot_contracts::{
      trusted          
      };
#+END_SRC

#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  use crate::*;
#+END_SRC

*** Externs
Load state extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn load_state(start: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn load_state_creusot(start: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { load_state(start, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn load_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn load_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      let result = load_state_creusot(temp.as_mut_ptr(), buf.len() as u32, offset);
      (
          coerce_rust_to_hacspec_public_byte_seq(&temp),
          result,
      )
  }

#+end_src
Write state extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn write_state(start: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn write_state_creusot(start: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { write_state(start, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn write_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn write_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      let result = write_state_creusot(temp.as_mut_ptr(), buf.len() as u32, offset);
      (
          coerce_rust_to_hacspec_public_byte_seq(&temp),
          result,
      )
  }
#+end_src
State size extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn state_size() -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn state_size_creusot() -> u32 {
      unsafe { state_size() }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn state_size_hacspec() -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn state_size_hacspec() -> u32 {
      state_size_creusot()
  }
  
#+end_src
Resize state extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Resize state to the new value (truncate if new size is smaller). Return 0 if
      // this was unsuccesful (new state too big), or 1 if successful.
      pub(crate) fn resize_state(new_size: u32) -> u32; // returns 0 or 1.
                                                        // get current state size in bytes.
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn resize_state_creusot(new_size: u32) -> u32 {
      unsafe { resize_state(new_size) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn resize_state_hacspec(new_size: u32) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn resize_state_hacspec(new_size: u32) -> u32 {
      resize_state_creusot(new_size)
  }
#+end_src
Extern for parameter section
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Write a section of the parameter to the given location. Return the number
      // of bytes written. The location is assumed to contain enough memory to
      // write the requested length into.
      pub(crate) fn get_parameter_section(param_bytes: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_parameter_section_creusot(start: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { get_parameter_section(start, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn get_parameter_section_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn get_parameter_section_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      let result = get_parameter_section_creusot(temp.as_mut_ptr(), buf.len() as u32, offset);
      (
          coerce_rust_to_hacspec_public_byte_seq(&temp),
          result,
      )
  }

#+end_src
Extern for parameter size and ~HasParameter~ trait.
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Get the size of the parameter to the method (either init or receive).
      pub(crate) fn get_parameter_size() -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_parameter_size_creusot() -> u32 {
      unsafe { get_parameter_size() }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn get_parameter_size_hacspec() -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn get_parameter_size_hacspec() -> u32 {
      get_parameter_size_creusot()
  }

  #[cfg(not(feature = "hacspec"))]
  impl HasParameter for Parameter {
      #[inline(always)]
      fn size(&self) -> u32 {
          get_parameter_size_hacspec()
      }
  }

#+end_src
Get slot time extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Getters for the chain meta data
    /// Slot time (in milliseconds) from chain meta data
    pub(crate) fn get_slot_time() -> u64;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_slot_time_creusot() -> u64 {
      unsafe { get_slot_time() }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn get_slot_time_hacspec() -> u64 {
      1u64
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn get_slot_time_hacspec() -> u64 {
      get_slot_time_creusot()
  }
#+end_src
Get policy section extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Write a section of the policy to the given location. Return the number
    // of bytes written. The location is assumed to contain enough memory to
    // write the requested length into.
    pub(crate) fn get_policy_section(policy_bytes: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_policy_section_creusot(policy_bytes: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { get_policy_section(policy_bytes, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn get_policy_section_hacspec(policy_bytes: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (policy_bytes, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn get_policy_section_hacspec(policy_bytes: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(policy_bytes.clone())[..];
      let result = get_policy_section_creusot(temp.as_mut_ptr(), policy_bytes.len() as u32, offset);
      (
          coerce_rust_to_hacspec_public_byte_seq(&temp),
          result,
      )
  }

#+end_src
Get init origin extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Getter for the init context.
    /// Address of the sender, 32 bytes
    pub(crate) fn get_init_origin(start: *mut u8);
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_init_origin_creusot(start: *mut u8) {
      unsafe { get_init_origin(start) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn get_init_origin_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      start
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn get_init_origin_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      get_init_origin_creusot(temp.as_mut_ptr());
      coerce_rust_to_hacspec_public_byte_seq(&temp)
  }

#+end_src
Get receive invoker extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    /// Invoker of the top-level transaction, AccountAddress.
    pub(crate) fn get_receive_invoker(start: *mut u8);
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_receive_invoker_creusot(start: *mut u8) {
      unsafe { get_receive_invoker(start) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn get_receive_invoker_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      start
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn get_receive_invoker_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      get_receive_invoker_creusot(temp.as_mut_ptr());
      coerce_rust_to_hacspec_public_byte_seq(&temp)
  }

#+end_src
Get receive self address extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    /// Address of the contract itself, ContractAddress.
    pub(crate) fn get_receive_self_address(start: *mut u8);
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_receive_self_address_creusot(start: *mut u8) {
      unsafe { get_receive_self_address(start) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn get_receive_self_address_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      start
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn get_receive_self_address_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      get_receive_self_address_creusot(temp.as_mut_ptr());
      coerce_rust_to_hacspec_public_byte_seq(&temp)
  }

#+end_src
Get receive self balance extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    /// Self-balance of the contract, returns the amount
    pub(crate) fn get_receive_self_balance() -> u64;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_receive_self_balance_creusot() -> u64 {
      unsafe { get_receive_self_balance() }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn get_receive_self_balance_hacspec() -> u64 {
      1u64
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn get_receive_self_balance_hacspec() -> u64 {
      get_receive_self_balance_creusot()
  }

#+end_src
Get receive sender extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    /// Immediate sender of the message (either contract or account).
    pub(crate) fn get_receive_sender(start: *mut u8);
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_receive_sender_creusot(start: *mut u8) {
      unsafe { get_receive_sender(start) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn get_receive_sender_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      start
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn get_receive_sender_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      get_receive_sender_creusot(temp.as_mut_ptr());
      coerce_rust_to_hacspec_public_byte_seq(&temp)
  }

#+end_src
Get receive owner extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    /// Owner of the contract, AccountAddress.
    pub(crate) fn get_receive_owner(start: *mut u8);
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_receive_owner_creusot(start: *mut u8) {
      unsafe { get_receive_owner(start) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn get_receive_owner_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      start
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn get_receive_owner_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      get_receive_owner_creusot(temp.as_mut_ptr());
      coerce_rust_to_hacspec_public_byte_seq(&temp)
  }

#+end_src
Log event extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Add a log item. Return values are
      // - -1 if logging failed due to the message being too long
      // - 0 if the log is already full
      // - 1 if data was successfully logged.
      pub(crate) fn log_event(start: *const u8, length: u32) -> i32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn log_event_creusot(start: *const u8, length: u32) -> i32 {
      unsafe { log_event(start, length) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn log_event_hacspec(start: PublicByteSeq) -> (PublicByteSeq, i32) {
      (start, 1i32)
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn log_event_hacspec(start: PublicByteSeq) -> (PublicByteSeq, i32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      let result = log_event_creusot(temp.as_ptr(), start.len() as u32);
      (coerce_rust_to_hacspec_public_byte_seq(&temp), result)
  }

#+end_src
Extern accept
#+begin_src rust :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn accept() -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn accept_creusot() -> u32 {
      unsafe { accept() }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn accept_hacspec() -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn accept_hacspec() -> u32 {
      accept_creusot()
  }
  
#+end_src
Extern simple transfer
#+begin_src rust :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Basic action to send tokens to an account.
    pub(crate) fn simple_transfer(addr_bytes: *const u8, amount: u64) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn simple_transfer_creusot(addr_bytes: *const u8, amount: u64) -> u32 {
      unsafe { simple_transfer(addr_bytes, amount) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn simple_transfer_hacspec(buf: PublicByteSeq, amount: u64) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn simple_transfer_hacspec(buf: PublicByteSeq, amount: u64) -> u32 {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      simple_transfer_creusot(temp.as_ptr(), amount)
  }

#+end_src
Extern send
#+begin_src rust :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Send a message to a smart contract.
    pub(crate) fn send(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: *const u8,
        receive_name_len: u32,
        amount: u64,
        parameter: *const u8,
        parameter_len: u32,
    ) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn send_creusot(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: *const u8,
        receive_name_len: u32,
        amount: u64,
        parameter: *const u8,
        parameter_len: u32,
    ) -> u32 {
      unsafe { send(addr_index, addr_subindex, receive_name, receive_name_len, amount, parameter, parameter_len) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn send_hacspec(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: PublicByteSeq,
        amount: u64,
        parameter: PublicByteSeq,
    ) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn send_hacspec(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: PublicByteSeq,
        amount: u64,
        parameter: PublicByteSeq,
    ) -> u32 {
      let temp_receive_name = &mut coerce_hacspec_to_rust_public_byte_seq(receive_name.clone())[..];
      let temp_parameter = &mut coerce_hacspec_to_rust_public_byte_seq(parameter.clone())[..];
      send_creusot(addr_index, addr_subindex, temp_receive_name.as_ptr(), receive_name.len() as u32, amount, temp_parameter.as_ptr(), parameter.len() as u32)
  }

#+end_src
Extern combine and
#+begin_src rust :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Combine two actions using normal sequencing. This is using the stack of
    // actions already produced.
    pub(crate) fn combine_and(l: u32, r: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn combine_and_creusot(l: u32, r: u32) -> u32 {
      unsafe { combine_and(l, r) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn combine_and_hacspec(l: u32, r: u32) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn combine_and_hacspec(l: u32, r: u32) -> u32 {
      combine_and_creusot(l,r)
  }

#+end_src
Extern combine or
#+begin_src rust :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Combine two actions using normal sequencing. This is using the stack of
    // actions already produced.
    pub(crate) fn combine_or(l: u32, r: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn combine_or_creusot(l: u32, r: u32) -> u32 {
      unsafe { combine_or(l, r) }
  }

  #[cfg(feature = "hacspec")]
  pub(crate) fn combine_or_hacspec(l: u32, r: u32) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  pub(crate) fn combine_or_hacspec(l: u32, r: u32) -> u32 {
      combine_or_creusot(l,r)
  }

#+end_src

* Concordium "Impls" specification
** Rust code
:PROPERTIES:
:header-args:  :tangle ../../examples/concordium/src/hacspec_concordium_impls.rs
:END:

*** Imports
#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  use crate::{
      collections::{BTreeMap, BTreeSet},
      convert::{self, TryFrom, TryInto},
      hash::Hash,
      num::NonZeroI32,
      vec::Vec,
      String,
      trap,
  };

  #[cfg(not(feature = "hacspec"))]
  use concordium_contracts_common::*;
#+END_SRC

#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  use crate::*;
  // #[cfg(not(feature = "hacspec"))]
  // use hacspec_concordium_traits::*;
  // #[cfg(not(feature = "hacspec"))]
  // use hacspec_concordium_types::*;
  // #[cfg(not(feature = "hacspec"))]
  // use hacspec_concordium_prims::*;
#+END_SRC

#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern crate hacspec_lib;

  use hacspec_lib::*;

  // #[cfg(feature = "hacspec_attributes")]
  #[cfg(feature = "hacspec")]
  use hacspec_attributes::*;

  // Creusot
  #[cfg(not(feature = "hacspec"))]
  extern crate creusot_contracts;
  #[cfg(not(feature = "hacspec"))]
  use creusot_contracts::{
      ensures,
      requires,
      trusted          
      };
#+END_SRC

*** Reject
We modle reject as the underlying data, that is the src_rust[:eval never]{i32} error code. The default constructor is i32 min.
#+begin_src rust :eval never
  pub type RejectHacspec = i32;

  pub fn reject_impl_deafult() -> RejectHacspec {
      i32::MIN
  }

#+end_src
We then implement the new operations for Reject.
#+begin_src rust :eval never
  pub fn new_reject_impl(x: i32) -> Option::<i32> { // Option<RejectHacspec>
      // TODO: fix 'identifier is not a constant' error (Seems to be fixed by some import?)
      if x < 0i32 {
          Option::<i32>::Some(x)
      } else {
          Option::<i32>::None
      }
  }

#+end_src
We define the coercion function for Reject, and implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_reject(hacspec_reject: RejectHacspec) -> Reject {
      Reject {
          error_code: unsafe { NonZeroI32::new_unchecked(hacspec_reject) },
      }
  }
#+end_src

**** Reject - From trait
#+begin_src rust :tangle no :eval never
  impl convert::From<()> for Reject {
      #[inline(always)]
      fn from(_: ()) -> Self {
          Reject {
              error_code: unsafe { NonZeroI32::new_unchecked(i32::MIN + 1) },
          }
      }
  }

  impl convert::From<ParseError> for Reject {
      #[inline(always)]
      fn from(_: ParseError) -> Self {
          Reject {
              error_code: unsafe { NonZeroI32::new_unchecked(i32::MIN + 2) },
          }
      }
  }
#+end_src

We modle the unsafe block with unchecked non zero as a precondition using requires giving us the hacspec equivalent
#+begin_src rust :eval never
  #[ensures(!(result === 0i32))] // !=
  pub fn reject_impl_convert_from_unit() -> RejectHacspec {
      i32::MIN + 1i32
  }

  #[ensures(!(result === 0i32))] // !=
  pub fn reject_impl_convert_from_parse_error() -> RejectHacspec {
      i32::MIN + 2i32
  }
#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl convert::From<()> for Reject {
      #[inline(always)]
      fn from(_: ()) -> Self {
          coerce_hacspec_to_rust_reject(reject_impl_convert_from_unit())
      }
  }

  #[cfg(not(feature = "hacspec"))]
  impl convert::From<ParseError> for Reject {
      #[inline(always)]
      fn from(_: ParseError) -> Self {
          coerce_hacspec_to_rust_reject(reject_impl_convert_from_parse_error())
      }
  }  
#+end_src
We define a log error type and function converting from it to the reject type
#+begin_src rust :eval never
  #[ensures(!(result === 0i32))] // !=
  pub fn reject_impl_from_log_error(le: LogError) -> RejectHacspec {
      match le {
          LogError::Full => i32::MIN + 3i32,
          LogError::Malformed => i32::MIN + 4i32,
      }
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Full is mapped to i32::MIN+3, Malformed is mapped to i32::MIN+4.
  impl From<LogError> for Reject {
      #[inline(always)]
      fn from(le: LogError) -> Self {
          coerce_hacspec_to_rust_reject(reject_impl_from_log_error(le))
      }
  }

#+end_src
We define a type for new contract name errors and conversion from it to reject
#+begin_src rust :eval never
  #[derive(Clone)] // , Debug, PartialEq, Eq
  pub enum NewContractNameError {
      NewContractNameErrorMissingInitPrefix,
      NewContractNameErrorTooLong,
      NewContractNameErrorContainsDot,
      NewContractNameErrorInvalidCharacters,
  }

  #[ensures(!(result === 0i32))] // !=
  pub fn reject_impl_from_new_contract_name_error(nre: NewContractNameError) -> RejectHacspec {
      match nre {
          NewContractNameError::NewContractNameErrorMissingInitPrefix => i32::MIN + 5i32,
          NewContractNameError::NewContractNameErrorTooLong => i32::MIN + 6i32,
          NewContractNameError::NewContractNameErrorContainsDot => i32::MIN + 9i32,
          NewContractNameError::NewContractNameErrorInvalidCharacters => i32::MIN + 10i32,
      }
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// MissingInitPrefix is mapped to i32::MIN + 5,
  /// TooLong to i32::MIN + 6,
  /// ContainsDot to i32::MIN + 9, and
  /// InvalidCharacters to i32::MIN + 10.
  impl From<NewContractNameError> for Reject {
      fn from(nre: NewContractNameError) -> Self {
          coerce_hacspec_to_rust_reject(reject_impl_from_new_contract_name_error(nre))
      }
  }

#+end_src
We define a type for new receive name errors and conversion from it to reject
#+begin_src rust :eval never
  #[derive(Clone)] // , Debug, PartialEq, Eq
  pub enum NewReceiveNameError {
      NewReceiveNameErrorMissingDotSeparator,
      NewReceiveNameErrorTooLong,
      NewReceiveNameErrorInvalidCharacters,
  }

  #[ensures(!(result === 0i32))] // !=
  pub fn reject_impl_from_new_receive_name_error(nre: NewReceiveNameError) -> RejectHacspec {
      match nre {
          NewReceiveNameError::NewReceiveNameErrorMissingDotSeparator => i32::MIN + 7i32,
          NewReceiveNameError::NewReceiveNameErrorTooLong => i32::MIN + 8i32,
          NewReceiveNameError::NewReceiveNameErrorInvalidCharacters => i32::MIN + 11i32,
      }
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// MissingDotSeparator is mapped to i32::MIN + 7,
  /// TooLong to i32::MIN + 8, and
  /// InvalidCharacters to i32::MIN + 11.
  impl From<NewReceiveNameError> for Reject {
      fn from(nre: NewReceiveNameError) -> Self {
          coerce_hacspec_to_rust_reject(reject_impl_from_new_receive_name_error(nre))
      }
  }

#+end_src

*** Contract state
We define contract state as its inner state namely the current position of the src_rust[:eval never]{u32} type.
#+begin_src rust :eval never
  pub type ContractStateHacspec = u32;
  
#+end_src
**** Contract State -- Seek
#+begin_src rust :eval never
  #[derive(Copy, Clone)] // , Debug, PartialEq, Eq
  pub enum SeekFromHacspec {
      /// Sets the offset to the provided number of bytes.
      Start(u64),

      /// Sets the offset to the size of this object plus the specified number of
      /// bytes.
      ///
      /// It is possible to seek beyond the end of an object, but it's an error to
      /// seek before byte 0.
      End(i64),

      /// Sets the offset to the current position plus the specified number of
      /// bytes.
      ///
      /// It is possible to seek beyond the end of an object, but it's an error to
      /// seek before byte 0.
      Current(i64),
  }

  pub type U32Option = Option<u32>;
  pub type I64Option = Option<i64>;

  // #[requires(forall<delta : i64> pos === SeekFrom::End(delta) ==> exists<b : u32> current_position.checked_add(delta as u32) == U32Option::Some(b))]
  pub fn contract_state_impl_seek(current_position: ContractStateHacspec, pos: SeekFromHacspec) -> Result<(ContractStateHacspec, u64), ()> {
      match pos {
          SeekFromHacspec::Start(offset) => Result::<(ContractStateHacspec, u64), ()>::Ok((offset as u32, offset)),
          SeekFromHacspec::End(delta) => {
              if delta >= 0_i64 {
                  match current_position.checked_add(delta as u32) {
                      U32Option::Some(b) => Result::<(ContractStateHacspec, u64), ()>::Ok((b, delta as u64)),
                      U32Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
                  }
              } else {
                  match delta.checked_abs() {
                      I64Option::Some(b) =>
                      {
                          Result::<(ContractStateHacspec, u64), ()>::Ok(((4_u32 - (b as u32)), (4_u32 - (b as u32)) as u64))
                      }
                      I64Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
                  }
              }
          }
          SeekFromHacspec::Current(delta) => {
              if delta >= 0_i64 {
                  match current_position.checked_add(delta as u32) {
                      U32Option::Some(offset) => Result::<(ContractStateHacspec, u64), ()>::Ok((offset, offset as u64)),
                      U32Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
                  }
              } else {
                  match delta.checked_abs() {
                      I64Option::Some(b) => match current_position.checked_sub(b as u32) {
                          U32Option::Some(offset) => Result::<(ContractStateHacspec, u64), ()>::Ok((offset, offset as u64)),
                          U32Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
                      },
                      I64Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
                  }
              }
          }
      }
  }
#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_contract_state(
      rust_contract_state: &mut ContractState,
  ) -> ContractStateHacspec {
      rust_contract_state.current_position.clone()
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_contract_state(
      rust_contract_state: &mut ContractState,
      hacspec_contract_state: ContractStateHacspec,
  ) {
      rust_contract_state.current_position = hacspec_contract_state;
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_seek_result(
      rust_contract_state: &mut ContractState,
      hacspec_seek_result: Result<(ContractStateHacspec, u64), ()>,
  ) -> Result<u64, ()> {
      let (hacspec_result, rust_result) = hacspec_seek_result?;
      coerce_hacspec_to_rust_contract_state(rust_contract_state, hacspec_result);
      Ok(rust_result)
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_seek_from(rust_seek_from: SeekFrom) -> SeekFromHacspec {
      match rust_seek_from {
          SeekFrom::Start(v) => SeekFromHacspec::Start(v),
          SeekFrom::End(v) => SeekFromHacspec::End(v),
          SeekFrom::Current(v) => SeekFromHacspec::Current(v),
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// # Contract state trait implementations.
  impl Seek for ContractState {
      type Err = ();

      fn seek(&mut self, pos: SeekFrom) -> Result<u64, Self::Err> {
          let contract_state = coerce_rust_to_hacspec_contract_state(self);
          coerce_hacspec_to_rust_seek_result(
              self,
              contract_state_impl_seek(
                  contract_state,
                  coerce_rust_to_hacspec_seek_from(pos),
              ),
          )
      }
  }
#+end_src

**** Contract State -- Load
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_public_byte_seq(buf: &[u8]) -> PublicByteSeq {
      PublicByteSeq::from_native_slice(buf)
  }

  // TODO: Make creusot friendly version
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_public_byte_seq(buf: PublicByteSeq) -> Vec<u8> {
      // buf.native_slice().iter().collect();
      let mut temp_vec: Vec<u8> = Vec::new();
      for i in 0..buf.len() {
          temp_vec.push(buf.index(i).clone())
      }
      temp_vec
  }

#+end_src


**** Contract State -- Read
#+begin_src rust :eval never
  pub fn contract_state_impl_read_read(
      current_position: ContractStateHacspec,
      buf : PublicByteSeq,
  ) -> (ContractStateHacspec, usize) {
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, num_read as usize)
  }

  /// Read a u32 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u64(
      current_position: ContractStateHacspec,
  ) -> (ContractStateHacspec, u64) {
      // let mut bytes: MaybeUninit<[u8; 8]> = MaybeUninit::uninit();
      let buf = PublicByteSeq::new(8);
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, u64_from_le_bytes(u64Word::from_seq(&buf))) // num_read as u64
  }

  /// Read a u32 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u32(
      current_position: ContractStateHacspec,
  ) -> (ContractStateHacspec, u32) {
      // let mut bytes: MaybeUninit<[u8; 4]> = MaybeUninit::uninit();
      let buf = PublicByteSeq::new(4);
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, u32_from_le_bytes(u32Word::from_seq(&buf))) // num_read as u64
  }

  /// Read a u8 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u8(
      current_position: ContractStateHacspec,
  ) -> (ContractStateHacspec, u8) {
      let buf = PublicByteSeq::new(1);
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, buf[0]) // num_read as u64
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl Read for ContractState {
      fn read(&mut self, buf: &mut [u8]) -> ParseResult<usize> {
          let (cs, nr) = contract_state_impl_read_read(
              coerce_rust_to_hacspec_contract_state(self),
              coerce_rust_to_hacspec_public_byte_seq(buf),
          );
          coerce_hacspec_to_rust_contract_state(self, cs);
          Ok(nr)
      }

      // TODO: !! Probably incorrect !!
      /// Read a `u32` in little-endian format. This is optimized to not
      /// initialize a dummy value before calling an external function.
      fn read_u64(&mut self) -> ParseResult<u64> {
          let (cs, nr) =
              contract_state_impl_read_read_u64(coerce_rust_to_hacspec_contract_state(self));
          coerce_hacspec_to_rust_contract_state(self, cs);
          Ok(nr)
          // if num_read == 8 {
          //     unsafe { Ok(u64::from_le_bytes(bytes.assume_init())) }
          // } else {
          //     Err(ParseError::default())
          // }
      }

      /// Read a `u32` in little-endian format. This is optimized to not
      /// initialize a dummy value before calling an external function.
      fn read_u32(&mut self) -> ParseResult<u32> {
          let (cs, nr) =
              contract_state_impl_read_read_u32(coerce_rust_to_hacspec_contract_state(self));
          coerce_hacspec_to_rust_contract_state(self, cs);
          Ok(nr)

          // let mut bytes: MaybeUninit<[u8; 4]> = MaybeUninit::uninit();
          // let num_read =
          //     unsafe { load_state(bytes.as_mut_ptr() as *mut u8, 4, self.current_position) };
          // self.current_position += num_read;
          // if num_read == 4 {
          //     unsafe { Ok(u32::from_le_bytes(bytes.assume_init())) }
          // } else {
          //     Err(ParseError::default())
          // }
      }

      /// Read a `u8` in little-endian format. This is optimized to not
      /// initialize a dummy value before calling an external function.
      fn read_u8(&mut self) -> ParseResult<u8> {
          let (cs, nr) =
              contract_state_impl_read_read_u8(coerce_rust_to_hacspec_contract_state(self));
          coerce_hacspec_to_rust_contract_state(self, cs);
          Ok(nr)
      }
  }
#+end_src

**** Contract State -- Write
#+begin_src rust :eval never
  pub fn contract_state_impl_write(
      current_position: ContractStateHacspec,
      buf : PublicByteSeq
  ) -> Result<(ContractStateHacspec, usize), ()> {
      if current_position.checked_add(buf.len() as u32).is_none() {
          Result::<(ContractStateHacspec, usize), ()>::Err(())?;
      }
      let (buf, num_bytes) = write_state_hacspec(buf, current_position);
      Result::<(ContractStateHacspec, usize), ()>::Ok((current_position + num_bytes, num_bytes as usize))
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl Write for ContractState {
      type Err = ();

      fn write(&mut self, buf: &[u8]) -> Result<usize, Self::Err> {
          let (cs, nr) = contract_state_impl_write(
              coerce_rust_to_hacspec_contract_state(self),
              coerce_rust_to_hacspec_public_byte_seq(buf),
          )?;
          coerce_hacspec_to_rust_contract_state(self, cs);
          Ok(nr)
      }
  }
#+end_src

**** Contract State -- Misc.

#+begin_src rust :eval never
  pub fn has_contract_state_impl_for_contract_state_open() -> ContractStateHacspec {
      0_u32
  }

  // pub fn has_contract_state_impl_for_contract_state_reserve_0(len: u32, cur_size: u32) -> bool {
  //     cur_size < len
  // }

  // pub fn has_contract_state_impl_for_contract_state_reserve_1(res: u32) -> bool {
  //     res == 1_u32
  // }

  pub fn has_contract_state_impl_for_contract_state_reserve(
      contract_state: ContractStateHacspec,
      len: u32,
  ) -> bool {
      let cur_size = state_size_hacspec();
      if cur_size < len {
          resize_state_hacspec(len) == 1_u32
      } else {
          true
      }
  }

  pub fn has_contract_state_impl_for_contract_state_truncate(
      current_position : ContractStateHacspec,
      cur_size: u32,
      new_size: u32,
  ) -> ContractStateHacspec {
      if cur_size > new_size {
          resize_state_hacspec(new_size);
      }
      if new_size < current_position {
          new_size
      }
      else {
          current_position
      }
  }
#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl HasContractState<()> for ContractState {
      type ContractStateData = ();

      #[inline(always)]
      fn open(_: Self::ContractStateData) -> Self {
          ContractState {
              current_position: has_contract_state_impl_for_contract_state_open(),
          }
      }

      fn reserve(&mut self, len: u32) -> bool {
          has_contract_state_impl_for_contract_state_reserve(
              coerce_rust_to_hacspec_contract_state(self),
              len,
          )
      }

      #[inline(always)]
      fn size(&self) -> u32 {
          state_size_hacspec()
      }

      fn truncate(&mut self, new_size: u32) {
          let current_position = coerce_rust_to_hacspec_contract_state(self);
          coerce_hacspec_to_rust_contract_state(
              self,
              has_contract_state_impl_for_contract_state_truncate(
                  current_position,
                  self.size(),
                  new_size,
              ),
          )
      }
  }
  
#+end_src

*** Parameter
We define parameter
#+begin_src rust :eval never
  pub type ParameterHacspec = u32;

  pub fn read_impl_for_parameter_read(
      current_position: ParameterHacspec,
      buf: PublicByteSeq,
  ) -> (ParameterHacspec, usize) {
      let (buf, num_read) = get_parameter_section_hacspec(buf, current_position);
      (current_position + num_read, num_read as usize)
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_parameter(
      rust_parameter: &mut Parameter,
  ) -> ParameterHacspec {
      rust_parameter.current_position.clone()
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_parameter(
      rust_parameter: &mut Parameter,
      hacspec_parameter: ParameterHacspec,
  ) {
      rust_parameter.current_position = hacspec_parameter;
  }

  
  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for Parameter
  impl Read for Parameter {
      fn read(&mut self, buf: &mut [u8]) -> ParseResult<usize> {
          let (cs, nr) = read_impl_for_parameter_read(
              coerce_rust_to_hacspec_parameter(self),
              coerce_rust_to_hacspec_public_byte_seq(buf),
          );
          coerce_hacspec_to_rust_parameter(self, cs);
          Ok(nr)
      }
  }

#+end_src
*** ChainMetaExtern
We define and implement traits for ~ChainMetaExtern~.
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for the chain metadata.
  impl HasChainMetadata for ChainMetaExtern {
      #[inline(always)]
      fn slot_time(&self) -> SlotTime {
          Timestamp::from_timestamp_millis(get_slot_time_hacspec() )
      }
  }
#+end_src

*** AttributesCursor

#+begin_src rust :eval never
  // pub struct AttributeTag(pub u8);
  pub type AttributesCursorHacspec = (u32, u16);

  // pub fn has_policy_impl_for_policy_attributes_cursor_next_test(
  //     policy_attribute_items: AttributesCursorHacspec,
  // ) -> bool {
  //     let (_, remaining_items) = policy_attribute_items;
  //     remaining_items == 0_u16
  // }

  // pub fn has_policy_impl_for_policy_attributes_cursor_next_tag_invalid(
  //     policy_attribute_items: AttributesCursorHacspec,
  //     tag_value_len_1: u8,
  //     num_read: u32,
  // ) -> (AttributesCursorHacspec, bool) {
  //     let (current_position, remaining_items) = policy_attribute_items;
  //     let policy_attribute_items = (current_position + num_read, remaining_items);
  //     (policy_attribute_items, tag_value_len_1 > 31_u8)
  // }

  pub fn has_policy_impl_for_policy_attributes_cursor_next_item(
      policy_attribute_items: AttributesCursorHacspec,
      buf: PublicByteSeq,
  ) -> Option<(AttributesCursorHacspec, (u8, u8))> {

      let (mut current_position, mut remaining_items) = policy_attribute_items;

      if remaining_items == 0u16 {
          Option::<(AttributesCursorHacspec, (u8, u8))>::None?;
      }

      let (tag_value_len, num_read) = get_policy_section_hacspec(PublicByteSeq::new(2), current_position);
      current_position = current_position + num_read;

      if tag_value_len[1] > 31u8 {
          // Should not happen because all attributes fit into 31 bytes.
          Option::<(AttributesCursorHacspec, (u8, u8))>::None?;
      }

      let (buf, num_read) = get_policy_section_hacspec(buf, current_position);
      current_position = current_position + num_read;
      remaining_items = remaining_items - 1u16;
      Option::<(AttributesCursorHacspec, (u8, u8))>::Some(((current_position, remaining_items), (tag_value_len[0], tag_value_len[1])))
  }

#+end_src
We then define traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_attributes_cursor(
      rust_attributes_cursor: &mut AttributesCursor,
  ) -> AttributesCursorHacspec {
      (
          rust_attributes_cursor.current_position.clone(),
          rust_attributes_cursor.remaining_items.clone(),
      )
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_attributes_cursor(
      rust_attributes_cursor: &mut AttributesCursor,
      hacspec_attributes_cursor: AttributesCursorHacspec,
  ) {
      let (current_position, remaining_items) = hacspec_attributes_cursor;
      rust_attributes_cursor.current_position = current_position;
      rust_attributes_cursor.remaining_items = remaining_items;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Policy on the credential of the account.
  ///
  /// This is one of the key features of the Concordium blockchain. Each account
  /// on the chain is backed by an identity. The policy is verified and signed by
  /// the identity provider before an account can be created on the chain.
  ///
  /// The type is parameterized by the choice of `Attributes`. These are either
  /// borrowed or owned, in the form of an iterator over key-value pairs or a
  /// vector of such. This flexibility is needed so that attributes can be
  /// accessed efficiently, as well as constructed conveniently for testing.
  #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
  #[derive(Clone)] // TODO: Creusot issue readd "Debug" attribute
  pub struct Policy<Attributes> {
      /// Identity of the identity provider who signed the identity object that
      /// this policy is derived from.
      pub identity_provider: IdentityProvider,
      /// Timestamp at the beginning of the month when the identity object backing
      /// this policy was created. This timestamp has very coarse granularity
      /// in order for the identity provider to not be able to link identities
      /// they have created with accounts that users created on the chain.
      /// as a timestamp (which has millisecond granularity) in order to make it
      /// easier to compare with, e.g., `slot_time`.
      pub created_at: Timestamp,
      /// Beginning of the month where the identity is __no longer valid__.
      pub valid_to: Timestamp,
      /// List of attributes, in ascending order of the tag.
      pub items: Attributes,
  }

  // TODO: Creusot issues?
  #[cfg(not(feature = "hacspec"))]
  impl HasPolicy for Policy<AttributesCursor> {
      fn identity_provider(&self) -> IdentityProvider {
          self.identity_provider
      }

      fn created_at(&self) -> Timestamp {
          self.created_at
      }

      fn valid_to(&self) -> Timestamp {
          self.valid_to
      }

      fn next_item(&mut self, buf: &mut [u8; 31]) -> Option<(AttributeTag, u8)> {
          let (ac, (at, v)) = has_policy_impl_for_policy_attributes_cursor_next_item(
              coerce_rust_to_hacspec_attributes_cursor(&mut self.items),
              coerce_rust_to_hacspec_public_byte_seq(&mut buf[..]),
          )?;
          coerce_hacspec_to_rust_attributes_cursor(&mut self.items, ac);
          Some((AttributeTag(at), v))
      }
  }
#+end_src

*** Policy iterator
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// An iterator over policies using host functions to supply the data.
  /// The main interface to using this type is via the methods of the [Iterator](https://doc.rust-lang.org/std/iter/trait.Iterator.html)
  /// and [ExactSizeIterator](https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html) traits.
  pub struct PoliciesIterator {
      /// Position in the policies binary serialization.
      pos: u32,
      /// Number of remaining items in the stream.
      remaining_items: u16,
  }

  pub type PoliciesIteratorHacspec = (u32, u16);

  // TODO: use PolicyAttributesCursorHacspec for implementation above instead of just AttributesCursorHacspec
  pub type PolicyAttributesCursorHacspec = (u32, u64, u64, AttributesCursorHacspec); // IdentityProvider, Timestamp, Timestamp, AttributesCursor

  // TODO: Fix creusot issues?
  fn iterator_impl_for_policies_iterator_next(
      policies_iterator: PoliciesIteratorHacspec,
  ) -> Option<(PoliciesIteratorHacspec, PolicyAttributesCursorHacspec)> {
      let (mut pos, remaining_items) = policies_iterator;
      if remaining_items == 0u16 {
          Option::<(PoliciesIteratorHacspec, PolicyAttributesCursorHacspec)>::None?;
      }

      // 2 for total size of this section, 4 for identity_provider,
      // 8 bytes for created_at, 8 for valid_to, and 2 for
      // the length
      let (buf, _) = get_policy_section_hacspec(PublicByteSeq::new(2 + 4 + 8 + 8 + 2), pos);
      let skip_part: PublicByteSeq = buf.slice_range(0..2);
      let ip_part: PublicByteSeq = buf.slice_range(2..2 + 4);
      let created_at_part: PublicByteSeq = buf.slice_range(2 + 4..2 + 4 + 8);
      let valid_to_part: PublicByteSeq = buf.slice_range(2 + 4 + 8..2 + 4 + 8 + 8);
      let len_part: PublicByteSeq = buf.slice_range(2 + 4 + 8 + 8..2 + 4 + 8 + 8 + 2);
      let identity_provider = u32_from_le_bytes(u32Word::from_seq(&ip_part)); // IdentityProvider = u32 // UnsignedPublicInteger
      let created_at = u64_from_le_bytes(u64Word::from_seq(&created_at_part)); // Timestamp = Timestamp::from_timestamp_millis(u64)
      let valid_to = u64_from_le_bytes(u64Word::from_seq(&valid_to_part)); // Timestamp = u64)
      let mut remaining_items = u16_from_le_bytes(u16Word::from_seq(&len_part));
      let attributes_start = pos + 2u32 + 4u32 + 8u32 + 8u32 + 2u32;
      pos = pos + (u16_from_le_bytes(u16Word::from_seq(&skip_part)) as u32) + 2u32;
      remaining_items = remaining_items - 1u16;
      Option::<(PoliciesIteratorHacspec, PolicyAttributesCursorHacspec)>::Some((
          (pos, remaining_items),
          (
              identity_provider,
              created_at,
              valid_to,
              (attributes_start, remaining_items),
          ),
      ))
  }

  // TODO: Fix creusot issues?
  #[cfg(not(feature = "hacspec"))]
  impl Iterator for PoliciesIterator {
      type Item = Policy<AttributesCursor>;

      fn next(&mut self) -> Option<Self::Item> {
          let ((pos, remaining_items), (identity_provider, created_at, valid_to, (cp, ri))) =
              iterator_impl_for_policies_iterator_next((self.pos, self.remaining_items))?;

          // TODO: make into coerce function
          self.pos = pos;
          self.remaining_items = remaining_items;

          Some(Policy {
              identity_provider,
              created_at: Timestamp::from_timestamp_millis(created_at),
              valid_to: Timestamp::from_timestamp_millis(valid_to),
              items: AttributesCursor {
                  current_position: cp,
                  remaining_items: ri,
              },
          })
      }

      fn size_hint(&self) -> (usize, Option<usize>) {
          let rem = self.remaining_items as usize;
          (rem, Some(rem))
      }
  }

  #[cfg(not(feature = "hacspec"))]
  impl ExactSizeIterator for PoliciesIterator {
      #[inline(always)]
      fn len(&self) -> usize {
          self.remaining_items.into() // as usize
      }
  }
#+end_src

*** External context
#+begin_src rust :eval never

  #[cfg(not(feature = "hacspec"))]
  impl<T: sealed::ContextType> HasCommonData for ExternContext<T> {
      type MetadataType = ChainMetaExtern;
      type ParamType = Parameter;
      type PolicyIteratorType = PoliciesIterator;
      type PolicyType = Policy<AttributesCursor>;

      // TODO: fix creusot issue
      #[inline(always)]
      fn metadata(&self) -> &Self::MetadataType {
          &ChainMetaExtern {}
      }

      fn policies(&self) -> PoliciesIterator {
          let (buf, _) = get_policy_section_hacspec(PublicByteSeq::new(2), 0);
          PoliciesIterator {
              pos: 2, // 2 because we already read 2 bytes.
              remaining_items: u16_from_le_bytes(u16Word::from_seq(&buf)),
          }
      }

      #[inline(always)]
      fn parameter_cursor(&self) -> Self::ParamType {
          Parameter {
              current_position: 0,
          }
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for the init context
  impl HasInitContext for ExternContext<InitContextExtern> {
      type InitData = ();

      /// Create a new init context by using an external call.
      fn open(_: Self::InitData) -> Self {
          ExternContext::default()
      }

      #[inline(always)]
      fn init_origin(&self) -> AccountAddress {
          let mut address : [u8; ACCOUNT_ADDRESS_SIZE] = Default::default();
          let temp = coerce_hacspec_to_rust_public_byte_seq(get_init_origin_hacspec(
              PublicByteSeq::new(ACCOUNT_ADDRESS_SIZE),
          ));
          address.clone_from_slice(temp.as_slice());
          AccountAddress(address)
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for the receive context
  impl HasReceiveContext for ExternContext<ReceiveContextExtern> {
      type ReceiveData = ();

      /// Create a new receive context
      fn open(_: Self::ReceiveData) -> Self {
          ExternContext::default()
      }

      // TODO: Make usable by creusot
      #[inline(always)]
      fn invoker(&self) -> AccountAddress {
          let mut address: [u8; ACCOUNT_ADDRESS_SIZE] = Default::default();
          address.clone_from_slice(
              &mut coerce_hacspec_to_rust_public_byte_seq(get_receive_invoker_hacspec(
                  PublicByteSeq::new(ACCOUNT_ADDRESS_SIZE),
              ))[..],
          );
          AccountAddress(address)
      }

      // TODO: Make usable by creusot
      #[inline(always)]
      fn self_address(&self) -> ContractAddress {
          let mut address: [u8; ACCOUNT_ADDRESS_SIZE] = Default::default();
          address.clone_from_slice(
              &mut coerce_hacspec_to_rust_public_byte_seq(get_receive_self_address_hacspec(
                  PublicByteSeq::new(ACCOUNT_ADDRESS_SIZE),
              ))[..],
          );
          match concordium_contracts_common::from_bytes(&address) {
              Ok(v) => v,
              Err(_) => trap(),
          }
      }

      #[inline(always)]
      fn self_balance(&self) -> Amount {
          Amount::from_micro_gtu(get_receive_self_balance_hacspec())
      }

      // TODO: Make usable by creusot
      // TODO: Remove/replace unsafe code !
      #[inline(always)]
      fn sender(&self) -> Address {
          let ptr : *mut u8 = (&mut coerce_hacspec_to_rust_public_byte_seq(get_receive_sender_hacspec(
              PublicByteSeq::new(ACCOUNT_ADDRESS_SIZE),
          ))[..]).as_mut_ptr();
          let tag = unsafe { *ptr };
          match tag {
              0u8 => {
                  match concordium_contracts_common::from_bytes(unsafe { core::slice::from_raw_parts(
                      ptr.add(1),
                      ACCOUNT_ADDRESS_SIZE,
                  )} ) {
                      Ok(v) => Address::Account(v),
                      Err(_) => trap(),
                  }
              }
              1u8 => match concordium_contracts_common::from_bytes(unsafe { core::slice::from_raw_parts(ptr.add(1), 16) }) {
                  Ok(v) => Address::Contract(v),
                  Err(_) => trap(),
              },
              _ => trap(), // unreachable!("Host violated precondition."),
          }
      }

      // TODO: Make usable by creusot
      #[inline(always)]
      fn owner(&self) -> AccountAddress {
          let mut address: [u8; ACCOUNT_ADDRESS_SIZE] = Default::default();
          address.clone_from_slice(
              &mut coerce_hacspec_to_rust_public_byte_seq(get_receive_self_address_hacspec(
                  PublicByteSeq::new(ACCOUNT_ADDRESS_SIZE),
              ))[..],
          );
          AccountAddress(address)
      }
  }
#+end_src

*** Logger

#+begin_src rust :eval never
  // #[cfg(not(feature = "hacspec"))]
  // /// A type representing the logger.
  // #[derive(Default)]
  // pub struct Logger {
  //     pub(crate) _private: (),
  // }

  #[cfg(not(feature = "hacspec"))]
  /// #Implementations of the logger.
  impl HasLogger for Logger {
      #[inline(always)]
      fn init() -> Self {
          Self { _private: () }
      }

      fn log_raw(&mut self, event: &[u8]) -> Result<(), LogError> {
          let (_, res) = log_event_hacspec(coerce_rust_to_hacspec_public_byte_seq(event));
          match res {
              1 => Ok(()),
              0 => Err(LogError::Full),
              _ => Err(LogError::Malformed),
          }
      }
  }
#+end_src
*** Action
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// #Implementation of actions.
  /// These actions are implemented by direct calls to host functions.
  impl HasActions for Action {
      #[inline(always)]
      fn accept() -> Self {
          Action {
              _private: accept_hacspec(),
          }
      }

      #[inline(always)]
      fn simple_transfer(acc: &AccountAddress, amount: Amount) -> Self {
          let res = simple_transfer_hacspec(coerce_rust_to_hacspec_public_byte_seq(&acc.0), amount.micro_gtu);
          Action { _private: res }
      }

      #[inline(always)]
      fn send_raw(
          ca: &ContractAddress,
          receive_name: ReceiveName,
          amount: Amount,
          parameter: &[u8],
      ) -> Self {
          let receive_bytes = receive_name.get_chain_name().as_bytes();
          let res = 
              send_hacspec(
                  ca.index,
                  ca.subindex,
                  coerce_rust_to_hacspec_public_byte_seq(&receive_bytes),
                  amount.micro_gtu,
                  coerce_rust_to_hacspec_public_byte_seq(&parameter),
              );
          Action { _private: res }
      }

      #[inline(always)]
      fn and_then(self, then: Self) -> Self {
          let res = combine_and_hacspec(self._private, then._private);
          Action { _private: res }
      }

      #[inline(always)]
      fn or_else(self, el: Self) -> Self {
          let res = combine_or_hacspec(self._private, el._private);
          Action { _private: res }
      }
  }

#+end_src

*** Remaining todo
# TODO: Get functionlity of everything into hacspec
#+begin_src rust :eval never
  // TODO: Define functionality in hacspec instead!
  #[cfg(not(feature = "hacspec"))]
  /// Allocates a Vec of bytes prepended with its length as a `u32` into memory,
  /// and prevents them from being dropped. Returns the pointer.
  /// Used to pass bytes from a Wasm module to its host.
  #[doc(hidden)]
  pub fn put_in_memory(input: &[u8]) -> *mut u8 {
      let bytes_length = input.len() as u32;
      let mut bytes = concordium_contracts_common::to_bytes(&bytes_length);
      bytes.extend_from_slice(input);
      let ptr = bytes.as_mut_ptr();
      #[cfg(feature = "std")]
      ::std::mem::forget(bytes);
      #[cfg(not(feature = "std"))]
      core::mem::forget(bytes);
      ptr
  }

#+end_src

#+begin_src rust :eval never
  // TODO: Name collision
  #[cfg(not(feature = "hacspec"))]
  /// Wrapper for
  /// [HasActions::send_raw](./trait.HasActions.html#tymethod.send_raw), which
  /// automatically serializes the parameter. Note that if the parameter is
  /// already a byte array or convertible to a byte array without allocations it
  /// is preferrable to use [send_raw](./trait.HasActions.html#tymethod.send_raw).
  /// It is more efficient and avoids memory allocations.
  pub fn send<A: HasActions, P: Serial>(
      ca: &ContractAddress,
      receive_name: ReceiveName,
      amount: Amount,
      parameter: &P,
  ) -> A {
      let param_bytes = concordium_contracts_common::to_bytes(parameter);
      A::send_raw(ca, receive_name, amount, &param_bytes)
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl<A, E> UnwrapAbort for Result<A, E> {
      type Unwrap = A;

      #[inline]
      fn unwrap_abort(self) -> Self::Unwrap {
          match self {
              Ok(x) => x,
              Err(_) => trap(),
          }
      }
  }
  
#+end_src

#+begin_src rust :eval never
  // TODO:
  // #[cfg(not(feature = "hacspec"))]
  // #[cfg(not(feature = "std"))]
  // use concordium_contracts_common::fmt; // core::fmt;

  #[cfg(not(feature = "hacspec"))]
  #[cfg(feature = "std")]
  use std::fmt;

  #[cfg(not(feature = "hacspec"))]
  impl<A, E: fmt::Debug> ExpectReport for Result<A, E> {
      type Unwrap = A;

      fn expect_report(self, msg: &str) -> Self::Unwrap {
          match self {
              Ok(x) => x,
              Err(e) => fail!("{}: {:?}", msg, e),
          }
      }
  }

#+end_src

#+begin_src rust :eval never
  // TODO:
  #[cfg(not(feature = "hacspec"))]
  impl<A: fmt::Debug, E> ExpectErrReport for Result<A, E> {
      type Unwrap = E;

      fn expect_err_report(self, msg: &str) -> Self::Unwrap {
          match self {
              Ok(a) => fail!("{}: {:?}", msg, a),
              Err(e) => e,
          }
      }
  }

#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl<A> UnwrapAbort for Option<A> {
      type Unwrap = A;

      #[inline(always)]
      fn unwrap_abort(self) -> Self::Unwrap {
          self.unwrap_or_else(|| trap())
      }
  }

#+end_src

#+begin_src rust :eval never
  // TODO:
  #[cfg(not(feature = "hacspec"))]
  impl<A> ExpectReport for Option<A> {
      type Unwrap = A;

      fn expect_report(self, msg: &str) -> Self::Unwrap {
          match self {
              Some(v) => v,
              None => fail!("{}", msg),
          }
      }
  }

#+end_src

#+begin_src rust :eval never
  // TODO:
  #[cfg(not(feature = "hacspec"))]
  impl<A: fmt::Debug> ExpectNoneReport for Option<A> {
      fn expect_none_report(self, msg: &str) {
          if let Some(x) = self {
              fail!("{}: {:?}", msg, x)
          }
      }
  }

#+end_src

#+begin_src rust :eval never

  #[cfg(not(feature = "hacspec"))]
  /// Write a [BTreeSet](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) as an ascending list of keys, without the length information.
  pub fn serial_set_no_length<W: Write, K: Serial>(
      map: &BTreeSet<K>,
      out: &mut W,
  ) -> Result<(), W::Err> {
      for k in map.iter() {
          k.serial(out)?;
      }
      Ok(())
  }

  #[cfg(not(feature = "hacspec"))]
  impl<K: Serial + Ord> SerialCtx for BTreeSet<K> {
      fn serial_ctx<W: Write>(
          &self,
          size_len: concordium_contracts_common::schema::SizeLength,
          out: &mut W,
      ) -> Result<(), W::Err> {
          concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
          // concordium_std::
          serial_set_no_length(self, out)
      }
  }

#+end_src

#+begin_src rust :eval never

  #[cfg(not(feature = "hacspec"))]
  /// Read a [BTreeSet](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) as a list of keys, given some length.
  /// NB: This ensures there are no duplicates, hence the specialized type.
  /// Moreover this will only succeed if keys are listed in order.
  pub fn deserial_set_no_length<R: Read, K: Deserial + Ord + Copy>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<BTreeSet<K>> {
      let mut out = BTreeSet::new();
      let mut prev = None;
      for _ in 0..len {
          let key = source.get()?;
          let next = Some(key);
          if next <= prev {
              return Err(ParseError::default());
          }
          out.insert(key);
          prev = next;
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]
  /// Read a [BTreeSet](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) as an list of key-value pairs given some length.
  /// Slightly faster version of `deserial_set_no_length` as it is skipping the
  /// order checking. The only check that is made to the set is that there are no
  /// duplicates.
  pub fn deserial_set_no_length_no_order_check<R: Read, K: Deserial + Ord>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<BTreeSet<K>> {
      let mut out = BTreeSet::new();
      for _ in 0..len {
          let key = source.get()?;
          if !out.insert(key) {
              return Err(ParseError::default());
          }
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]
  impl<K: Deserial + Ord + Copy> DeserialCtx for BTreeSet<K> {
      fn deserial_ctx<R: Read>(
          size_len: concordium_contracts_common::schema::SizeLength,
          ensure_ordered: bool,
          source: &mut R,
      ) -> ParseResult<Self> {
          let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
          if ensure_ordered {
              // concordium_std::
              deserial_set_no_length(source, len)
          } else {
              // concordium_std::
              deserial_set_no_length_no_order_check(source, len)
          }
      }
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Write a Map as a list of key-value pairs ordered by the key, without the
  /// length information.
  pub fn serial_map_no_length<W: Write, K: Serial, V: Serial>(
      map: &BTreeMap<K, V>,
      out: &mut W,
  ) -> Result<(), W::Err> {
      for (k, v) in map.iter() {
          k.serial(out)?;
          v.serial(out)?;
      }
      Ok(())
  }

  #[cfg(not(feature = "hacspec"))]
  impl<K: Serial + Ord, V: Serial> SerialCtx for BTreeMap<K, V> {
      fn serial_ctx<W: Write>(
          &self,
          size_len: concordium_contracts_common::schema::SizeLength,
          out: &mut W,
      ) -> Result<(), W::Err> {
          concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
          // concordium_std::
          serial_map_no_length(self, out)
      }
  }
  
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Read a [BTreeMap](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) as a list of key-value pairs given some length.
  /// NB: This ensures there are no duplicates, hence the specialized type.
  /// Moreover this will only succeed if keys are listed in order.
  pub fn deserial_map_no_length<R: Read, K: Deserial + Ord + Copy, V: Deserial>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<BTreeMap<K, V>> {
      let mut out = BTreeMap::new();
      let mut x = None;
      for _ in 0..len {
          let k = source.get()?;
          let v = source.get()?;
          match x {
              None => {
                  out.insert(k, v);
              }
              Some(kk) => {
                  if k > kk {
                      out.insert(k, v);
                  } else {
                      return Err(ParseError::default());
                  }
              }
          }
          x = Some(k);
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]  
  /// Read a [BTreeMap](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) as a list of key-value pairs given some length.
  /// Slightly faster version of `deserial_map_no_length` as it is skipping the
  /// order checking
  pub fn deserial_map_no_length_no_order_check<R: Read, K: Deserial + Ord, V: Deserial>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<BTreeMap<K, V>> {
      let mut out = BTreeMap::new();
      for _ in 0..len {
          let k = source.get()?;
          let v = source.get()?;
          if out.insert(k, v).is_some() {
              return Err(ParseError::default());
          }
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]  
  impl<K: Deserial + Ord + Copy, V: Deserial> DeserialCtx for BTreeMap<K, V> {
      fn deserial_ctx<R: Read>(
          size_len: concordium_contracts_common::schema::SizeLength,
          ensure_ordered: bool,
          source: &mut R,
      ) -> ParseResult<Self> {
          let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
          if ensure_ordered {
              // concordium_std::
              deserial_map_no_length(source, len)
          } else {
              // concordium_std::
              deserial_map_no_length_no_order_check(source, len)
          }
      }
  }
  
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Write a [HashSet](https://doc.rust-lang.org/std/collections/struct.HashSet.html) as a list of keys in no particular order, without the length information.
  pub fn serial_hashset_no_length<W: Write, K: Serial>(
      map: &HashSet<K>,
      out: &mut W,
  ) -> Result<(), W::Err> {
      for k in map.iter() {
          k.serial(out)?;
      }
      Ok(())
  }

  #[cfg(not(feature = "hacspec"))]
  /// Serialization for HashSet given a size_len.
  /// Values are not serialized in any particular order.
  impl<K: Serial> SerialCtx for HashSet<K> {
      fn serial_ctx<W: Write>(
          &self,
          size_len: concordium_contracts_common::schema::SizeLength,
          out: &mut W,
      ) -> Result<(), W::Err> {
          concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
          // concordium_std::
          serial_hashset_no_length(self, out)
      }
  }

#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Read a [HashSet](https://doc.rust-lang.org/std/collections/struct.HashSet.html) as a list of keys, given some length.
  /// NB: This ensures there are no duplicates.
  pub fn deserial_hashset_no_length<R: Read, K: Deserial + Eq + Hash>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<HashSet<K>> {
      let mut out = HashSet::default();
      for _ in 0..len {
          let key = source.get()?;
          if !out.insert(key) {
              return Err(ParseError::default());
          }
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]  
  /// Deserialization for HashSet given a size_len.
  /// Values are not verified to be in any particular order and setting
  /// ensure_ordering have no effect.
  impl<K: Deserial + Eq + Hash> DeserialCtx for HashSet<K> {
      fn deserial_ctx<R: Read>(
          size_len: concordium_contracts_common::schema::SizeLength,
          _ensure_ordered: bool,
          source: &mut R,
      ) -> ParseResult<Self> {
          let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
          deserial_hashset_no_length(source, len)
      }
  }

#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]  
  /// Write a HashMap as a list of key-value pairs in to particular order, without
  /// the length information.
  pub fn serial_hashmap_no_length<W: Write, K: Serial, V: Serial>(
      map: &HashMap<K, V>,
      out: &mut W,
  ) -> Result<(), W::Err> {
      for (k, v) in map.iter() {
          k.serial(out)?;
          v.serial(out)?;
      }
      Ok(())
  }

  #[cfg(not(feature = "hacspec"))]  
  /// Serialization for HashMap given a size_len.
  /// Keys are not serialized in any particular order.
  impl<K: Serial, V: Serial> SerialCtx for HashMap<K, V> {
      fn serial_ctx<W: Write>(
          &self,
          size_len: concordium_contracts_common::schema::SizeLength,
          out: &mut W,
      ) -> Result<(), W::Err> {
          concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
          serial_hashmap_no_length(self, out)
      }
  }
  
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Read a [HashMap](https://doc.rust-lang.org/std/collections/struct.HashMap.html) as a list of key-value pairs given some length.
  pub fn deserial_hashmap_no_length<R: Read, K: Deserial + Eq + Hash, V: Deserial>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<HashMap<K, V>> {
      let mut out = HashMap::default();
      for _ in 0..len {
          let k = source.get()?;
          let v = source.get()?;
          if out.insert(k, v).is_some() {
              return Err(ParseError::default());
          }
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]
  /// Deserialization for HashMap given a size_len.
  /// Keys are not verified to be in any particular order and setting
  /// ensure_ordering have no effect.
  impl<K: Deserial + Eq + Hash, V: Deserial> DeserialCtx for HashMap<K, V> {
      fn deserial_ctx<R: Read>(
          size_len: concordium_contracts_common::schema::SizeLength,
          _ensure_ordered: bool,
          source: &mut R,
      ) -> ParseResult<Self> {
          let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
          // concordium_std::
          deserial_hashmap_no_length(source, len)
      }
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Write a slice of elements, without including length information.
  /// This is intended to be used either when the length is statically known,
  /// or when the length is serialized independently as part of a bigger
  /// structure.
  pub fn serial_vector_no_length<W: Write, T: Serial>(xs: &[T], out: &mut W) -> Result<(), W::Err> {
      for x in xs {
          x.serial(out)?;
      }
      Ok(())
  }

  #[cfg(not(feature = "hacspec"))]
  impl<T: Serial> SerialCtx for &[T] {
      fn serial_ctx<W: Write>(
          &self,
          size_len: concordium_contracts_common::schema::SizeLength,
          out: &mut W,
      ) -> Result<(), W::Err> {
          concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
          serial_vector_no_length(self, out)
      }
  }
  
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub(crate) static MAX_PREALLOCATED_CAPACITY: usize = 4096;

  #[cfg(not(feature = "hacspec"))]
  /// Read a vector given a length.
  pub fn deserial_vector_no_length<R: Read, T: Deserial>(
      reader: &mut R,
      len: usize,
  ) -> ParseResult<Vec<T>> {
      let mut vec = Vec::with_capacity(core::cmp::min(len, MAX_PREALLOCATED_CAPACITY));
      for _ in 0..len {
          vec.push(T::deserial(reader)?);
      }
      Ok(vec)
  }

  #[cfg(not(feature = "hacspec"))]
  impl<T: Deserial> DeserialCtx for Vec<T> {
      fn deserial_ctx<R: Read>(
          size_len: concordium_contracts_common::schema::SizeLength,
          _ensure_ordered: bool,
          source: &mut R,
      ) -> ParseResult<Self> {
          let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
          deserial_vector_no_length(source, len)
      }
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl SerialCtx for &str {
      fn serial_ctx<W: Write>(
          &self,
          size_len: concordium_contracts_common::schema::SizeLength,
          out: &mut W,
      ) -> Result<(), W::Err> {
          concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
          serial_vector_no_length(&self.as_bytes().to_vec(), out)
      }
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl SerialCtx for String {
      fn serial_ctx<W: Write>(
          &self,
          size_len: concordium_contracts_common::schema::SizeLength,
          out: &mut W,
      ) -> Result<(), W::Err> {
          self.as_str().serial_ctx(size_len, out)
      }
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]  
  impl DeserialCtx for String {
      fn deserial_ctx<R: Read>(
          size_len: concordium_contracts_common::schema::SizeLength,
          _ensure_ordered: bool,
          source: &mut R,
      ) -> ParseResult<Self> {
          let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
          let bytes = deserial_vector_no_length(source, len)?;
          let res = String::from_utf8(bytes).map_err(|_| ParseError::default())?;
          Ok(res)
      }
  }
#+end_src

*** Rust Tests
#+begin_src rust :eval never

#+end_src

* Generation of backend output

#+begin_src elisp :var SOURCE-CODE-FILE="Concordium.v" :results output silent :tangle no
(org-babel-detangle SOURCE-CODE-FILE)
#+end_src

*** Coq code
:PROPERTIES:
:header-args: coq :tangle Concordium.v :comments link
:header-args: coq :eval never :results output silent
:END:

#+begin_src coq
(** This file was automatically generated using Hacspec **)
Require Import Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.
#+end_src

#+begin_src coq
Require Import Crate.
#+end_src

#+begin_src coq
Definition max_contract_state_size_v : int32 :=
  @repr WORDSIZE32 16384.
#+end_src

#+begin_src coq
Definition max_log_size_v : uint_size :=
  usize 512.
#+end_src

#+begin_src coq
Definition max_num_logs_v : uint_size :=
  usize 64.
#+end_src

#+begin_src coq
Inductive log_error_t :=
| Full : log_error_t
| Malformed : log_error_t.

Definition eqb_log_error_t (x y : log_error_t) : bool :=
match x with
   | Full => match y with | Full=> true | _ => false end
   | Malformed => match y with | Malformed=> true | _ => false end
   end.

Definition eqb_leibniz_log_error_t (x y : log_error_t) : eqb_log_error_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_log_error_t : EqDec (log_error_t) :=
Build_EqDec (log_error_t) (eqb_log_error_t) (eqb_leibniz_log_error_t).
#+end_src

#+begin_src coq
Require Import Hacspec.Lib.
#+end_src

#+begin_src coq
Definition load_state_hacspec
  (buf_0 : public_byte_seq)
  (offset_1 : int32)
  : (public_byte_seq × int32) :=
  (buf_0, @repr WORDSIZE32 1).
#+end_src

#+begin_src coq
Definition write_state_hacspec
  (buf_2 : public_byte_seq)
  (offset_3 : int32)
  : (public_byte_seq × int32) :=
  (buf_2, @repr WORDSIZE32 1).
#+end_src

#+begin_src coq
Definition state_size_hacspec  : int32 :=
  @repr WORDSIZE32 1.
#+end_src

#+begin_src coq
Definition resize_state_hacspec (new_size_4 : int32) : int32 :=
  @repr WORDSIZE32 1.
#+end_src

#+begin_src coq
Definition get_parameter_section_hacspec
  (buf_5 : public_byte_seq)
  (offset_6 : int32)
  : (public_byte_seq × int32) :=
  (buf_5, @repr WORDSIZE32 1).
#+end_src

#+begin_src coq
Definition get_parameter_size_hacspec  : int32 :=
  @repr WORDSIZE32 1.
#+end_src

#+begin_src coq
Definition get_slot_time_hacspec  : int64 :=
  @repr WORDSIZE64 1.
#+end_src

#+begin_src coq
Definition get_policy_section_hacspec
  (policy_bytes_7 : public_byte_seq)
  (offset_8 : int32)
  : (public_byte_seq × int32) :=
  (policy_bytes_7, @repr WORDSIZE32 1).
#+end_src

#+begin_src coq
Definition get_init_origin_hacspec
  (start_9 : public_byte_seq)
  : public_byte_seq :=
  start_9.
#+end_src

#+begin_src coq
Definition get_receive_invoker_hacspec
  (start_10 : public_byte_seq)
  : public_byte_seq :=
  start_10.
#+end_src

#+begin_src coq
Definition get_receive_self_address_hacspec
  (start_11 : public_byte_seq)
  : public_byte_seq :=
  start_11.
#+end_src

#+begin_src coq
Definition get_receive_self_balance_hacspec  : int64 :=
  @repr WORDSIZE64 1.
#+end_src

#+begin_src coq
Definition get_receive_sender_hacspec
  (start_12 : public_byte_seq)
  : public_byte_seq :=
  start_12.
#+end_src

#+begin_src coq
Definition get_receive_owner_hacspec
  (start_13 : public_byte_seq)
  : public_byte_seq :=
  start_13.
#+end_src

#+begin_src coq
Definition log_event_hacspec
  (start_14 : public_byte_seq)
  : (public_byte_seq × int32) :=
  (start_14, @repr WORDSIZE32 1).
#+end_src

#+begin_src coq
Definition accept_hacspec  : int32 :=
  @repr WORDSIZE32 1.
#+end_src

#+begin_src coq
Definition simple_transfer_hacspec
  (buf_15 : public_byte_seq)
  (amount_16 : int64)
  : int32 :=
  @repr WORDSIZE32 1.
#+end_src

#+begin_src coq
Definition send_hacspec
  (addr_index_17 : int64)
  (addr_subindex_18 : int64)
  (receive_name_19 : public_byte_seq)
  (amount_20 : int64)
  (parameter_21 : public_byte_seq)
  : int32 :=
  @repr WORDSIZE32 1.
#+end_src

#+begin_src coq
Definition combine_and_hacspec (l_22 : int32) (r_23 : int32) : int32 :=
  @repr WORDSIZE32 1.
#+end_src

#+begin_src coq
Definition combine_or_hacspec (l_24 : int32) (r_25 : int32) : int32 :=
  @repr WORDSIZE32 1.
#+end_src

#+begin_src coq
Require Import Hacspec.Lib.
#+end_src

#+begin_src coq
Notation "'reject_hacspec_t'" := (int32) : hacspec_scope.
#+end_src

#+begin_src coq
Definition reject_impl_deafult  : reject_hacspec_t :=
  min_v.
#+end_src

#+begin_src coq
Definition new_reject_impl (x_26 : int32) : (option int32) :=
  (if ((x_26) <.? (@repr WORDSIZE32 0)):bool then (@Some int32 (x_26)) else (
      @None int32)).
#+end_src

#+begin_src coq
Definition reject_impl_convert_from_unit  : reject_hacspec_t :=
  (min_v) .+ (@repr WORDSIZE32 1).

Theorem ensures_reject_impl_convert_from_unit : forall result_27 ,
@reject_impl_convert_from_unit  = result_27 ->
~ (result_27 = @repr WORDSIZE32 0).
Proof. Admitted.
#+end_src

#+begin_src coq
Definition reject_impl_convert_from_parse_error  : reject_hacspec_t :=
  (min_v) .+ (@repr WORDSIZE32 2).

Theorem ensures_reject_impl_convert_from_parse_error : forall result_27 ,
@reject_impl_convert_from_parse_error  = result_27 ->
~ (result_27 = @repr WORDSIZE32 0).
Proof. Admitted.
#+end_src

#+begin_src coq
Definition reject_impl_from_log_error
  (le_28 : log_error_t)
  : reject_hacspec_t :=
  match le_28 with
  | Full => (min_v) .+ (@repr WORDSIZE32 3)
  | Malformed => (min_v) .+ (@repr WORDSIZE32 4)
  end.

Theorem ensures_reject_impl_from_log_error : forall result_27 (
  le_28 : log_error_t),
@reject_impl_from_log_error le_28 = result_27 ->
~ (result_27 = @repr WORDSIZE32 0).
Proof. Admitted.
#+end_src

#+begin_src coq
Inductive new_contract_name_error_t :=
| NewContractNameErrorMissingInitPrefix : new_contract_name_error_t
| NewContractNameErrorTooLong : new_contract_name_error_t
| NewContractNameErrorContainsDot : new_contract_name_error_t
| NewContractNameErrorInvalidCharacters : new_contract_name_error_t.
#+end_src

#+begin_src coq
Definition reject_impl_from_new_contract_name_error
  (nre_29 : new_contract_name_error_t)
  : reject_hacspec_t :=
  match nre_29 with
  | NewContractNameErrorMissingInitPrefix => (min_v) .+ (@repr WORDSIZE32 5)
  | NewContractNameErrorTooLong => (min_v) .+ (@repr WORDSIZE32 6)
  | NewContractNameErrorContainsDot => (min_v) .+ (@repr WORDSIZE32 9)
  | NewContractNameErrorInvalidCharacters => (min_v) .+ (@repr WORDSIZE32 10)
  end.

Theorem ensures_reject_impl_from_new_contract_name_error : forall result_27 (
  nre_29 : new_contract_name_error_t),
@reject_impl_from_new_contract_name_error nre_29 = result_27 ->
~ (result_27 = @repr WORDSIZE32 0).
Proof. Admitted.
#+end_src

#+begin_src coq
Inductive new_receive_name_error_t :=
| NewReceiveNameErrorMissingDotSeparator : new_receive_name_error_t
| NewReceiveNameErrorTooLong : new_receive_name_error_t
| NewReceiveNameErrorInvalidCharacters : new_receive_name_error_t.
#+end_src

#+begin_src coq
Definition reject_impl_from_new_receive_name_error
  (nre_30 : new_receive_name_error_t)
  : reject_hacspec_t :=
  match nre_30 with
  | NewReceiveNameErrorMissingDotSeparator => (min_v) .+ (@repr WORDSIZE32 7)
  | NewReceiveNameErrorTooLong => (min_v) .+ (@repr WORDSIZE32 8)
  | NewReceiveNameErrorInvalidCharacters => (min_v) .+ (@repr WORDSIZE32 11)
  end.

Theorem ensures_reject_impl_from_new_receive_name_error : forall result_27 (
  nre_30 : new_receive_name_error_t),
@reject_impl_from_new_receive_name_error nre_30 = result_27 ->
~ (result_27 = @repr WORDSIZE32 0).
Proof. Admitted.
#+end_src

#+begin_src coq
Notation "'contract_state_hacspec_t'" := (int32) : hacspec_scope.
#+end_src

#+begin_src coq
Inductive seek_from_hacspec_t :=
| Start : int64 -> seek_from_hacspec_t
| End : int64 -> seek_from_hacspec_t
| Current : int64 -> seek_from_hacspec_t.
#+end_src

#+begin_src coq
Notation "'uint32_option_t'" := ((option int32)) : hacspec_scope.
#+end_src

#+begin_src coq
Notation "'iint64_option_t'" := ((option int64)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition contract_state_impl_seek
  (current_position_31 : contract_state_hacspec_t)
  (pos_32 : seek_from_hacspec_t)
  : (result (contract_state_hacspec_t × int64) unit) :=
  match pos_32 with
  | Start offset_33 => @Ok (contract_state_hacspec_t × int64) unit ((
      @cast _ uint32 _ (offset_33),
      offset_33
    ))
  | End delta_34 => (if ((delta_34) >=.? (@repr WORDSIZE64 0)):bool then (
      match pub_uint32_checked_add (current_position_31) (@cast _ uint32 _ (
	  delta_34)) with
      | Some b_35 => @Ok (contract_state_hacspec_t × int64) unit ((
	  b_35,
	  @cast _ uint64 _ (delta_34)
	))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end) else (match pub_int64_checked_abs (delta_34) with
      | Some b_36 => @Ok (contract_state_hacspec_t × int64) unit ((
	  (@repr WORDSIZE32 4) .- (@cast _ uint32 _ (b_36)),
	  @cast _ uint64 _ ((@repr WORDSIZE32 4) .- (@cast _ uint32 _ (b_36)))
	))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end))
  | Current delta_37 => (if ((delta_37) >=.? (@repr WORDSIZE64 0)):bool then (
      match pub_uint32_checked_add (current_position_31) (@cast _ uint32 _ (
	  delta_37)) with
      | Some offset_38 => @Ok (contract_state_hacspec_t × int64) unit ((
	  offset_38,
	  @cast _ uint64 _ (offset_38)
	))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end) else (match pub_int64_checked_abs (delta_37) with
      | Some b_39 => match pub_uint32_checked_sub (current_position_31) (
	@cast _ uint32 _ (b_39)) with
      | Some offset_40 => @Ok (contract_state_hacspec_t × int64) unit ((
	  offset_40,
	  @cast _ uint64 _ (offset_40)
	))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end))
  end.
#+end_src

#+begin_src coq
Definition contract_state_impl_read_read
  (current_position_41 : contract_state_hacspec_t)
  (buf_42 : public_byte_seq)
  : (contract_state_hacspec_t × uint_size) :=
  let '(buf_43, num_read_44) :=
    load_state_hacspec (buf_42) (current_position_41) in 
  ((current_position_41) .+ (num_read_44), @cast _ uint32 _ (num_read_44)).
#+end_src

#+begin_src coq
Definition contract_state_impl_read_read_u64
  (current_position_45 : contract_state_hacspec_t)
  : (contract_state_hacspec_t × int64) :=
  let buf_46 : seq int8 :=
    seq_new_ (default) (usize 8) in 
  let '(buf_47, num_read_48) :=
    load_state_hacspec (buf_46) (current_position_45) in 
  (
    (current_position_45) .+ (num_read_48),
    u64_from_le_bytes (array_from_seq (8) (buf_47))
  ).
#+end_src

#+begin_src coq
Definition contract_state_impl_read_read_u32
  (current_position_49 : contract_state_hacspec_t)
  : (contract_state_hacspec_t × int32) :=
  let buf_50 : seq int8 :=
    seq_new_ (default) (usize 4) in 
  let '(buf_51, num_read_52) :=
    load_state_hacspec (buf_50) (current_position_49) in 
  (
    (current_position_49) .+ (num_read_52),
    u32_from_le_bytes (array_from_seq (4) (buf_51))
  ).
#+end_src

#+begin_src coq
Definition contract_state_impl_read_read_u8
  (current_position_53 : contract_state_hacspec_t)
  : (contract_state_hacspec_t × int8) :=
  let buf_54 : seq int8 :=
    seq_new_ (default) (usize 1) in 
  let '(buf_55, num_read_56) :=
    load_state_hacspec (buf_54) (current_position_53) in 
  ((current_position_53) .+ (num_read_56), seq_index (buf_55) (usize 0)).
#+end_src

#+begin_src coq
Definition contract_state_impl_write
  (current_position_57 : contract_state_hacspec_t)
  (buf_58 : public_byte_seq)
  : (result (contract_state_hacspec_t × uint_size) unit) :=
  ifbnd option_is_none (pub_uint32_checked_add (current_position_57) (pub_u32 (
	seq_len (buf_58)))) : bool
  thenbnd (bind (@Err (contract_state_hacspec_t × uint_size) unit (tt)) (
      fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  let '(buf_59, num_bytes_60) :=
    write_state_hacspec (buf_58) (current_position_57) in 
  @Ok (contract_state_hacspec_t × uint_size) unit ((
      (current_position_57) .+ (num_bytes_60),
      @cast _ uint32 _ (num_bytes_60)
    ))).
#+end_src

#+begin_src coq
Definition has_contract_state_impl_for_contract_state_open

  : contract_state_hacspec_t :=
  @repr WORDSIZE32 0.
#+end_src

#+begin_src coq
Definition has_contract_state_impl_for_contract_state_reserve
  (contract_state_61 : contract_state_hacspec_t)
  (len_62 : int32)
  : bool :=
  let cur_size_63 : int32 :=
    state_size_hacspec  in 
  (if ((cur_size_63) <.? (len_62)):bool then ((resize_state_hacspec (
	  len_62)) =.? (@repr WORDSIZE32 1)) else (true)).
#+end_src

#+begin_src coq
Definition has_contract_state_impl_for_contract_state_truncate
  (current_position_64 : contract_state_hacspec_t)
  (cur_size_65 : int32)
  (new_size_66 : int32)
  : contract_state_hacspec_t :=
  let 'tt :=
    if (cur_size_65) >.? (new_size_66):bool then (let _ : int32 :=
	resize_state_hacspec (new_size_66) in 
      tt) else (tt) in 
  (if ((new_size_66) <.? (current_position_64)):bool then (new_size_66) else (
      current_position_64)).
#+end_src

#+begin_src coq
Notation "'parameter_hacspec_t'" := (int32) : hacspec_scope.
#+end_src

#+begin_src coq
Definition read_impl_for_parameter_read
  (current_position_67 : parameter_hacspec_t)
  (buf_68 : public_byte_seq)
  : (parameter_hacspec_t × uint_size) :=
  let '(buf_69, num_read_70) :=
    get_parameter_section_hacspec (buf_68) (current_position_67) in 
  ((current_position_67) .+ (num_read_70), @cast _ uint32 _ (num_read_70)).
#+end_src

#+begin_src coq
Notation "'attributes_cursor_hacspec_t'" := ((int32 × int16)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition has_policy_impl_for_policy_attributes_cursor_next_item
  (policy_attribute_items_71 : attributes_cursor_hacspec_t)
  (buf_72 : public_byte_seq)
  : (option (attributes_cursor_hacspec_t × (int8 × int8))) :=
  let '(current_position_73, remaining_items_74) :=
    policy_attribute_items_71 in 
  ifbnd (remaining_items_74) =.? (@repr WORDSIZE16 0) : bool
  thenbnd (bind (@None (attributes_cursor_hacspec_t × (int8 × int8))) (
      fun _ =>  Some (tt)))
  else (tt) >> (fun 'tt =>
  let '(tag_value_len_75, num_read_76) :=
    get_policy_section_hacspec (seq_new_ (default) (usize 2)) (
      current_position_73) in 
  let current_position_73 :=
    (current_position_73) .+ (num_read_76) in 
  ifbnd (seq_index (tag_value_len_75) (usize 1)) >.? (@repr WORDSIZE8 31) : bool
  thenbnd (bind (@None (attributes_cursor_hacspec_t × (int8 × int8))) (
      fun _ =>  Some (tt)))
  else (tt) >> (fun 'tt =>
  let '(buf_77, num_read_78) :=
    get_policy_section_hacspec (buf_72) (current_position_73) in 
  let current_position_73 :=
    (current_position_73) .+ (num_read_78) in 
  let remaining_items_74 :=
    (remaining_items_74) .- (@repr WORDSIZE16 1) in 
  @Some (attributes_cursor_hacspec_t × (int8 × int8)) ((
      (current_position_73, remaining_items_74),
      (
	seq_index (tag_value_len_75) (usize 0),
	seq_index (tag_value_len_75) (usize 1)
      )
    )))).
#+end_src

#+begin_src coq
Notation "'policies_iterator_hacspec_t'" := ((int32 × int16)) : hacspec_scope.
#+end_src

#+begin_src coq
Notation "'policy_attributes_cursor_hacspec_t'" := ((
  int32 ×
  int64 ×
  int64 ×
  attributes_cursor_hacspec_t
)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition iterator_impl_for_policies_iterator_next
  (policies_iterator_79 : policies_iterator_hacspec_t)
  : (option (policies_iterator_hacspec_t × policy_attributes_cursor_hacspec_t
    )) :=
  let '(pos_80, remaining_items_81) :=
    policies_iterator_79 in 
  ifbnd (remaining_items_81) =.? (@repr WORDSIZE16 0) : bool
  thenbnd (bind (@None (
	policies_iterator_hacspec_t ×
	policy_attributes_cursor_hacspec_t
      )) (fun _ =>  Some (tt)))
  else (tt) >> (fun 'tt =>
  let '(buf_82, _) :=
    get_policy_section_hacspec (seq_new_ (default) (((((usize 2) + (
		usize 4)) + (usize 8)) + (usize 8)) + (usize 2))) (pos_80) in 
  let skip_part_83 : public_byte_seq :=
    seq_slice_range (buf_82) ((usize 0, usize 2)) in 
  let ip_part_84 : public_byte_seq :=
    seq_slice_range (buf_82) ((usize 2, (usize 2) + (usize 4))) in 
  let created_at_part_85 : public_byte_seq :=
    seq_slice_range (buf_82) ((
	(usize 2) + (usize 4),
	((usize 2) + (usize 4)) + (usize 8)
      )) in 
  let valid_to_part_86 : public_byte_seq :=
    seq_slice_range (buf_82) ((
	((usize 2) + (usize 4)) + (usize 8),
	(((usize 2) + (usize 4)) + (usize 8)) + (usize 8)
      )) in 
  let len_part_87 : public_byte_seq :=
    seq_slice_range (buf_82) ((
	(((usize 2) + (usize 4)) + (usize 8)) + (usize 8),
	((((usize 2) + (usize 4)) + (usize 8)) + (usize 8)) + (usize 2)
      )) in 
  let identity_provider_88 : int32 :=
    u32_from_le_bytes (array_from_seq (4) (ip_part_84)) in 
  let created_at_89 : int64 :=
    u64_from_le_bytes (array_from_seq (8) (created_at_part_85)) in 
  let valid_to_90 : int64 :=
    u64_from_le_bytes (array_from_seq (8) (valid_to_part_86)) in 
  let remaining_items_91 : int16 :=
    u16_from_le_bytes (array_from_seq (2) (len_part_87)) in 
  let attributes_start_92 : int32 :=
    (((((pos_80) .+ (@repr WORDSIZE32 2)) .+ (@repr WORDSIZE32 4)) .+ (
	  @repr WORDSIZE32 8)) .+ (@repr WORDSIZE32 8)) .+ (
      @repr WORDSIZE32 2) in 
  let pos_80 :=
    ((pos_80) .+ (@cast _ uint32 _ (u16_from_le_bytes (array_from_seq (2) (
	      skip_part_83))))) .+ (@repr WORDSIZE32 2) in 
  let remaining_items_91 :=
    (remaining_items_91) .- (@repr WORDSIZE16 1) in 
  @Some (policies_iterator_hacspec_t × policy_attributes_cursor_hacspec_t) ((
      (pos_80, remaining_items_91),
      (
	identity_provider_88,
	created_at_89,
	valid_to_90,
	(attributes_start_92, remaining_items_91)
      )
    ))).
#+end_src
