#+TITLE: Piggybank Smartcontract
#+AUTHOR: Lasse Letager Hansen

# Use org-tanglesync !
# lentic

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file
# C-c C-v s   -  create results / run subtree

* General information
:PROPERTIES:
:header-args: sh :eval never :results output silent
:END:
** Resulting output
#+begin_src sh
cargo clean
#+end_src

#+begin_src sh
cargo install --path language
#+end_src

#+begin_src sh
cargo build
#+end_src

#+begin_src sh
cargo hacspec -e v --dir coq/src/ hacspec-piggybank --org-file piggybank.org --vc-init --vc-dir coq/_vc
#+end_src

#+begin_src sh
cargo hacspec -e v --dir coq/src/ hacspec-piggybank --org-file piggybank.org --vc-update --vc-dir coq/_vc
#+end_src

* Piggybank smart contract specification
** Config
#+begin_src toml :tangle ../../examples/piggybank/Cargo.toml :mkdirp yes :eval never
[package]
name = "hacspec-piggybank"
version = "0.1.0"
authors = [""]
edition = "2018"

[lib]
path = "src/piggybank.rs"

[dependencies]
hacspec-lib = { path = "../../lib" }
# pearlite-syn = { path = "../../../../creusot/pearlite-syn" }
creusot-contracts = { git = "https://github.com/xldenis/creusot", rev = "7763b3ae77205fba83182b9a6c3e69ad0b12fec7" }
# hacspec = {optional = true}
concordium-contracts-common = { git = "https://github.com/Concordium/concordium-contracts-common", rev = "84ff7db509ca1fbf958b47e5e5903b7662295850" ,  version = "=2.0.0" , default-features = false }
hacspec-concordium = { path = "../concordium" }
hacspec-concordium-derive = { path = "../concordium-derive" }

[features]
hacspec = []

[dev-dependencies]
hacspec-dev = { path = "../../utils/dev" }
criterion = "0.3"
rand = "0.8"
quickcheck = "1"
quickcheck_macros = "1"
#+end_src

** Rust code
:PROPERTIES:
:header-args: rust :tangle ../../examples/piggybank/src/piggybank.rs :mkdirp yes :eval never
:END:

*** Imports
#+begin_src rust
#[cfg(not(feature = "hacspec"))]
extern crate hacspec_lib;

use hacspec_lib::*;

#[cfg(not(feature = "hacspec"))]
extern crate creusot_contracts;
#[cfg(not(feature = "hacspec"))]
use creusot_contracts::{ensures, requires};
#+end_src

#+begin_src rust
use hacspec_concordium::*;
#+end_src

#+begin_src rust
#[cfg(feature = "hacspec")]
use concert_lib::*;
#+end_src

#+begin_src rust
#[cfg(not(feature = "hacspec"))]
/// The state of the piggy bank
#[derive(Debug, Serialize, PartialEq, Eq)]
enum PiggyBankState {
    /// Alive and well, allows for GTU to be inserted.
    Intact,
    /// The piggy bank has been emptied, preventing further GTU to be inserted.
    Smashed,
}


#[cfg(feature = "hacspec")]
/// The state of the piggy bank
#[derive(Debug, PartialEq, Eq , Serialize)]
#[contract_state(contract = "CIS1-wCCD")]
pub enum PiggyBankStateHacspec {
    Intact,
    Smashed,
}
#[cfg(not(feature = "hacspec"))]
#[derive(Debug, PartialEq, Eq)]
pub enum PiggyBankStateHacspec {
    Intact,
    Smashed,
}

#[cfg(not(feature = "hacspec"))]
fn coerce_hacspec_to_rust_piggybank_state(pbs : PiggyBankStateHacspec) -> PiggyBankState {
    match pbs {
        PiggyBankStateHacspec::Intact  => PiggyBankState::Intact,
        PiggyBankStateHacspec::Smashed => PiggyBankState::Smashed,
    }
}


#[cfg(not(feature = "hacspec"))]
fn coerce_rust_to_hacspec_piggybank_state(pbs : &PiggyBankState) -> PiggyBankStateHacspec {
    match pbs {
        PiggyBankState::Intact  => PiggyBankStateHacspec::Intact,
        PiggyBankState::Smashed => PiggyBankStateHacspec::Smashed,
    }
}
#+end_src

#+begin_src rust
pub fn piggy_init_hacspec() -> PiggyBankStateHacspec {
    // Always succeeds
    PiggyBankStateHacspec::Intact
}
#+end_src

#+begin_src rust
#[cfg(feature = "hacspec")]
#[init(contract = "PiggyBank")]
pub fn piggy_init(ctx : Context) -> (Context, PiggyBankStateHacspec) { // , actions
    // Always succeeds
    (ctx, piggy_init_hacspec())
}
#+end_src

#+begin_src rust
#[cfg(not(feature = "hacspec"))]
/// Setup a new Intact piggy bank.
#[init(contract = "PiggyBank")]
fn piggy_init(_ctx: &impl HasInitContext) -> InitResult<PiggyBankState> {
    // Always succeeds
    Ok(coerce_hacspec_to_rust_piggybank_state(piggy_init_hacspec()))
}
#+end_src

#+begin_src rust
pub type PiggyInsertResult = Result<(), ()>;

pub fn piggy_insert_hacspec(ctx: Context, amount: u64, state: PiggyBankStateHacspec) -> PiggyInsertResult {
    // Ensure the piggy bank has not been smashed already.
    match state {
        PiggyBankStateHacspec::Intact => PiggyInsertResult::Ok(()),
        PiggyBankStateHacspec::Smashed => PiggyInsertResult::Err(()),
    }
}

#[cfg(feature = "hacspec")]
#[receive(contract = "PiggyBank", name = "insert", payable)]
pub fn piggy_insert(ctx_state: (Context, PiggyBankStateHacspec), amount: u64) -> Option<((Context, PiggyBankStateHacspec), ListAction)> {
    let (ctx, state) = ctx_state;
    let Context(a, c, balance, d) = ctx;
    accept_hacspec();
    let temp = piggy_insert_hacspec(ctx, amount, state);
    match temp {
        PiggyInsertResult::Ok(_) => Option::<()>::Some(()),
        PiggyInsertResult::Err(_) => Option::<()>::None
    }?;
    let s = Seq::<HasAction>::new(0);
    s[0] = accept_action();
    Option::<((Context, PiggyBankStateHacspec), ListAction)>::Some (((Context(a, c, balance + amount, d), state), s))
}

#[cfg(not(feature = "hacspec"))]
/// Insert some GTU into a piggy bank, allowed by anyone.
#[receive(contract = "PiggyBank", name = "insert", payable)]
fn piggy_insert<A: HasActions>(
    ctx: &impl HasReceiveContext,
    amount: Amount,
    state: &mut PiggyBankState,
) -> ReceiveResult<A> {
    let ctx_hacspec = coerce_rust_to_hacspec_context(ctx)?;
    // Ensure the piggy bank has not been smashed already.
    piggy_insert_hacspec(ctx_hacspec, amount.micro_ccd, coerce_rust_to_hacspec_piggybank_state(state))?;
    // Just accept since the GTU balance is managed by the chain.
    Ok(A::accept())
}

// #[cfg(not(feature = "hacspec"))]
#[derive(Debug, PartialEq, Eq, Reject)]
enum SmashError {
    NotOwner,
    AlreadySmashed,
}

#[cfg(not(feature = "hacspec"))]
fn coerce_rust_to_hacspec_context(ctx: &impl HasReceiveContext) -> Result<Context, SmashError> {
    Ok(Context(
        coerce_rust_to_hacspec_account_address(&ctx.owner()),
        coerce_rust_to_hacspec_account_address(
            &(match ctx.sender() {
                Address::Account(a) => Ok(a),
                _ => Err(SmashError::NotOwner),
            }?),
        ),
        match ctx.self_balance() {
            Amount { micro_ccd } => micro_ccd,
        },
        0u64
    ))
}

type PiggySmashResult = Result<PiggyBankStateHacspec, SmashError>;

fn piggy_smash_hacspec(ctx: Context, state: PiggyBankStateHacspec) -> PiggySmashResult {
    // Get the contract owner, i.e. the account who initialized the contract.
    let Context(owner, sender, _balance, _metadata) = ctx;

    if !(owner == sender) {
        PiggySmashResult::Err(SmashError::NotOwner)?;
    }

    if !(state == PiggyBankStateHacspec::Intact) {
        PiggySmashResult::Err(SmashError::AlreadySmashed)?;
    }

    PiggySmashResult::Ok(PiggyBankStateHacspec::Smashed)
}

#[cfg(feature = "hacspec")]
#[receive(contract = "PiggyBank", name = "smash")]
fn piggy_smash(ctx_state: (Context, PiggyBankStateHacspec)) -> Option<((Context, PiggyBankStateHacspec), ListAction)> {
    let (ctx, state) = ctx_state;
    let Context(a, c, balance, d) = ctx;
    accept_hacspec();
    let smash = piggy_smash_hacspec(ctx, state);
    let new_state = match smash {
        PiggySmashResult::Ok(a) => Option::<PiggyBankStateHacspec>::Some(a),
        PiggySmashResult::Err(b) => Option::<PiggyBankStateHacspec>::None,
    }?;
    let s = Seq::<HasAction>::new(1);
    // s[0] = HasAction::SIMPLE_TRANSFER( a, balance );
    Option::<((Context, PiggyBankStateHacspec), ListAction)>::Some(((Context(a, c, 0u64, d), new_state), s))
    // piggy_smash_hacspec(ctx, state)
}

#[cfg(not(feature = "hacspec"))]
/// Smash a piggy bank retrieving the GTU, only allowed by the owner.
#[receive(contract = "PiggyBank", name = "smash")]
fn piggy_smash<A: HasActions>(
    ctx: &impl HasReceiveContext,
    state: &mut PiggyBankState,
) -> Result<A, SmashError> {
    let ctx_hacspec = coerce_rust_to_hacspec_context(ctx)?;

    ,*state = coerce_hacspec_to_rust_piggybank_state(
        match piggy_smash_hacspec(ctx_hacspec, coerce_rust_to_hacspec_piggybank_state(state)) {
            Ok(a) => a,
            Err(e) => return Err(e),
        },
    );

    // Get the current balance of the smart contract.
    let balance = ctx.self_balance();
    // Result in a transfer of the whole balance to the contract owner.
    Ok(A::simple_transfer(&ctx.owner(), balance))
}

//Tests - type checker ignores #[cfg(test)] parts
#[cfg(test)]
extern crate quickcheck;
#[cfg(test)]
#[macro_use(quickcheck)]
extern crate quickcheck_macros;

#[cfg(test)]
use quickcheck::*;

// Running the initialization ensuring nothing fails and the state of the
// piggy bank is intact.
#[cfg(test)]
#[proof]
fn test_init_hacspec() -> bool {
    piggy_init_hacspec() == PiggyBankStateHacspec::Intact
}

#[cfg(test)]
#[quickcheck]
#[proof]
fn test_insert_intact(ctx: Context, amount: u64) -> bool {
    piggy_insert_hacspec(ctx, amount, PiggyBankStateHacspec::Intact) == PiggyInsertResult::Ok(())
}

#[cfg(test)]
#[quickcheck]
#[proof]
fn test_insert_smashed(ctx: Context, amount: u64) -> bool {
    piggy_insert_hacspec(ctx, amount, PiggyBankStateHacspec::Smashed) == PiggyInsertResult::Err(())
}

#[cfg(test)]
#[quickcheck]
#[proof]
fn test_smash_intact(owner : UserAddress, balance : u64, metadata: u64) -> bool {
    // Setup the context
    let sender = owner;
    let ctx = Context(owner, sender, balance, metadata);

    // Trigger the smash
    piggy_smash_hacspec(ctx, PiggyBankStateHacspec::Intact) == PiggySmashResult::Ok(PiggyBankStateHacspec::Smashed)
}

#[cfg(test)]
#[quickcheck]
#[proof]
fn test_smash_intact_not_owner(owner : UserAddress, sender : UserAddress, balance : u64, metadata: u64) -> bool{
    // Setup the contextt
    let ctx = Context(owner, sender, balance, metadata);

    // Trigger the smash
    // TODO: Generate pair of owner sender not equal (not a big issue)
    owner == sender || piggy_smash_hacspec(ctx, PiggyBankStateHacspec::Intact) == PiggySmashResult::Err(SmashError::NotOwner)
}

#[cfg(test)]
#[quickcheck]
#[proof]
fn test_smash_smashed(owner : UserAddress, balance : u64, metadata: u64) -> bool{
    // Setup the context
    let sender = owner;
    let ctx = Context(owner, sender, balance, metadata);

    // Trigger the smash
    piggy_smash_hacspec(ctx, PiggyBankStateHacspec::Smashed) == PiggySmashResult::Err(SmashError::AlreadySmashed)
}

#[cfg(not(feature = "hacspec"))]
// Unit tests for the smart contract "PiggyBank"
#[concordium_cfg_test]
mod tests {
    use super::*;
    // Pulling in the testing utils found in concordium_std.
    use test_infrastructure::*;

    // Running the initialization ensuring nothing fails and the state of the
    // piggy bank is intact.
    #[concordium_test]
    fn test_init() {
        // Setup
        let ctx = InitContextTest::empty();

        // Call the init function
        let state_result = piggy_init(&ctx);

        // Inspect the result
        let state = state_result.expect_report("Contract initialization failed.");

        claim_eq!(
            state,
            PiggyBankState::Intact,
            "Piggy bank state should be intact after initialization."
        );
    }

    #[concordium_test]
    fn test_insert_intact() {
        // Setup
        let ctx = ReceiveContextTest::empty();
        let amount = Amount::from_micro_ccd(100);
        let mut state = PiggyBankState::Intact;

        // Trigger the insert
        let actions_result: ReceiveResult<ActionsTree> = piggy_insert(&ctx, amount, &mut state);

        // Inspect the result
        let actions = actions_result.expect_report("Inserting GTU results in error.");

        claim_eq!(
            actions,
            ActionsTree::accept(),
            "No action should be produced."
        );
        claim_eq!(
            state,
            PiggyBankState::Intact,
            "Piggy bank state should still be intact."
        );
    }

    #[concordium_test]
    fn test_insert_smashed() {
        // Setup
        let ctx = ReceiveContextTest::empty();
        let amount = Amount::from_micro_ccd(100);
        let mut state = PiggyBankState::Smashed;

        // Trigger the insert
        let actions_result: ReceiveResult<ActionsTree> = piggy_insert(&ctx, amount, &mut state);

        // Inspect the result
        claim!(
            actions_result.is_err(),
            "Should failed when piggy bank is smashed."
        );
    }

    #[concordium_test]
    fn test_smash_intact() {
        // Setup the context

        let mut ctx = ReceiveContextTest::empty();
        let owner = AccountAddress([0u8; 32]);
        ctx.set_owner(owner);
        let sender = Address::Account(owner);
        ctx.set_sender(sender);
        let balance = Amount::from_micro_ccd(100);
        ctx.set_self_balance(balance);

        let mut state = PiggyBankState::Intact;

        // Trigger the smash
        let actions_result: Result<ActionsTree, _> = piggy_smash(&ctx, &mut state);

        // Inspect the result
        let actions = actions_result.expect_report("Inserting GTU results in error.");
        claim_eq!(actions, ActionsTree::simple_transfer(&owner, balance));
        claim_eq!(state, PiggyBankState::Smashed);
    }

    #[concordium_test]
    fn test_smash_intact_not_owner() {
        // Setup the context

        let mut ctx = ReceiveContextTest::empty();
        let owner = AccountAddress([0u8; 32]);
        ctx.set_owner(owner);
        let sender = Address::Account(AccountAddress([1u8; 32]));
        ctx.set_sender(sender);
        let balance = Amount::from_micro_ccd(100);
        ctx.set_self_balance(balance);

        let mut state = PiggyBankState::Intact;

        // Trigger the smash
        let actions_result: Result<ActionsTree, _> = piggy_smash(&ctx, &mut state);

        let err = actions_result.expect_err_report("Contract is expected to fail.");
        claim_eq!(
            err,
            SmashError::NotOwner,
            "Expected to fail with error NotOwner"
        )
    }

    #[concordium_test]
    fn test_smash_smashed() {
        // Setup the context
        let mut ctx = ReceiveContextTest::empty();
        let owner = AccountAddress([0u8; 32]);
        ctx.set_owner(owner);
        let sender = Address::Account(owner);
        ctx.set_sender(sender);
        let balance = Amount::from_micro_ccd(100);
        ctx.set_self_balance(balance);

        let mut state = PiggyBankState::Smashed;

        // Trigger the smash
        let actions_result: Result<ActionsTree, _> = piggy_smash(&ctx, &mut state);

        let err = actions_result.expect_err_report("Contract is expected to fail.");
        claim_eq!(
            err,
            SmashError::AlreadySmashed,
            "Expected  to fail with error AlreadySmashed"
        )
    }
}
#+end_src

** Generation of backend output

#+begin_src elisp :var SOURCE-CODE-FILE="Hacspec_Piggybank.v" :results output silent :tangle no
(org-babel-detangle SOURCE-CODE-FILE)
#+end_src

*** piggybank - Coq code
:PROPERTIES:
:header-args: coq :tangle Hacspec_Piggybank.v :mkdirp yes  :comments link
:header-args: coq :eval never :results output silent
:END:

#+begin_src coq

(** This file was automatically generated using Hacspec **)
Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
From Coq Require Import List.
Import ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.
From QuickChick Require Import QuickChick.
Require Import QuickChickLib.

From ConCert.Utils Require Import Extras.
From ConCert.Utils Require Import Automation.
From ConCert.Execution Require Import Serializable.
From ConCert.Execution Require Import Blockchain.
From ConCert.Execution Require Import ContractCommon.
From Coq Require Import Morphisms ZArith Basics.
Open Scope Z.
Set Nonrecursive Elimination Schemes.
#+end_src

#+begin_src coq
Require Import Hacspec_Lib.
Export Hacspec_Lib.
#+end_src

#+begin_src coq
Require Import Hacspec_Concordium.
Export Hacspec_Concordium.
#+end_src

#+begin_src coq
Require Import Concert_Lib.
Export Concert_Lib.
#+end_src

#+begin_src coq
Inductive piggy_bank_state_hacspec_t :=
| Intact : piggy_bank_state_hacspec_t
| Smashed : piggy_bank_state_hacspec_t.
Global Instance serializable_piggy_bank_state_hacspec_t : Serializable piggy_bank_state_hacspec_t :=
  Derive Serializable piggy_bank_state_hacspec_t_rect<Intact,Smashed>.

Definition eqb_piggy_bank_state_hacspec_t (x y : piggy_bank_state_hacspec_t) : bool :=
match x with
   | Intact => match y with | Intact=> true | _ => false end
   | Smashed => match y with | Smashed=> true | _ => false end
   end.

Definition eqb_leibniz_piggy_bank_state_hacspec_t (x y : piggy_bank_state_hacspec_t) : eqb_piggy_bank_state_hacspec_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_piggy_bank_state_hacspec_t : EqDec (piggy_bank_state_hacspec_t) :=
  Build_EqDec (piggy_bank_state_hacspec_t) (eqb_piggy_bank_state_hacspec_t) (eqb_leibniz_piggy_bank_state_hacspec_t).

Global Instance show_piggy_bank_state_hacspec_t : Show (piggy_bank_state_hacspec_t) :=
 @Build_Show (piggy_bank_state_hacspec_t) (fun x =>
 match x with
 Intact => ("Intact")%string
 | Smashed => ("Smashed")%string
 end).
Definition g_piggy_bank_state_hacspec_t : G (piggy_bank_state_hacspec_t) := oneOf_ (returnGen Intact) [returnGen Intact;returnGen Smashed].
Global Instance gen_piggy_bank_state_hacspec_t : Gen (piggy_bank_state_hacspec_t) := Build_Gen piggy_bank_state_hacspec_t g_piggy_bank_state_hacspec_t.
#+end_src

#+begin_src coq
Notation "'context_state_hacspec_t'" := ((
    context_t ∏
    piggy_bank_state_hacspec_t
  )) : hacspec_scope.
Instance show_context_state_hacspec_t : Show (context_state_hacspec_t) :=
Build_Show context_state_hacspec_t (fun x =>
  let (x, x0) := x in
  (("(") ++ ((show x) ++ ((",") ++ ((show x0) ++ (")"))))))%string.
Definition g_context_state_hacspec_t : G (context_state_hacspec_t) :=
bindGen arbitrary (fun x0 : context_t =>
  bindGen arbitrary (fun x1 : piggy_bank_state_hacspec_t =>
  returnGen (x0,x1))).
Instance gen_context_state_hacspec_t : Gen (context_state_hacspec_t) := Build_Gen context_state_hacspec_t g_context_state_hacspec_t.
#+end_src

#+begin_src coq
Definition piggy_init_hacspec : piggy_bank_state_hacspec_t :=
  Intact.
#+end_src

#+begin_src coq
Definition piggy_init (ctx_0 : context_t): context_state_hacspec_t :=
  (ctx_0, piggy_init_hacspec ).
Definition State := context_state_hacspec_t.
  Definition Setup := unit.
  Definition PiggyBank_State (chain : Chain) (ctx : ContractCallContext) (setup : Setup) : option State :=
  Some (piggy_init (Context (ctx.(ctx_from), ctx.(ctx_origin), repr ctx.(ctx_amount), 0 (* TODO *)))).
#+end_src

#+begin_src coq
Notation "'piggy_insert_result_t'" := ((result unit unit)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition piggy_insert_hacspec
  (ctx_1 : context_t)
  (amount_2 : int64)
  (state_3 : piggy_bank_state_hacspec_t): piggy_insert_result_t :=
  match state_3 with
  | Intact => @Ok unit unit (tt)
  | Smashed => @Err unit unit (tt)
  end.
#+end_src

#+begin_src coq
Definition piggy_insert
  (ctx_state_4 : context_state_hacspec_t)
  (amount_5 : int64): (option (context_state_hacspec_t ∏ list_action_t)) :=
  let '(ctx_6, state_7) :=
    ctx_state_4 in 
  let 'Context ((a_8, c_9, balance_10, d_11)) :=
    ctx_6 in 
  let _ : int32 :=
    accept_hacspec  in 
  let temp_12 : (result unit unit) :=
    piggy_insert_hacspec (ctx_6) (amount_5) (state_7) in 
  bind (match temp_12 with
    | Ok _ => @Some unit (tt)
    | Err _ => @None unit
    end) (fun _ =>  let s_13 : seq has_action_t :=
      seq_new_ (default) (usize 0) in 
    let s_13 :=
      seq_upd s_13 (usize 0) (accept_action ) in 
    @Some (context_state_hacspec_t ∏ list_action_t) ((
	(Context ((a_8, c_9, (balance_10) .+ (amount_5), d_11)), state_7),
	s_13
      ))).

Definition insert (amount : int64)(st : State) :=
  piggy_insert st amount.
#+end_src

#+begin_src coq
Inductive smash_error_t :=
| NotOwner : smash_error_t
| AlreadySmashed : smash_error_t.
Global Instance serializable_smash_error_t : Serializable smash_error_t :=
  Derive Serializable smash_error_t_rect<NotOwner,AlreadySmashed>.

Definition eqb_smash_error_t (x y : smash_error_t) : bool :=
match x with
   | NotOwner => match y with | NotOwner=> true | _ => false end
   | AlreadySmashed => match y with | AlreadySmashed=> true | _ => false end
   end.

Definition eqb_leibniz_smash_error_t (x y : smash_error_t) : eqb_smash_error_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_smash_error_t : EqDec (smash_error_t) :=
  Build_EqDec (smash_error_t) (eqb_smash_error_t) (eqb_leibniz_smash_error_t).

Global Instance show_smash_error_t : Show (smash_error_t) :=
 @Build_Show (smash_error_t) (fun x =>
 match x with
 NotOwner => ("NotOwner")%string
 | AlreadySmashed => ("AlreadySmashed")%string
 end).
Definition g_smash_error_t : G (smash_error_t) := oneOf_ (returnGen NotOwner) [returnGen NotOwner;returnGen AlreadySmashed].
Global Instance gen_smash_error_t : Gen (smash_error_t) := Build_Gen smash_error_t g_smash_error_t.
#+end_src

#+begin_src coq
Notation "'piggy_smash_result_t'" := ((
    result piggy_bank_state_hacspec_t smash_error_t)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition piggy_smash_hacspec
  (ctx_14 : context_t)
  (state_15 : piggy_bank_state_hacspec_t): piggy_smash_result_t :=
  let 'Context ((owner_16, sender_17, balance_18, metadata_19)) :=
    ctx_14 in 
  ifbnd negb ((owner_16) array_eq (sender_17)) : bool
  thenbnd (bind (@Err piggy_bank_state_hacspec_t smash_error_t (NotOwner)) (
      fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  ifbnd negb ((state_15) =.? (Intact)) : bool
  thenbnd (bind (@Err piggy_bank_state_hacspec_t smash_error_t (
	AlreadySmashed)) (fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  @Ok piggy_bank_state_hacspec_t smash_error_t (Smashed))).
#+end_src

#+begin_src coq
Definition piggy_smash
  (ctx_state_20 : context_state_hacspec_t): (option (
      context_state_hacspec_t ∏
      list_action_t
    )) :=
  let '(ctx_21, state_22) :=
    ctx_state_20 in 
  let 'Context ((a_23, c_24, balance_25, d_26)) :=
    ctx_21 in 
  let _ : int32 :=
    accept_hacspec  in 
  let smash_27 : (result piggy_bank_state_hacspec_t smash_error_t) :=
    piggy_smash_hacspec (ctx_21) (state_22) in 
  bind (match smash_27 with
    | Ok a_28 => @Some piggy_bank_state_hacspec_t (a_28)
    | Err b_29 => @None piggy_bank_state_hacspec_t
    end) (fun new_state_30 =>  let s_31 : seq has_action_t :=
      seq_new_ (default) (usize 1) in 
    @Some (context_state_hacspec_t ∏ list_action_t) ((
	(Context ((a_23, c_24, @repr WORDSIZE64 0, d_26)), new_state_30),
	s_31
      ))).

Definition smash (st : State) :=
  piggy_smash st.
#+end_src

#+begin_src coq
Definition test_init_hacspec : bool :=
  (piggy_init_hacspec ) =.? (Intact).
#+end_src

#+begin_src coq
Definition test_insert_intact (ctx_32 : context_t) (amount_33 : int64): bool :=
  (piggy_insert_hacspec (ctx_32) (amount_33) (Intact)) =.? (@Ok unit unit (tt)).

QuickChick (forAll g_context_t (fun ctx_32 : context_t =>
  forAll g_int64 (fun amount_33 : int64 =>
  test_insert_intact ctx_32 amount_33))).
#+end_src

#+begin_src coq
Definition test_insert_smashed (ctx_34 : context_t) (amount_35 : int64): bool :=
  (piggy_insert_hacspec (ctx_34) (amount_35) (Smashed)) =.? (@Err unit unit (
      tt)).

QuickChick (forAll g_context_t (fun ctx_34 : context_t =>
  forAll g_int64 (fun amount_35 : int64 =>
  test_insert_smashed ctx_34 amount_35))).
#+end_src

#+begin_src coq
Definition test_smash_intact
  (owner_36 : user_address_t)
  (balance_37 : int64)
  (metadata_38 : int64): bool :=
  let sender_39 : user_address_t :=
    owner_36 in 
  let ctx_40 : context_t :=
    Context ((owner_36, sender_39, balance_37, metadata_38)) in 
  (piggy_smash_hacspec (ctx_40) (Intact)) =.? (
    @Ok piggy_bank_state_hacspec_t smash_error_t (Smashed)).

QuickChick (forAll g_user_address_t (fun owner_36 : user_address_t =>
  forAll g_int64 (fun balance_37 : int64 =>
  forAll g_int64 (fun metadata_38 : int64 =>
  test_smash_intact owner_36 balance_37 metadata_38)))).
#+end_src

#+begin_src coq
Definition test_smash_intact_not_owner
  (owner_41 : user_address_t)
  (sender_42 : user_address_t)
  (balance_43 : int64)
  (metadata_44 : int64): bool :=
  let ctx_45 : context_t :=
    Context ((owner_41, sender_42, balance_43, metadata_44)) in 
  ((owner_41) array_eq (sender_42)) || ((piggy_smash_hacspec (ctx_45) (
	Intact)) =.? (@Err piggy_bank_state_hacspec_t smash_error_t (
	NotOwner))).

QuickChick (forAll g_user_address_t (fun owner_41 : user_address_t =>
  forAll g_user_address_t (fun sender_42 : user_address_t =>
  forAll g_int64 (fun balance_43 : int64 =>
  forAll g_int64 (fun metadata_44 : int64 =>
  test_smash_intact_not_owner owner_41 sender_42 balance_43 metadata_44))))).
#+end_src

#+begin_src coq
Definition test_smash_smashed
  (owner_46 : user_address_t)
  (balance_47 : int64)
  (metadata_48 : int64): bool :=
  let sender_49 : user_address_t :=
    owner_46 in 
  let ctx_50 : context_t :=
    Context ((owner_46, sender_49, balance_47, metadata_48)) in 
  (piggy_smash_hacspec (ctx_50) (Smashed)) =.? (
    @Err piggy_bank_state_hacspec_t smash_error_t (AlreadySmashed)).

QuickChick (forAll g_user_address_t (fun owner_46 : user_address_t =>
  forAll g_int64 (fun balance_47 : int64 =>
  forAll g_int64 (fun metadata_48 : int64 =>
  test_smash_smashed owner_46 balance_47 metadata_48)))).
#+end_src

#+begin_src coq
Inductive Msg :=
| INSERT
| SMASH.
Global Instance Msg_serializable : Serializable Msg :=
  Derive Serializable Msg_rect<INSERT,SMASH>.
Definition PiggyBank_receive (chain : Chain) (ctx : ContractCallContext) (state : State) (msg : option Msg) : option (State * list ActionBody) :=
  match msg with
  | Some INSERT => to_action_body_list ctx (
    insert (repr ctx.(ctx_amount)) state)
  | Some SMASH => to_action_body_list ctx (smash state)
  | None => None
  end.

Definition PiggyBank_contract : Contract Setup Msg State :=
  build_contract PiggyBank_State PiggyBank_receive.
#+end_src
# 22 code sections
