#+TITLE: Piggybank Smartcontract
#+AUTHOR: Lasse Letager Hansen

# Use org-tanglesync !
# lentic

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file
# C-c C-v s   -  create results / run subtree

* General information
:PROPERTIES:
:header-args: sh :eval never :results output silent
:END:
** Resulting output
#+begin_src sh
cargo clean
#+end_src

#+begin_src sh
cargo install --path language
#+end_src

#+begin_src sh
cargo build
#+end_src

#+begin_src sh
cargo hacspec -e v --dir coq/src/ hacspec-piggybank --vc-init --org-file piggybank.org
#+end_src

#+begin_src sh
cargo hacspec -e v --dir coq/src/ hacspec-piggybank --vc-update --org-file piggybank.org
#+end_src

* Piggybank smart contract specification
** Config
#+begin_src toml :tangle ../../examples/piggybank/Cargo.toml :mkdirp yes :eval never
[package]
name = "hacspec-piggybank"
version = "0.1.0"
authors = [""]
edition = "2018"

[lib]
path = "src/piggybank.rs"

[dependencies]
hacspec-lib = { path = "../../lib" }
# pearlite-syn = { path = "../../../../creusot/pearlite-syn" }
creusot-contracts = { git = "https://github.com/xldenis/creusot", rev = "7763b3ae77205fba83182b9a6c3e69ad0b12fec7" }
# hacspec = {optional = true}
concordium-contracts-common = { path = "../../../../concordium-rust-smart-contracts/concordium-contracts-common" }
hacspec-concordium = { path = "../concordium" }
hacspec-concordium-derive = { path = "../concordium-derive" }

[features]
hacspec = []

[dev-dependencies]
hacspec-dev = { path = "../../utils/dev" }
criterion = "0.3"
rand = "0.8"
quickcheck = "1"
quickcheck_macros = "1"
#+end_src

** Rust code
:PROPERTIES:
:header-args: rust :tangle ../../examples/piggybank/src/piggybank.rs :mkdirp yes :eval never
:END:

*** Imports
#+begin_src rust
#[cfg(not(feature = "hacspec"))]
extern crate hacspec_lib;

use hacspec_lib::*;

#[cfg(not(feature = "hacspec"))]
extern crate creusot_contracts;
#[cfg(not(feature = "hacspec"))]
use creusot_contracts::{ensures, requires};
#+end_src

#+begin_src rust
use hacspec_concordium::*;
#+end_src

#+begin_src rust
#[cfg(feature = "hacspec")]
use concert_lib::*;
#+end_src

#+begin_src rust
#[cfg(not(feature = "hacspec"))]
/// The state of the piggy bank
#[derive(Debug, Serialize, PartialEq, Eq)]
enum PiggyBankState {
    /// Alive and well, allows for GTU to be inserted.
    Intact,
    /// The piggy bank has been emptied, preventing further GTU to be inserted.
    Smashed,
}

/// The state of the piggy bank
#[derive(Debug, PartialEq, Eq)] // , Serialize
pub enum PiggyBankStateHacspec {
    /// Alive and well, allows for GTU to be inserted.
    Intact,
    /// The piggy bank has been emptied, preventing further GTU to be inserted.
    Smashed,
}

#[cfg(not(feature = "hacspec"))]
fn coerce_hacspec_to_rust_piggybank_state(pbs : PiggyBankStateHacspec) -> PiggyBankState {
    match pbs {
        PiggyBankStateHacspec::Intact  => PiggyBankState::Intact,
        PiggyBankStateHacspec::Smashed => PiggyBankState::Smashed,
    }
}


#[cfg(not(feature = "hacspec"))]
fn coerce_rust_to_hacspec_piggybank_state(pbs : &PiggyBankState) -> PiggyBankStateHacspec {
    match pbs {
        PiggyBankState::Intact  => PiggyBankStateHacspec::Intact,
        PiggyBankState::Smashed => PiggyBankStateHacspec::Smashed,
    }
}
#+end_src

#+begin_src rust
array!(UserAddress, 32, u8);

pub struct Context(pub UserAddress, pub UserAddress, pub u64, pub u64);
pub type ContextStateHacspec = (Context, PiggyBankStateHacspec);
#+end_src

#+begin_src rust
pub fn piggy_init_hacspec() -> PiggyBankStateHacspec {
    // Always succeeds
    PiggyBankStateHacspec::Intact
}
#+end_src

#+begin_src rust
#[cfg(feature = "hacspec")]
#[init(contract = "PiggyBank")]
pub fn piggy_init(ctx : Context) -> ContextStateHacspec { // , actions
    // Always succeeds
    (ctx, piggy_init_hacspec())
}
#+end_src

#+begin_src rust
#[cfg(not(feature = "hacspec"))]
/// Setup a new Intact piggy bank.
#[init(contract = "PiggyBank")]
fn piggy_init(_ctx: &impl HasInitContext) -> InitResult<PiggyBankState> {
    // Always succeeds
    Ok(coerce_hacspec_to_rust_piggybank_state(piggy_init_hacspec()))
}
#+end_src

#+begin_src rust
#[cfg(not(feature = "hacspec"))]
fn coerce_rust_to_hacspec_account_address(aa: &AccountAddress) -> UserAddress {
    UserAddress::from_native_slice(&aa.0)
}
#+end_src

#+begin_src rust
pub type PiggyInsertResult = Result<(), ()>;

pub fn piggy_insert_hacspec(ctx: Context, amount: u64, state: PiggyBankStateHacspec) -> PiggyInsertResult {
    // Ensure the piggy bank has not been smashed already.
    match state {
        PiggyBankStateHacspec::Intact => PiggyInsertResult::Ok(()),
        PiggyBankStateHacspec::Smashed => PiggyInsertResult::Err(()),
    }
}

#[cfg(feature = "hacspec")]
#[receive(contract = "PiggyBank", name = "insert", payable)]
pub fn piggy_insert(ctx_state: ContextStateHacspec, amount: u64) -> Option<(ContextStateHacspec, ListAction)> {
    let (ctx, state) = ctx_state;
    let Context(a, c, balance, d) = ctx;
    accept_hacspec();
    let temp = piggy_insert_hacspec(ctx, amount, state);
    match temp {
        PiggyInsertResult::Ok(_) => Option::<()>::Some(()),
        PiggyInsertResult::Err(_) => Option::<()>::None
    }?;
    let s = Seq::<HasAction>::new(0);
    s[0] = accept_action();
    Option::<(ContextStateHacspec, ListAction)>::Some (((Context(a, c, balance + amount, d), state), s))
}

#[cfg(not(feature = "hacspec"))]
/// Insert some GTU into a piggy bank, allowed by anyone.
#[receive(contract = "PiggyBank", name = "insert", payable)]
fn piggy_insert<A: HasActions>(
    ctx: &impl HasReceiveContext,
    amount: Amount,
    state: &mut PiggyBankState,
) -> ReceiveResult<A> {
    let ctx_hacspec = coerce_rust_to_hacspec_context(ctx)?;
    // Ensure the piggy bank has not been smashed already.
    piggy_insert_hacspec(ctx_hacspec, amount.micro_ccd, coerce_rust_to_hacspec_piggybank_state(state))?;
    // Just accept since the GTU balance is managed by the chain.
    Ok(A::accept())
}

// #[cfg(not(feature = "hacspec"))]
#[derive(Debug, PartialEq, Eq, Reject)]
enum SmashError {
    NotOwner,
    AlreadySmashed,
}

#[cfg(not(feature = "hacspec"))]
fn coerce_rust_to_hacspec_context(ctx: &impl HasReceiveContext) -> Result<Context, SmashError> {
    Ok(Context(
        coerce_rust_to_hacspec_account_address(&ctx.owner()),
        coerce_rust_to_hacspec_account_address(
            &(match ctx.sender() {
                Address::Account(a) => Ok(a),
                _ => Err(SmashError::NotOwner),
            }?),
        ),
        match ctx.self_balance() {
            Amount { micro_ccd } => micro_ccd,
        },
        0u64
    ))
}

type PiggySmashResult = Result<PiggyBankStateHacspec, SmashError>;

fn piggy_smash_hacspec(ctx: Context, state: PiggyBankStateHacspec) -> PiggySmashResult {
    // Get the contract owner, i.e. the account who initialized the contract.
    let Context(owner, sender, _balance, _metadata) = ctx;

    if !(owner == sender) {
        PiggySmashResult::Err(SmashError::NotOwner)?;
    }

    if !(state == PiggyBankStateHacspec::Intact) {
        PiggySmashResult::Err(SmashError::AlreadySmashed)?;
    }

    PiggySmashResult::Ok(PiggyBankStateHacspec::Smashed)
}

#[cfg(feature = "hacspec")]
#[receive(contract = "PiggyBank", name = "smash")]
fn piggy_smash(ctx_state: ContextStateHacspec) -> Option<(ContextStateHacspec, ListAction)> {
    let (ctx, state) = ctx_state;
    let Context(a, c, balance, d) = ctx;
    accept_hacspec();
    let smash = piggy_smash_hacspec(ctx, state);
    let new_state = match smash {
        PiggySmashResult::Ok(a) => Option::<PiggyBankStateHacspec>::Some(a),
        PiggySmashResult::Err(b) => Option::<PiggyBankStateHacspec>::None,
    }?;
    let s = Seq::<HasAction>::new(1);
    // s[0] = HasAction::SIMPLE_TRANSFER( a, balance );
    Option::<(ContextStateHacspec, ListAction)>::Some(((Context(a, c, 0u64, d), new_state), s))
    // piggy_smash_hacspec(ctx, state)
}

#[cfg(not(feature = "hacspec"))]
/// Smash a piggy bank retrieving the GTU, only allowed by the owner.
#[receive(contract = "PiggyBank", name = "smash")]
fn piggy_smash<A: HasActions>(
    ctx: &impl HasReceiveContext,
    state: &mut PiggyBankState,
) -> Result<A, SmashError> {
    let ctx_hacspec = coerce_rust_to_hacspec_context(ctx)?;

    ,*state = coerce_hacspec_to_rust_piggybank_state(
        match piggy_smash_hacspec(ctx_hacspec, coerce_rust_to_hacspec_piggybank_state(state)) {
            Ok(a) => a,
            Err(e) => return Err(e),
        },
    );

    // Get the current balance of the smart contract.
    let balance = ctx.self_balance();
    // Result in a transfer of the whole balance to the contract owner.
    Ok(A::simple_transfer(&ctx.owner(), balance))
}

//Tests - type checker ignores #[cfg(test)] parts
#[cfg(test)]
extern crate quickcheck;
#[cfg(test)]
#[macro_use(quickcheck)]
extern crate quickcheck_macros;

#[cfg(test)]
use quickcheck::*;

// Running the initialization ensuring nothing fails and the state of the
// piggy bank is intact.
#[cfg(test)]
#[proof]
fn test_init_hacspec() -> bool {
    piggy_init_hacspec() == PiggyBankStateHacspec::Intact
}

#[cfg(test)]
#[quickcheck]
#[proof]
fn test_insert_intact(ctx: Context, amount: u64) -> bool {
    piggy_insert_hacspec(ctx, amount, PiggyBankStateHacspec::Intact) == PiggyInsertResult::Ok(())
}

#[cfg(test)]
#[quickcheck]
#[proof]
fn test_insert_smashed(ctx: Context, amount: u64) -> bool {
    piggy_insert_hacspec(ctx, amount, PiggyBankStateHacspec::Smashed) == PiggyInsertResult::Err(())
}

#[cfg(test)]
#[quickcheck]
#[proof]
fn test_smash_intact(owner : UserAddress, balance : u64, metadata: u64) -> bool {
    // Setup the context
    let sender = owner;
    let ctx = Context(owner, sender, balance, metadata);

    // Trigger the smash
    piggy_smash_hacspec(ctx, PiggyBankStateHacspec::Intact) == PiggySmashResult::Ok(PiggyBankStateHacspec::Smashed)
}

#[cfg(test)]
#[quickcheck]
#[proof]
fn test_smash_intact_not_owner(owner : UserAddress, sender : UserAddress, balance : u64, metadata: u64) -> bool{
    // Setup the contextt
    let ctx = Context(owner, sender, balance, metadata);

    // Trigger the smash
    // TODO: Generate pair of owner sender not equal (not a big issue)
    owner == sender || piggy_smash_hacspec(ctx, PiggyBankStateHacspec::Intact) == PiggySmashResult::Err(SmashError::NotOwner)
}

#[cfg(test)]
#[quickcheck]
#[proof]
fn test_smash_smashed(owner : UserAddress, balance : u64, metadata: u64) -> bool{
    // Setup the context
    let sender = owner;
    let ctx = Context(owner, sender, balance, metadata);

    // Trigger the smash
    piggy_smash_hacspec(ctx, PiggyBankStateHacspec::Smashed) == PiggySmashResult::Err(SmashError::AlreadySmashed)
}

#[cfg(not(feature = "hacspec"))]
// Unit tests for the smart contract "PiggyBank"
#[concordium_cfg_test]
mod tests {
    use super::*;
    // Pulling in the testing utils found in concordium_std.
    use test_infrastructure::*;

    // Running the initialization ensuring nothing fails and the state of the
    // piggy bank is intact.
    #[concordium_test]
    fn test_init() {
        // Setup
        let ctx = InitContextTest::empty();

        // Call the init function
        let state_result = piggy_init(&ctx);

        // Inspect the result
        let state = state_result.expect_report("Contract initialization failed.");

        claim_eq!(
            state,
            PiggyBankState::Intact,
            "Piggy bank state should be intact after initialization."
        );
    }

    #[concordium_test]
    fn test_insert_intact() {
        // Setup
        let ctx = ReceiveContextTest::empty();
        let amount = Amount::from_micro_ccd(100);
        let mut state = PiggyBankState::Intact;

        // Trigger the insert
        let actions_result: ReceiveResult<ActionsTree> = piggy_insert(&ctx, amount, &mut state);

        // Inspect the result
        let actions = actions_result.expect_report("Inserting GTU results in error.");

        claim_eq!(
            actions,
            ActionsTree::accept(),
            "No action should be produced."
        );
        claim_eq!(
            state,
            PiggyBankState::Intact,
            "Piggy bank state should still be intact."
        );
    }

    #[concordium_test]
    fn test_insert_smashed() {
        // Setup
        let ctx = ReceiveContextTest::empty();
        let amount = Amount::from_micro_ccd(100);
        let mut state = PiggyBankState::Smashed;

        // Trigger the insert
        let actions_result: ReceiveResult<ActionsTree> = piggy_insert(&ctx, amount, &mut state);

        // Inspect the result
        claim!(
            actions_result.is_err(),
            "Should failed when piggy bank is smashed."
        );
    }

    #[concordium_test]
    fn test_smash_intact() {
        // Setup the context

        let mut ctx = ReceiveContextTest::empty();
        let owner = AccountAddress([0u8; 32]);
        ctx.set_owner(owner);
        let sender = Address::Account(owner);
        ctx.set_sender(sender);
        let balance = Amount::from_micro_ccd(100);
        ctx.set_self_balance(balance);

        let mut state = PiggyBankState::Intact;

        // Trigger the smash
        let actions_result: Result<ActionsTree, _> = piggy_smash(&ctx, &mut state);

        // Inspect the result
        let actions = actions_result.expect_report("Inserting GTU results in error.");
        claim_eq!(actions, ActionsTree::simple_transfer(&owner, balance));
        claim_eq!(state, PiggyBankState::Smashed);
    }

    #[concordium_test]
    fn test_smash_intact_not_owner() {
        // Setup the context

        let mut ctx = ReceiveContextTest::empty();
        let owner = AccountAddress([0u8; 32]);
        ctx.set_owner(owner);
        let sender = Address::Account(AccountAddress([1u8; 32]));
        ctx.set_sender(sender);
        let balance = Amount::from_micro_ccd(100);
        ctx.set_self_balance(balance);

        let mut state = PiggyBankState::Intact;

        // Trigger the smash
        let actions_result: Result<ActionsTree, _> = piggy_smash(&ctx, &mut state);

        let err = actions_result.expect_err_report("Contract is expected to fail.");
        claim_eq!(
            err,
            SmashError::NotOwner,
            "Expected to fail with error NotOwner"
        )
    }

    #[concordium_test]
    fn test_smash_smashed() {
        // Setup the context
        let mut ctx = ReceiveContextTest::empty();
        let owner = AccountAddress([0u8; 32]);
        ctx.set_owner(owner);
        let sender = Address::Account(owner);
        ctx.set_sender(sender);
        let balance = Amount::from_micro_ccd(100);
        ctx.set_self_balance(balance);

        let mut state = PiggyBankState::Smashed;

        // Trigger the smash
        let actions_result: Result<ActionsTree, _> = piggy_smash(&ctx, &mut state);

        let err = actions_result.expect_err_report("Contract is expected to fail.");
        claim_eq!(
            err,
            SmashError::AlreadySmashed,
            "Expected  to fail with error AlreadySmashed"
        )
    }
}
#+end_src

** Generation of backend output

#+begin_src elisp :var SOURCE-CODE-FILE="Hacspec_Piggybank.v" :results output silent :tangle no
(org-babel-detangle SOURCE-CODE-FILE)
#+end_src

***  - Coq code
:PROPERTIES:
:header-args: coq :tangle Hacspec_Piggybank.v :mkdirp yes  :comments link
:header-args: coq :eval never :results output silent
:END:

#+begin_src coq
(** This file was automatically generated using Hacspec **)
Require Import Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.
From QuickChick Require Import QuickChick.
Require Import QuickChickLib.
#+end_src

#+begin_src coq
Require Import Hacspec.Lib.
#+end_src

#+begin_src coq
Require Import Hacspec.Concordium.
#+end_src

#+begin_src coq
Inductive piggy_bank_state_hacspec_t :=
| Intact : piggy_bank_state_hacspec_t
| Smashed : piggy_bank_state_hacspec_t.

Definition eqb_piggy_bank_state_hacspec_t (x y : piggy_bank_state_hacspec_t) : bool :=
match x with
   | Intact => match y with | Intact=> true | _ => false end
   | Smashed => match y with | Smashed=> true | _ => false end
   end.

Definition eqb_leibniz_piggy_bank_state_hacspec_t (x y : piggy_bank_state_hacspec_t) : eqb_piggy_bank_state_hacspec_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_piggy_bank_state_hacspec_t : EqDec (piggy_bank_state_hacspec_t) :=
Build_EqDec (piggy_bank_state_hacspec_t) (eqb_piggy_bank_state_hacspec_t) (eqb_leibniz_piggy_bank_state_hacspec_t).

Global Instance show_piggy_bank_state_hacspec_t : Show (piggy_bank_state_hacspec_t) :=
 @Build_Show (piggy_bank_state_hacspec_t) (fun x =>
 match x with
 Intact => ("Intact")%string
 | Smashed => ("Smashed")%string
 end).
Definition g_piggy_bank_state_hacspec_t : G (piggy_bank_state_hacspec_t) := oneOf_ (returnGen Intact) [returnGen Intact;returnGen Smashed].
Global Instance gen_piggy_bank_state_hacspec_t : Gen (piggy_bank_state_hacspec_t) := Build_Gen piggy_bank_state_hacspec_t g_piggy_bank_state_hacspec_t.
#+end_src

#+begin_src coq
Definition piggy_init_hacspec  : piggy_bank_state_hacspec_t :=
  Intact.
#+end_src

#+begin_src coq
Definition user_address_t := nseq (int8) (usize 32).
Instance show_user_address_t : Show (user_address_t) := Build_Show (user_address_t) show.
Definition g_user_address_t : G (user_address_t) := arbitrary.
Instance gen_user_address_t : Gen (user_address_t) := Build_Gen user_address_t g_user_address_t.
#+end_src

#+begin_src coq
Notation "'piggy_insert_result_t'" := ((result unit unit)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition piggy_insert_hacspec
  (state_0 : piggy_bank_state_hacspec_t)
  : piggy_insert_result_t :=
  match state_0 with
  | Intact => @Ok unit unit (tt)
  | Smashed => @Err unit unit (tt)
  end.
#+end_src

#+begin_src coq
Notation "'context_t'" := ((user_address_t × user_address_t × int64
)) : hacspec_scope.
Instance show_context_t : Show (context_t) :=
Build_Show context_t (fun x =>
  let (x, x0) := x in
  let (x, x1) := x in
  (
    ("(") ++ ((show x) ++ ((",") ++ ((show x0) ++ ((",") ++ ((show x1) ++ (")"))))))))%string.
Definition g_context_t : G (context_t) :=
bindGen arbitrary (fun x0 : user_address_t =>
  bindGen arbitrary (fun x1 : user_address_t =>
  bindGen arbitrary (fun x2 : int64 =>
  returnGen (x0,x1,x2)))).
Instance gen_context_t : Gen (context_t) := Build_Gen context_t g_context_t.
#+end_src

#+begin_src coq
Inductive smash_error_t :=
| NotOwner : smash_error_t
| AlreadySmashed : smash_error_t.

Definition eqb_smash_error_t (x y : smash_error_t) : bool :=
match x with
   | NotOwner => match y with | NotOwner=> true | _ => false end
   | AlreadySmashed => match y with | AlreadySmashed=> true | _ => false end
   end.

Definition eqb_leibniz_smash_error_t (x y : smash_error_t) : eqb_smash_error_t x y = true <-> x = y.
Proof. split. intros; destruct x ; destruct y ; try (f_equal ; apply eqb_leibniz) ; easy. intros ; subst ; destruct y ; try reflexivity ; try (apply eqb_refl). Qed.

Instance eq_dec_smash_error_t : EqDec (smash_error_t) :=
Build_EqDec (smash_error_t) (eqb_smash_error_t) (eqb_leibniz_smash_error_t).

Global Instance show_smash_error_t : Show (smash_error_t) :=
 @Build_Show (smash_error_t) (fun x =>
 match x with
 NotOwner => ("NotOwner")%string
 | AlreadySmashed => ("AlreadySmashed")%string
 end).
Definition g_smash_error_t : G (smash_error_t) := oneOf_ (returnGen NotOwner) [returnGen NotOwner;returnGen AlreadySmashed].
Global Instance gen_smash_error_t : Gen (smash_error_t) := Build_Gen smash_error_t g_smash_error_t.
#+end_src

#+begin_src coq
Notation "'piggy_smash_result_t'" := ((
  result piggy_bank_state_hacspec_t smash_error_t)) : hacspec_scope.
#+end_src

#+begin_src coq
Definition piggy_smash_hacspec
  (ctx_1 : context_t)
  (state_2 : piggy_bank_state_hacspec_t)
  : piggy_smash_result_t :=
  let '(owner_3, sender_4, balance_5) :=
    ctx_1 in
  ifbnd negb ((owner_3) array_eq (sender_4)) : bool
  thenbnd (bind (@Err piggy_bank_state_hacspec_t smash_error_t (NotOwner)) (
      fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  ifbnd negb ((state_2) =.? (Intact)) : bool
  thenbnd (bind (@Err piggy_bank_state_hacspec_t smash_error_t (
	AlreadySmashed)) (fun _ =>  Ok (tt)))
  else (tt) >> (fun 'tt =>
  @Ok piggy_bank_state_hacspec_t smash_error_t (Smashed))).
#+end_src

#+begin_src coq
Definition test_init_hacspec  : bool :=
  (piggy_init_hacspec ) =.? (Intact).
#+end_src

#+begin_src coq
Definition test_insert_intact  : bool :=
  (piggy_insert_hacspec (Intact)) =.? (@Ok unit unit (tt)).
#+end_src

#+begin_src coq
Definition test_insert_smashed  : bool :=
  (piggy_insert_hacspec (Smashed)) =.? (@Err unit unit (tt)).
#+end_src

#+begin_src coq
Definition test_smash_intact
  (owner_6 : user_address_t)
  (balance_7 : int64)
  : bool :=
  let sender_8 : user_address_t :=
    owner_6 in
  let ctx_9 : (user_address_t × user_address_t × int64) :=
    (owner_6, sender_8, balance_7) in
  (piggy_smash_hacspec (ctx_9) (Intact)) =.? (
    @Ok piggy_bank_state_hacspec_t smash_error_t (Smashed)).
QuickChick (
  forAll g_user_address_t (fun owner_6 : user_address_t => forAll g_int64 (fun balance_7 : int64 => test_smash_intact owner_6 balance_7))).
#+end_src

#+begin_src coq
Definition test_smash_intact_not_owner
  (owner_10 : user_address_t)
  (sender_11 : user_address_t)
  (balance_12 : int64)
  : bool :=
  let ctx_13 : (user_address_t × user_address_t × int64) :=
    (owner_10, sender_11, balance_12) in
  ((owner_10) array_eq (sender_11)) || ((piggy_smash_hacspec (ctx_13) (
	Intact)) =.? (@Err piggy_bank_state_hacspec_t smash_error_t (
	NotOwner))).
QuickChick (
  forAll g_user_address_t (fun owner_10 : user_address_t => forAll g_user_address_t (fun sender_11 : user_address_t => forAll g_int64 (fun balance_12 : int64 => test_smash_intact_not_owner owner_10 sender_11 balance_12)))).
#+end_src

#+begin_src coq
Definition test_smash_smashed
  (owner_14 : user_address_t)
  (balance_15 : int64)
  : bool :=
  let sender_16 : user_address_t :=
    owner_14 in
  let ctx_17 : (user_address_t × user_address_t × int64) :=
    (owner_14, sender_16, balance_15) in
  (piggy_smash_hacspec (ctx_17) (Smashed)) =.? (
    @Err piggy_bank_state_hacspec_t smash_error_t (AlreadySmashed)).
QuickChick (
  forAll g_user_address_t (fun owner_14 : user_address_t => forAll g_int64 (fun balance_15 : int64 => test_smash_smashed owner_14 balance_15))).
#+end_src
