#+TITLE: Fib Smartcontract
#+AUTHOR: Lasse Letager Hansen

# Use org-tanglesync !
# lentic

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file
# C-c C-v s   -  create results / run subtree

* General information
:PROPERTIES:
:header-args: sh :eval never :results output silent
:END:
** Resulting output
#+begin_src sh
  cargo clean
#+end_src

#+begin_src sh
  cargo install --path language
#+end_src

#+begin_src sh
  cargo build
#+end_src

#+begin_src sh
  cargo hacspec -o coq/src/Fib.v hacspec-fib --init --org-file fib.org
#+end_src

#+begin_src sh
  cargo hacspec -o coq/src/Fib.v hacspec-fib --update --org-file fib.org
#+end_src

* Fib smart contract specification
** Config
#+begin_src toml :tangle ../../examples/fib/Cargo.toml :eval never
[package]
name = "hacspec-fib"
version = "0.1.0"
authors = [""]
edition = "2018"

[lib]
path = "src/fib.rs"

[dependencies]
hacspec-lib = { path = "../../lib" }
hacspec-attributes = { path = "../../utils/attributes", version = "0.1.0-beta.1" , features = ["print_attributes"] } # , features = ["hacspec_unsafe"] , , optional = true
# pearlite-syn = { path = "../../../../creusot/pearlite-syn" }
creusot-contracts = { path = "../../../../creusot/creusot-contracts" }
# hacspec = {optional = true}
concordium-contracts-common = { path = "../../../../concordium-rust-smart-contracts/concordium-contracts-common" }
hacspec-concordium = { path = "../concordium" }
hacspec-concordium-derive = { path = "../concordium-derive" }

[features]
hacspec = []
# use_attributes = ["hacspec-attributes", "hacspec-attributes/print_attributes"]

[dev-dependencies]
hacspec-dev = { path = "../../utils/dev" }
criterion = "0.3"
rand = "0.8"
quickcheck = "1"
quickcheck_macros = "1"
#+end_src

** Rust code
:PROPERTIES:
:header-args: rust :tangle ../../examples/fib/src/fib.rs :eval never
:END:

*** Imports
#+begin_src rust
#[cfg(not(feature = "hacspec"))]
extern crate hacspec_lib;

use hacspec_lib::*;

// #[cfg(feature = "hacspec_attributes")]
#[cfg(feature = "hacspec")]
use hacspec_attributes::*;
// #[cfg(not(feature = "hacspec"))]
#[cfg(test)]
use hacspec_attributes::proof;

#[cfg(test)]
#[cfg(not(feature = "hacspec"))]
use creusot_contracts::{ensures, requires};
#+end_src

#+begin_src rust
use hacspec_concordium::*;
#+end_src

#+begin_src rust
#[cfg(not(feature = "hacspec"))]
#[derive(Serialize, SchemaType)]
pub struct State {
    result: u64,
}

pub type StateHacspec = u64;

#[cfg(not(feature = "hacspec"))]
pub fn coerce_hacspec_to_rust_state(st: StateHacspec) -> State {
    State { result: st }
}

#[cfg(not(feature = "hacspec"))]
pub fn coerce_rust_to_hacspec_state(st: State) -> StateHacspec {
    st.result
}

fn contract_init_hacspec() -> StateHacspec {
    0u64
}

#[cfg(not(feature = "hacspec"))]
#[init(contract = "fib")]
#[inline(always)]
fn contract_init(_ctx: &impl HasInitContext) -> InitResult<((), State)> {
    let state = coerce_hacspec_to_rust_state(contract_init_hacspec());
    Ok(((), state))
}

pub enum Action {
    Start(u64),
    Continuation0(u64, u64),
    Continuation1(u64, u64),
    Value(u64),
}

fn contract_receive_hacspec(action: Action) -> Action {
    match action {
        Action::Start(n) => {
            if n <= 1u64 {
                Action::Value(1u64)
            } else {
                Action::Continuation0(n, n - 2u64)
            }
        }
        Action::Continuation0(n, p) => Action::Continuation1(p, n - 1u64),
        Action::Continuation1(p, q) => Action::Value(p + q),
        Action::Value(v) => Action::Value(v), // TODO: Should never happen ! (happens because return / call statement in strange recursive )
    }
}

#[cfg(not(feature = "hacspec"))]
fn contract_receive_call(
    ctx: &impl HasReceiveContext,
    host: &mut impl HasHost<State>,
    n: u64,
) -> u64 {
    let self_address = ctx.self_address();
    let p2 = n.to_le_bytes();
    let mut n2 = host
        .invoke_contract(
            &self_address,
            Parameter(&p2),
            EntrypointName::new_unchecked("receive"),
            Amount::zero(),
        )
        .unwrap_abort()
        .1
        .unwrap_abort();
    let cv2 = host.state().result;
    let n2: u64 = n2.get().unwrap_abort();
    // ensure_eq!(cv2, n2);
    cv2
}

fn fib (n : u64) -> u64 {
    if n == 1u64 {
        1u64
    } else {
        fib (n - 2u64) + fib (n - 1u64)
    }
}

#[cfg(not(feature = "hacspec"))]
// Add the the nth Fibonacci number F(n) to this contract's state.
// This is achieved by recursively calling the contract itself.
#[inline(always)]
#[receive(
    contract = "fib",
    name = "receive",
    parameter = "u64",
    return_value = "u64"
)]
fn contract_receive(
    ctx: &impl HasReceiveContext,
    host: &mut impl HasHost<State>,
) -> ReceiveResult<u64> {
    // Try to get the parameter (64bit unsigned integer).
    let n: u64 = ctx.parameter_cursor().get()?;
    match contract_receive_hacspec(Action::Start(n)) {
        Action::Value(v) => {
            host.state().result = v;
            Ok(v)
        }
        Action::Continuation0(_, p) => {
            let p = contract_receive_call(ctx, host, p); // p = n-1
            match contract_receive_hacspec(Action::Continuation0(n, p)) {
                Action::Continuation1(p, q) => {
                    let q = contract_receive_call(ctx, host, q);
                    match contract_receive_hacspec(Action::Continuation1(p, q)) {
                        Action::Value(v) => {
                            host.state().result = v;
                            Ok(v)
                        }
                        _ => Err(Reject {
                            error_code: unsafe {
                                core::num::NonZeroI32::new_unchecked(i32::MIN + 5i32)
                            },
                        }),
                    }
                }
                _ => Err(Reject {
                    error_code: unsafe { core::num::NonZeroI32::new_unchecked(i32::MIN + 5i32) },
                }),
            }
        }
        _ => {
            Err(Reject {
                error_code: unsafe { core::num::NonZeroI32::new_unchecked(i32::MIN + 5i32) },
            })
        }
    }

    // if n <= 1 {
    //     host.state().result = 1;
    //     Ok(1)
    // } else {
    //     let cv2 = contract_receive_call(ctx, host, n-2);
    //     let cv1 = contract_receive_call(ctx, host, n-1);
    //     host.state().result = cv1 + cv2;
    //     Ok(cv1 + cv2)
    // }
}

#[cfg(not(feature = "hacspec"))]
/// Retrieve the value of the state.
#[inline(always)]
#[receive(contract = "fib", name = "view", return_value = "u64")]
fn contract_view(
    _ctx: &impl HasReceiveContext,
    host: &mut impl HasHost<State>,
) -> ReceiveResult<u64> {
    Ok(host.state().result)
}

#[cfg(not(feature = "hacspec"))]
#[concordium_cfg_test]
mod tests {
    use super::*;
    use test_infrastructure::*;

    // Compute the n-th fibonacci number.
    fn fib(n: u64) -> u64 {
        let mut n1 = 1;
        let mut n2 = 1;
        for _ in 2..=n {
            let t = n1;
            n1 = n2;
            n2 += t;
        }
        n2
    }

    #[concordium_test]
    fn receive_works() {
        let mut ctx = ReceiveContextTest::empty();
        let parameter_bytes = to_bytes(&10u64);
        let contract_address = ContractAddress {
            index: 0,
            subindex: 0,
        };
        ctx.set_parameter(&parameter_bytes);
        ctx.set_self_address(contract_address.clone());

        let mut host = HostTest::new(State { result: 0 });

        host.setup_mock_invocation(
            contract_address,
            OwnedEntrypointName::new_unchecked("receive".into()),
            Handler::new(MockFn::new(|parameter, _amount, state| {
                let n: u64 = match from_bytes(parameter.0) {
                    Ok(n) => n,
                    Err(_) => return Err(InvokeError::Trap),
                };
                state.result = fib(n);
                Ok((true, state.result))
            })),
        );
        let res = contract_receive(&ctx, &mut host).expect_report("Calling receive failed.");
        assert_eq!(res, fib(10));
        assert_eq!(host.state().result, fib(10));
    }
}
#+end_src

** Generation of backend output

#+begin_src elisp :var SOURCE-CODE-FILE="Fib.v" :results output silent :tangle no
(org-babel-detangle SOURCE-CODE-FILE)
#+end_src

***  - Coq code
:PROPERTIES:
:header-args: coq :tangle Fib.v  :comments link
:header-args: coq :eval never :results output silent
:END:
