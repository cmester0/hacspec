#+TITLE: Concordium Smartcontract Infrastructure Implementations
#+AUTHOR: Lasse Letager Hansen

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file

* Concordium "Impls" specification
** Config
#+BEGIN_SRC toml :eval never
[package]
name = "concordium_impls"
version = "0.1.0"
authors = [""]
edition = "2018"

[lib]
path = "src/concordium_impls.rs"

[dependencies]
hacspec-lib = { path = "../../lib" }
hacspec-attributes = { path = "../../utils/attributes", version = "0.1.0-beta.1" , features = ["print_attributes", "hacspec_unsafe"] } # , features = ["hacspec_unsafe"] , , optional = true
# pearlite-syn = { path = "../../../../creusot/pearlite-syn" }
creusot-contracts = { path = "../../../../creusot/creusot-contracts" }

[features]
use_attributes = ["hacspec-attributes/print_attributes", "hacspec-attributes/hacspec_unsafe"]

[dev-dependencies]
hacspec-dev = { path = "../../utils/dev" }
criterion = "0.3"
rand = "0.8"
#+END_SRC

** Imports
#+BEGIN_SRC rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern crate hacspec_lib;

  use hacspec_lib::*;

  // #[cfg(feature = "hacspec_attributes")]
  #[cfg(feature = "hacspec")]
  use hacspec_attributes::*;

  #[cfg(not(feature = "hacspec"))]
  extern crate creusot_contracts;
  #[cfg(not(feature = "hacspec"))]
  use creusot_contracts::*;
#+END_SRC

** Rust code
*** Reject
The ~Rust~ definition for Reject is
#+begin_src rust :tangle no :eval never
/// An error message, signalling rejection of a smart contract invocation.
/// The client will see the error code as a reject reason; if a schema is
/// provided, the error message corresponding to the error code will be
/// displayed. The valid range for an error code is from i32::MIN to  -1.
#[derive(Eq, PartialEq, Debug)]
#[repr(transparent)]
pub struct Reject {
    pub error_code: crate::num::NonZeroI32,
}

/// Default error is i32::MIN.
impl Default for Reject {
    #[inline(always)]
    fn default() -> Self {
        Self {
            error_code: unsafe { crate::num::NonZeroI32::new_unchecked(i32::MIN) },
        }
    }
}

impl Reject {
    /// This returns `None` for all values >= 0 and `Some` otherwise.
    pub fn new(x: i32) -> Option<Self> {
        if x < 0 {
            let error_code = unsafe { crate::num::NonZeroI32::new_unchecked(x) };
            Some(Reject {
                error_code,
            })
        } else {
            None
        }
    }
}
#+end_src
# NonZeroI32 is located in rust/library/core/src/num/nonzero.rs
We modle reject as the underlying data, that is the src_rust[:eval never]{i32} error code. The default constructor is i32 min.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub type Reject = i32;

  pub fn reject_impl_deafult() -> Reject {
      i32::MIN
  }
#+end_src

#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub fn new_reject_impl(x: i32) -> Option<Reject> {
      if x < 0i32 {
	  Option::<i32>::Some(x)
      } else {
	  Option::<i32>::None
      }
  }

#+end_src

**** Reject - From trait
#+begin_src rust :tangle no :eval never
  impl convert::From<()> for Reject {
      #[inline(always)]
      fn from(_: ()) -> Self {
	  Reject {
	      error_code: unsafe { num::NonZeroI32::new_unchecked(i32::MIN + 1) },
	  }
      }
  }

  impl convert::From<ParseError> for Reject {
      #[inline(always)]
      fn from(_: ParseError) -> Self {
	  Reject {
	      error_code: unsafe { num::NonZeroI32::new_unchecked(i32::MIN + 2) },
	  }
      }
  }
#+end_src

We modle the unsafe block with unchecked non zero as a precondition using requires giving us the hacspec equivalent
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[ensures(result != 0i32)]
  pub fn reject_impl_convert_from_unit() -> Reject {
      i32::MIN + 1i32
  }

  #[ensures(result != 0i32)]
  pub fn reject_impl_convert_from_parse_error() -> Reject {
      i32::MIN + 2i32
  }
#+end_src
which we can insert as the definition of the from functions in the trait implementation by using a coerce function
#+begin_src rust :tangle no :eval never
  pub fn coerce_hacspec_to_rust_reject(hacspec_reject: ConcordiumImpls::Reject) -> Reject {
      Reject {
	  error_code: hacspec_reject,
      }
  }
#+end_src
We define a log error type and function converting from it to the reject type
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  /// Errors that can occur during logging.
  #[derive(Copy, Clone)] // , Debug, Eq, PartialEq
  #[repr(u8)]
  pub enum LogError {
      /// The log is full.
      Full,
      /// The message to log was malformed (e.g., too long)
      Malformed,
  }

  #[ensures(result != 0i32)]
  pub fn reject_impl_from_log_error(le: LogError) -> Reject {
      match le {
	  LogError::Full => i32::MIN + 3i32,
	  LogError::Malformed => i32::MIN + 4i32,
      }
  }

#+end_src
We define a type for new contract name errors and conversion from it to reject
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[derive(Clone)] // , Debug, PartialEq, Eq
  pub enum NewContractNameError {
      NewContractNameErrorMissingInitPrefix,
      NewContractNameErrorTooLong,
      NewContractNameErrorContainsDot,
      NewContractNameErrorInvalidCharacters,
  }

  #[ensures(result != 0i32)]
  pub fn reject_impl_from_new_contract_name_error(nre: NewContractNameError) -> Reject {
      match nre {
	  NewContractNameError::NewContractNameErrorMissingInitPrefix => i32::MIN + 5i32,
	  NewContractNameError::NewContractNameErrorTooLong => i32::MIN + 6i32,
	  NewContractNameError::NewContractNameErrorContainsDot => i32::MIN + 9i32,
	  NewContractNameError::NewContractNameErrorInvalidCharacters => i32::MIN + 10i32,
      }
  }

#+end_src
We define a type for new receive name errors and conversion from it to reject
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[derive(Clone)] // , Debug, PartialEq, Eq
  pub enum NewReceiveNameError {
      NewReceiveNameErrorMissingDotSeparator,
      NewReceiveNameErrorTooLong,
      NewReceiveNameErrorInvalidCharacters,
  }

  #[ensures(result != 0i32)]
  pub fn reject_impl_from_new_receive_name_error(nre: NewReceiveNameError) -> Reject {
      match nre {
	  NewReceiveNameError::NewReceiveNameErrorMissingDotSeparator => i32::MIN + 7i32,
	  NewReceiveNameError::NewReceiveNameErrorTooLong => i32::MIN + 8i32,
	  NewReceiveNameError::NewReceiveNameErrorInvalidCharacters => i32::MIN + 11i32,
      }
  }

#+end_src
*** Contract state
We define contract state as its inner state namely the current position of the src_rust[:eval never]{u32} type.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub type ContractState = u32;

#+end_src
**** Contract State -- Seek
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[derive(Copy, Clone)] // , Debug, PartialEq, Eq
  pub enum SeekFrom {
      /// Sets the offset to the provided number of bytes.
      Start(u64),

      /// Sets the offset to the size of this object plus the specified number of
      /// bytes.
      ///
      /// It is possible to seek beyond the end of an object, but it's an error to
      /// seek before byte 0.
      End(i64),

      /// Sets the offset to the current position plus the specified number of
      /// bytes.
      ///
      /// It is possible to seek beyond the end of an object, but it's an error to
      /// seek before byte 0.
      Current(i64),
  }

  pub type U32Option = Option<u32>;
  pub type I64Option = Option<i64>;

  // #[requires(forall<delta : i64> pos === SeekFrom::End(delta) ==> exists<b : u32> current_position.checked_add(delta as u32) == U32Option::Some(b))]
  pub fn contract_state_impl_seek(current_position: ContractState, pos: SeekFrom) -> Result<(ContractState, u64), ()> {
      match pos {
	  SeekFrom::Start(offset) => Result::<(ContractState, u64), ()>::Ok((offset as u32, offset)),
	  SeekFrom::End(delta) => {
	      if delta >= 0_i64 {
		  match current_position.checked_add(delta as u32) {
		      U32Option::Some(b) => Result::<(ContractState, u64), ()>::Ok((b, delta as u64)),
		      U32Option::None => Result::<(ContractState, u64), ()>::Err(()),
		  }
	      } else {
		  match delta.checked_abs() {
		      I64Option::Some(b) =>
		      {
			  Result::<(ContractState, u64), ()>::Ok(((4_u32 - (b as u32)), (4_u32 - (b as u32)) as u64))
		      }
		      I64Option::None => Result::<(ContractState, u64), ()>::Err(()),
		  }
	      }
	  }
	  SeekFrom::Current(delta) => {
	      if delta >= 0_i64 {
		  match current_position.checked_add(delta as u32) {
		      U32Option::Some(offset) => Result::<(ContractState, u64), ()>::Ok((offset, offset as u64)),
		      U32Option::None => Result::<(ContractState, u64), ()>::Err(()),
		  }
	      } else {
		  match delta.checked_abs() {
		      I64Option::Some(b) => match current_position.checked_sub(b as u32) {
			  U32Option::Some(offset) => Result::<(ContractState, u64), ()>::Ok((offset, offset as u64)),
			  U32Option::None => Result::<(ContractState, u64), ()>::Err(()),
		      },
		      I64Option::None => Result::<(ContractState, u64), ()>::Err(()),
		  }
	      }
	  }
      }
  }
#+end_src
**** Contract State -- Load
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn load_state(start: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn load_state_creusot(start: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { load_state(start, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  fn load_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn load_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let mut temp_vec: Vec<u8> = Vec::new();
      for i in 0..buf.len() {
	  temp_vec.push(buf.index(i).clone())
      }
      let temp = &mut temp_vec[..];
      (
	  PublicByteSeq::from_native_slice(temp),
	  load_state_creusot(temp.as_mut_ptr(), buf.len() as u32, offset),
      )
  }
    
#+end_src
**** Contract State -- Read
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub fn contract_state_impl_read_read(
      current_position: ContractState,
      buf : PublicByteSeq // Seq<u8>
      // num_read: u32,
  ) -> (ContractState, usize) {
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, num_read as usize)
  }

  /// Read a u32 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u64(
      current_position: ContractState,
      num_read: u32,
  ) -> (ContractState, bool) {
      (current_position + num_read, num_read == 8_u32)
  }

  /// Read a u32 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u32(
      current_position: ContractState,
      num_read: u32,
  ) -> (ContractState, bool) {
      (current_position + num_read, num_read == 4_u32)
  }

  /// Read a u8 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u8(
      current_position: ContractState,
      num_read: u32,
  ) -> (ContractState, bool) {
      (current_position + num_read, num_read == 1_u32)
  }

#+end_src
**** Contract State -- Write
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub fn write_impl_for_contract_state_test(current_position: ContractState, len: u32) -> bool {
      current_position.checked_add(len).is_none() // Check for overflow
  }

  pub fn write_impl_for_contract_state(
      current_position: ContractState,
      num_bytes: u32,
  ) -> (ContractState, usize) {
      (current_position + num_bytes, num_bytes as usize)
  }

#+end_src
**** Contract State -- Misc.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub fn has_contract_state_impl_for_contract_state_open() -> ContractState {
      0_u32
  }

  pub fn has_contract_state_impl_for_contract_state_reserve_0(len: u32, cur_size: u32) -> bool {
      cur_size < len
  }
  
  pub fn has_contract_state_impl_for_contract_state_reserve_1(res: u32) -> bool {
      res == 1_u32
  }

  pub fn has_contract_state_impl_for_contract_state_truncate_0(cur_size: u32, new_size: u32) -> bool {
      cur_size > new_size
  }

  pub fn has_contract_state_impl_for_contract_state_truncate_1(
      current_position: ContractState,
      new_size: u32,
  ) -> ContractState {
      if new_size < current_position {
	  new_size
      } else {
	  current_position
      }
  }

#+end_src
*** Parameter
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub type Parameter = u32;

  pub fn read_impl_for_parameter_read(
      current_position: Parameter,
      num_read: u32,
  ) -> (Parameter, usize) {
      (current_position + num_read, num_read as usize)
  }

#+end_src
*** AttributesCursor
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  // pub struct AttributeTag(pub u8);
  pub type AttributesCursor = (u32, u16);

  pub fn has_policy_impl_for_policy_attributes_cursor_next_test(
      policy_attribute_items: AttributesCursor,
  ) -> bool {
      let (_, remaining_items) = policy_attribute_items;
      remaining_items == 0_u16
  }

  pub fn has_policy_impl_for_policy_attributes_cursor_next_tag_invalid(
      policy_attribute_items: AttributesCursor,
      tag_value_len_1: u8,
      num_read: u32,
  ) -> (AttributesCursor, bool) {
      let (current_position, remaining_items) = policy_attribute_items;
      let policy_attribute_items = (current_position + num_read, remaining_items);
      (policy_attribute_items, tag_value_len_1 > 31_u8)
  }

  pub fn has_policy_impl_for_policy_attributes_cursor_next(
      policy_attribute_items: AttributesCursor,
      num_read: u32,
  ) -> AttributesCursor {
      let (current_position, remaining_items) = policy_attribute_items;
      (current_position + num_read, remaining_items - 1_u16)
  }
#+end_src
** Rust Tests
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never

#+end_src

** Interface between Rust and Hacspec
This file should replace the import of the concordium ~impls.rs~ file.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls_interface.rs :eval never
  use crate::{
      collections::{BTreeMap, BTreeSet},
      convert::{self, TryFrom, TryInto},
      hash::Hash,
      mem, num, prims,
      prims::*,
      traits::*,
      types::*,
      vec::Vec,
      String,
  };
  use concordium_contracts_common::*;
  use mem::MaybeUninit;

  use concordium_impls::*;

  pub fn coerce_hacspec_to_rust_reject(hacspec_reject: ConcordiumImpls::Reject) -> Reject {
      Reject {
	  error_code: hacspec_reject,
      }
  }

  impl convert::From<()> for Reject {
      #[inline(always)]
      fn from(_: ()) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_convert_from_unit())
      }
  }

  impl convert::From<ParseError> for Reject {
      #[inline(always)]
      fn from(_: ParseError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_convert_from_parse_error())
      }
  }

  // pub fn coerce_hacspec_to_rust_log_error(hacspec_log_error: ConcordiumImpls::LogError) -> LogError {
  //     match hacspec_log_error {
  //         ConcordiumImpls::LogError::Full => LogError::Full,
  //         ConcordiumImpls::LogError::Malformed => LogError::Malformed,
  //     }
  // }

  pub fn coerce_rust_to_hacspec_log_error(rust_log_error: LogError) -> ConcordiumImpls::LogError {
      match rust_log_error {
	  LogError::Full => ConcordiumImpls::LogError::Full,
	  LogError::Malformed => ConcordiumImpls::LogError::Malformed,
      }
  }

  /// Full is mapped to i32::MIN+3, Malformed is mapped to i32::MIN+4.
  impl From<LogError> for Reject {
      #[inline(always)]
      fn from(le: LogError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_from_log_error(
	      coerce_rust_to_hacspec_log_error(le),
	  ))
      }
  }

  pub fn coerce_rust_to_hacspec_new_contract_name_error(
      rust_contract_name_error: NewContractNameError,
  ) -> ConcordiumImpls::NewContractNameError {
      match rust_log_error {
	  NewContractNameError::NewContractNameErrorMissingInitPrefix => {
	      ConcordiumImpls::NewContractNameError::NewContractNameErrorMissingInitPrefix
	  }
	  NewContractNameError::NewContractNameErrorTooLong => {
	      ConcordiumImpls::NewContractNameError::NewContractNameErrorTooLong
	  }
	  NewContractNameError::NewContractNameErrorContainsDot => {
	      ConcordiumImpls::NewContractNameError::NewContractNameErrorContainsDot
	  }
	  NewContractNameError::NewContractNameErrorInvalidCharacters => {
	      ConcordiumImpls::NewContractNameError::NewContractNameErrorInvalidCharacters
	  }
      }
  }

  /// MissingInitPrefix is mapped to i32::MIN + 5,
  /// TooLong to i32::MIN + 6,
  /// ContainsDot to i32::MIN + 9, and
  /// InvalidCharacters to i32::MIN + 10.
  impl From<NewContractNameError> for Reject {
      fn from(nre: NewContractNameError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_from_new_contract_name_error(
	      coerce_rust_to_hacspec_new_contract_name_error(nre),
	  ))
      }
  }

  pub fn coerce_rust_to_hacspec_new_receive_name_error(
      rust_receive_name_error: NewReceiveNameError,
  ) -> ConcordiumImpls::NewReceiveNameError {
      match rust_log_error {
	  NewReceiveNameError::NewReceiveNameErrorMissingInitPrefix => {
	      ConcordiumImpls::NewReceiveNameError::NewReceiveNameErrorMissingInitPrefix
	  }
	  NewReceiveNameError::NewReceiveNameErrorTooLong => {
	      ConcordiumImpls::NewReceiveNameError::NewReceiveNameErrorTooLong
	  }
	  NewReceiveNameError::NewReceiveNameErrorContainsDot => {
	      ConcordiumImpls::NewReceiveNameError::NewReceiveNameErrorContainsDot
	  }
	  NewReceiveNameError::NewReceiveNameErrorInvalidCharacters => {
	      ConcordiumImpls::NewReceiveNameError::NewReceiveNameErrorInvalidCharacters
	  }
      }
  }

  /// MissingDotSeparator is mapped to i32::MIN + 7,
  /// TooLong to i32::MIN + 8, and
  /// InvalidCharacters to i32::MIN + 11.
  impl From<NewReceiveNameError> for Reject {
      fn from(nre: NewReceiveNameError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_from_new_receive_name_error(
	      coerce_rust_to_hacspec_new_receive_name_error(nre),
	  ))
      }
  }

  pub fn coerce_rust_to_hacspec_contract_state(
      rust_contract_state: ContractState,
  ) -> ConcordiumImpls::ContractState {
      rust_contract_state.current_position
  }

  pub fn coerce_hacspec_to_rust_contract_state(
      rust_contract_state: &ContractState,
      hacspec_contract_state: ConcordiumImpls::ContractState,
  ) -> ContractState {
      rust_contract_state.current_position = hacspec_contract_state;
  }

  pub fn coerce_hacspec_to_rust_seek_result(
      rust_contract_state: &ContractState,
      hacspec_seek_result: Result<(ContractState, u64), ()>,
  ) -> ConcordiumImpls::ContractState {
      let (hacspec_result, rust_result) = hacspec_seek_result?;
      coerce_hacspec_to_rust_contract_state(rust_contract_state, hacspec_result);
      Ok(rust_result)
  }

  /// # Contract state trait implementations.
  impl Seek for ContractState {
      type Err = ();

      fn seek(&mut self, pos: SeekFrom) -> Result<u64, Self::Err> {
	  coerce_hacspec_to_rust_seek_result(
	      &self,
	      contract_state_impl_seek(coerce_rust_to_hacspec_contract_state(self), pos),
	  )
      }
  }

  // impl Read for ContractState {
  //     fn read(&mut self, buf: &mut [u8]) -> ParseResult<usize> {
  //         let len: u32 = {
  //             match buf.len().try_into() {
  //                 Ok(v) => v,
  //                 _ => return Err(ParseError::default()),
  //             }
  //         };
  //         let num_read = unsafe { load_state(buf.as_mut_ptr(), len, self.current_position) };
  //         self.current_position += num_read;
  //         Ok(num_read as usize)
  //     }

  //     /// Read a `u32` in little-endian format. This is optimized to not
  //     /// initialize a dummy value before calling an external function.
  //     fn read_u64(&mut self) -> ParseResult<u64> {
  //         let mut bytes: MaybeUninit<[u8; 8]> = MaybeUninit::uninit();
  //         let num_read =
  //             unsafe { load_state(bytes.as_mut_ptr() as *mut u8, 8, self.current_position) };
  //         self.current_position += num_read;
  //         if num_read == 8 {
  //             unsafe { Ok(u64::from_le_bytes(bytes.assume_init())) }
  //         } else {
  //             Err(ParseError::default())
  //         }
  //     }

  //     /// Read a `u32` in little-endian format. This is optimized to not
  //     /// initialize a dummy value before calling an external function.
  //     fn read_u32(&mut self) -> ParseResult<u32> {
  //         let mut bytes: MaybeUninit<[u8; 4]> = MaybeUninit::uninit();
  //         let num_read =
  //             unsafe { load_state(bytes.as_mut_ptr() as *mut u8, 4, self.current_position) };
  //         self.current_position += num_read;
  //         if num_read == 4 {
  //             unsafe { Ok(u32::from_le_bytes(bytes.assume_init())) }
  //         } else {
  //             Err(ParseError::default())
  //         }
  //     }

  //     /// Read a `u8` in little-endian format. This is optimized to not
  //     /// initialize a dummy value before calling an external function.
  //     fn read_u8(&mut self) -> ParseResult<u8> {
  //         let mut bytes: MaybeUninit<[u8; 1]> = MaybeUninit::uninit();
  //         let num_read =
  //             unsafe { load_state(bytes.as_mut_ptr() as *mut u8, 1, self.current_position) };
  //         self.current_position += num_read;
  //         if num_read == 1 {
  //             unsafe { Ok(bytes.assume_init()[0]) }
  //         } else {
  //             Err(ParseError::default())
  //         }
  //     }
  // }

  // impl Write for ContractState {
  //     type Err = ();

  //     fn write(&mut self, buf: &[u8]) -> Result<usize, Self::Err> {
  //         let len: u32 = {
  //             match buf.len().try_into() {
  //                 Ok(v) => v,
  //                 _ => return Err(()),
  //             }
  //         };
  //         if self.current_position.checked_add(len).is_none() {
  //             return Err(());
  //         }
  //         let num_bytes = unsafe { write_state(buf.as_ptr(), len, self.current_position) };
  //         self.current_position += num_bytes; // safe because of check above that len + pos is small enough
  //         Ok(num_bytes as usize)
  //     }
  // }

  // impl HasContractState<()> for ContractState {
  //     type ContractStateData = ();

  //     #[inline(always)]
  //     fn open(_: Self::ContractStateData) -> Self {
  //         ContractState {
  //             current_position: 0,
  //         }
  //     }

  //     fn reserve(&mut self, len: u32) -> bool {
  //         let cur_size = unsafe { state_size() };
  //         if cur_size < len {
  //             let res = unsafe { resize_state(len) };
  //             res == 1
  //         } else {
  //             true
  //         }
  //     }

  //     #[inline(always)]
  //     fn size(&self) -> u32 {
  //         unsafe { state_size() }
  //     }

  //     fn truncate(&mut self, new_size: u32) {
  //         let cur_size = self.size();
  //         if cur_size > new_size {
  //             unsafe { resize_state(new_size) };
  //         }
  //         if new_size < self.current_position {
  //             self.current_position = new_size
  //         }
  //     }
  // }

  // /// # Trait implementations for Parameter
  // impl Read for Parameter {
  //     fn read(&mut self, buf: &mut [u8]) -> ParseResult<usize> {
  //         let len: u32 = {
  //             match buf.len().try_into() {
  //                 Ok(v) => v,
  //                 _ => return Err(ParseError::default()),
  //             }
  //         };
  //         let num_read =
  //             unsafe { get_parameter_section(buf.as_mut_ptr(), len, self.current_position) };
  //         self.current_position += num_read;
  //         Ok(num_read as usize)
  //     }
  // }

  // impl HasParameter for Parameter {
  //     #[inline(always)]
  //     fn size(&self) -> u32 {
  //         unsafe { get_parameter_size() }
  //     }
  // }

  // /// # Trait implementations for the chain metadata.
  // impl HasChainMetadata for ChainMetaExtern {
  //     #[inline(always)]
  //     fn slot_time(&self) -> SlotTime {
  //         Timestamp::from_timestamp_millis(unsafe { get_slot_time() })
  //     }
  // }

  // impl HasPolicy for Policy<AttributesCursor> {
  //     fn identity_provider(&self) -> IdentityProvider {
  //         self.identity_provider
  //     }

  //     fn created_at(&self) -> Timestamp {
  //         self.created_at
  //     }

  //     fn valid_to(&self) -> Timestamp {
  //         self.valid_to
  //     }

  //     fn next_item(&mut self, buf: &mut [u8; 31]) -> Option<(AttributeTag, u8)> {
  //         if self.items.remaining_items == 0 {
  //             return None;
  //         }

  //         let (tag_value_len, num_read) = unsafe {
  //             let mut tag_value_len = MaybeUninit::<[u8; 2]>::uninit();
  //             // Should succeed, otherwise host violated precondition.
  //             let num_read = get_policy_section(
  //                 tag_value_len.as_mut_ptr() as *mut u8,
  //                 2,
  //                 self.items.current_position,
  //             );
  //             (tag_value_len.assume_init(), num_read)
  //         };
  //         self.items.current_position += num_read;
  //         if tag_value_len[1] > 31 {
  //             // Should not happen because all attributes fit into 31 bytes.
  //             return None;
  //         }
  //         let num_read = unsafe {
  //             get_policy_section(
  //                 buf.as_mut_ptr(),
  //                 u32::from(tag_value_len[1]),
  //                 self.items.current_position,
  //             )
  //         };
  //         self.items.current_position += num_read;
  //         self.items.remaining_items -= 1;
  //         Some((AttributeTag(tag_value_len[0]), tag_value_len[1]))
  //     }
  // }

  // /// An iterator over policies using host functions to supply the data.
  // /// The main interface to using this type is via the methods of the [Iterator](https://doc.rust-lang.org/std/iter/trait.Iterator.html)
  // /// and [ExactSizeIterator](https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html) traits.
  // pub struct PoliciesIterator {
  //     /// Position in the policies binary serialization.
  //     pos: u32,
  //     /// Number of remaining items in the stream.
  //     remaining_items: u16,
  // }

  // impl Iterator for PoliciesIterator {
  //     type Item = Policy<AttributesCursor>;

  //     fn next(&mut self) -> Option<Self::Item> {
  //         if self.remaining_items == 0 {
  //             return None;
  //         }
  //         // 2 for total size of this section, 4 for identity_provider,
  //         // 8 bytes for created_at, 8 for valid_to, and 2 for
  //         // the length
  //         let mut buf: MaybeUninit<[u8; 2 + 4 + 8 + 8 + 2]> = MaybeUninit::uninit();
  //         let buf = unsafe {
  //             get_policy_section(buf.as_mut_ptr() as *mut u8, 2 + 4 + 8 + 8 + 2, self.pos);
  //             buf.assume_init()
  //         };
  //         let skip_part: [u8; 2] = buf[0..2].try_into().unwrap_abort();
  //         let ip_part: [u8; 4] = buf[2..2 + 4].try_into().unwrap_abort();
  //         let created_at_part: [u8; 8] = buf[2 + 4..2 + 4 + 8].try_into().unwrap_abort();
  //         let valid_to_part: [u8; 8] = buf[2 + 4 + 8..2 + 4 + 8 + 8].try_into().unwrap_abort();
  //         let len_part: [u8; 2] = buf[2 + 4 + 8 + 8..2 + 4 + 8 + 8 + 2]
  //             .try_into()
  //             .unwrap_abort();
  //         let identity_provider = IdentityProvider::from_le_bytes(ip_part);
  //         let created_at = Timestamp::from_timestamp_millis(u64::from_le_bytes(created_at_part));
  //         let valid_to = Timestamp::from_timestamp_millis(u64::from_le_bytes(valid_to_part));
  //         let remaining_items = u16::from_le_bytes(len_part);
  //         let attributes_start = self.pos + 2 + 4 + 8 + 8 + 2;
  //         self.pos += u32::from(u16::from_le_bytes(skip_part)) + 2;
  //         self.remaining_items -= 1;
  //         Some(Policy {
  //             identity_provider,
  //             created_at,
  //             valid_to,
  //             items: AttributesCursor {
  //                 current_position: attributes_start,
  //                 remaining_items,
  //             },
  //         })
  //     }

  //     fn size_hint(&self) -> (usize, Option<usize>) {
  //         let rem = self.remaining_items as usize;
  //         (rem, Some(rem))
  //     }
  // }

  // impl ExactSizeIterator for PoliciesIterator {
  //     #[inline(always)]
  //     fn len(&self) -> usize {
  //         self.remaining_items as usize
  //     }
  // }

  // impl<T: sealed::ContextType> HasCommonData for ExternContext<T> {
  //     type MetadataType = ChainMetaExtern;
  //     type ParamType = Parameter;
  //     type PolicyIteratorType = PoliciesIterator;
  //     type PolicyType = Policy<AttributesCursor>;

  //     #[inline(always)]
  //     fn metadata(&self) -> &Self::MetadataType {
  //         &ChainMetaExtern {}
  //     }

  //     fn policies(&self) -> PoliciesIterator {
  //         let mut buf: MaybeUninit<[u8; 2]> = MaybeUninit::uninit();
  //         let buf = unsafe {
  //             get_policy_section(buf.as_mut_ptr() as *mut u8, 2, 0);
  //             buf.assume_init()
  //         };
  //         PoliciesIterator {
  //             pos: 2, // 2 because we already read 2 bytes.
  //             remaining_items: u16::from_le_bytes(buf),
  //         }
  //     }

  //     #[inline(always)]
  //     fn parameter_cursor(&self) -> Self::ParamType {
  //         Parameter {
  //             current_position: 0,
  //         }
  //     }
  // }

  // /// # Trait implementations for the init context
  // impl HasInitContext for ExternContext<crate::types::InitContextExtern> {
  //     type InitData = ();

  //     /// Create a new init context by using an external call.
  //     fn open(_: Self::InitData) -> Self {
  //         ExternContext::default()
  //     }

  //     #[inline(always)]
  //     fn init_origin(&self) -> AccountAddress {
  //         let mut bytes: MaybeUninit<[u8; ACCOUNT_ADDRESS_SIZE]> = MaybeUninit::uninit();
  //         let ptr = bytes.as_mut_ptr();
  //         let address = unsafe {
  //             get_init_origin(ptr as *mut u8);
  //             bytes.assume_init()
  //         };
  //         AccountAddress(address)
  //     }
  // }

  // /// # Trait implementations for the receive context
  // impl HasReceiveContext for ExternContext<crate::types::ReceiveContextExtern> {
  //     type ReceiveData = ();

  //     /// Create a new receive context
  //     fn open(_: Self::ReceiveData) -> Self {
  //         ExternContext::default()
  //     }

  //     #[inline(always)]
  //     fn invoker(&self) -> AccountAddress {
  //         let mut bytes: MaybeUninit<[u8; ACCOUNT_ADDRESS_SIZE]> = MaybeUninit::uninit();
  //         let ptr = bytes.as_mut_ptr();
  //         let address = unsafe {
  //             get_receive_invoker(ptr as *mut u8);
  //             bytes.assume_init()
  //         };
  //         AccountAddress(address)
  //     }

  //     #[inline(always)]
  //     fn self_address(&self) -> ContractAddress {
  //         let mut bytes: MaybeUninit<[u8; 16]> = MaybeUninit::uninit();
  //         let ptr = bytes.as_mut_ptr();
  //         let address = unsafe {
  //             get_receive_self_address(ptr as *mut u8);
  //             bytes.assume_init()
  //         };
  //         match from_bytes(&address) {
  //             Ok(v) => v,
  //             Err(_) => crate::trap(),
  //         }
  //     }

  //     #[inline(always)]
  //     fn self_balance(&self) -> Amount {
  //         Amount::from_micro_gtu(unsafe { get_receive_self_balance() })
  //     }

  //     #[inline(always)]
  //     fn sender(&self) -> Address {
  //         let mut bytes: MaybeUninit<[u8; 33]> = MaybeUninit::uninit();
  //         let ptr = bytes.as_mut_ptr() as *mut u8;
  //         unsafe {
  //             get_receive_sender(ptr);
  //             let tag = *ptr;
  //             match tag {
  //                 0u8 => {
  //                     match from_bytes(core::slice::from_raw_parts(
  //                         ptr.add(1),
  //                         ACCOUNT_ADDRESS_SIZE,
  //                     )) {
  //                         Ok(v) => Address::Account(v),
  //                         Err(_) => crate::trap(),
  //                     }
  //                 }
  //                 1u8 => match from_bytes(core::slice::from_raw_parts(ptr.add(1), 16)) {
  //                     Ok(v) => Address::Contract(v),
  //                     Err(_) => crate::trap(),
  //                 },
  //                 _ => crate::trap(), // unreachable!("Host violated precondition."),
  //             }
  //         }
  //     }

  //     #[inline(always)]
  //     fn owner(&self) -> AccountAddress {
  //         let mut bytes: MaybeUninit<[u8; ACCOUNT_ADDRESS_SIZE]> = MaybeUninit::uninit();
  //         let ptr = bytes.as_mut_ptr();
  //         let address = unsafe {
  //             get_receive_owner(ptr as *mut u8);
  //             bytes.assume_init()
  //         };
  //         AccountAddress(address)
  //     }
  // }

  // /// #Implementations of the logger.

  // impl HasLogger for Logger {
  //     #[inline(always)]
  //     fn init() -> Self {
  //         Self { _private: () }
  //     }

  //     fn log_raw(&mut self, event: &[u8]) -> Result<(), LogError> {
  //         let res = unsafe { log_event(event.as_ptr(), event.len() as u32) };
  //         match res {
  //             1 => Ok(()),
  //             0 => Err(LogError::Full),
  //             _ => Err(LogError::Malformed),
  //         }
  //     }
  // }

  // /// #Implementation of actions.
  // /// These actions are implemented by direct calls to host functions.
  // impl HasActions for Action {
  //     #[inline(always)]
  //     fn accept() -> Self {
  //         Action {
  //             _private: unsafe { accept() },
  //         }
  //     }

  //     #[inline(always)]
  //     fn simple_transfer(acc: &AccountAddress, amount: Amount) -> Self {
  //         let res = unsafe { simple_transfer(acc.0.as_ptr(), amount.micro_gtu) };
  //         Action { _private: res }
  //     }

  //     #[inline(always)]
  //     fn send_raw(
  //         ca: &ContractAddress,
  //         receive_name: ReceiveName,
  //         amount: Amount,
  //         parameter: &[u8],
  //     ) -> Self {
  //         let receive_bytes = receive_name.get_chain_name().as_bytes();
  //         let res = unsafe {
  //             prims::send(
  //                 ca.index,
  //                 ca.subindex,
  //                 receive_bytes.as_ptr(),
  //                 receive_bytes.len() as u32,
  //                 amount.micro_gtu,
  //                 parameter.as_ptr(),
  //                 parameter.len() as u32,
  //             )
  //         };
  //         Action { _private: res }
  //     }

  //     #[inline(always)]
  //     fn and_then(self, then: Self) -> Self {
  //         let res = unsafe { combine_and(self._private, then._private) };
  //         Action { _private: res }
  //     }

  //     #[inline(always)]
  //     fn or_else(self, el: Self) -> Self {
  //         let res = unsafe { combine_or(self._private, el._private) };
  //         Action { _private: res }
  //     }
  // }

  // /// Allocates a Vec of bytes prepended with its length as a `u32` into memory,
  // /// and prevents them from being dropped. Returns the pointer.
  // /// Used to pass bytes from a Wasm module to its host.
  // #[doc(hidden)]
  // pub fn put_in_memory(input: &[u8]) -> *mut u8 {
  //     let bytes_length = input.len() as u32;
  //     let mut bytes = to_bytes(&bytes_length);
  //     bytes.extend_from_slice(input);
  //     let ptr = bytes.as_mut_ptr();
  //     #[cfg(feature = "std")]
  //     ::std::mem::forget(bytes);
  //     #[cfg(not(feature = "std"))]
  //     core::mem::forget(bytes);
  //     ptr
  // }

  // /// Wrapper for
  // /// [HasActions::send_raw](./trait.HasActions.html#tymethod.send_raw), which
  // /// automatically serializes the parameter. Note that if the parameter is
  // /// already a byte array or convertible to a byte array without allocations it
  // /// is preferrable to use [send_raw](./trait.HasActions.html#tymethod.send_raw).
  // /// It is more efficient and avoids memory allocations.
  // pub fn send<A: HasActions, P: Serial>(
  //     ca: &ContractAddress,
  //     receive_name: ReceiveName,
  //     amount: Amount,
  //     parameter: &P,
  // ) -> A {
  //     let param_bytes = to_bytes(parameter);
  //     A::send_raw(ca, receive_name, amount, &param_bytes)
  // }

  // impl<A, E> UnwrapAbort for Result<A, E> {
  //     type Unwrap = A;

  //     #[inline]
  //     fn unwrap_abort(self) -> Self::Unwrap {
  //         match self {
  //             Ok(x) => x,
  //             Err(_) => crate::trap(),
  //         }
  //     }
  // }

  // #[cfg(not(feature = "std"))]
  // use core::fmt;
  // #[cfg(feature = "std")]
  // use std::fmt;

  // impl<A, E: fmt::Debug> ExpectReport for Result<A, E> {
  //     type Unwrap = A;

  //     fn expect_report(self, msg: &str) -> Self::Unwrap {
  //         match self {
  //             Ok(x) => x,
  //             Err(e) => crate::fail!("{}: {:?}", msg, e),
  //         }
  //     }
  // }

  // impl<A: fmt::Debug, E> ExpectErrReport for Result<A, E> {
  //     type Unwrap = E;

  //     fn expect_err_report(self, msg: &str) -> Self::Unwrap {
  //         match self {
  //             Ok(a) => crate::fail!("{}: {:?}", msg, a),
  //             Err(e) => e,
  //         }
  //     }
  // }

  // impl<A> UnwrapAbort for Option<A> {
  //     type Unwrap = A;

  //     #[inline(always)]
  //     fn unwrap_abort(self) -> Self::Unwrap {
  //         self.unwrap_or_else(|| crate::trap())
  //     }
  // }

  // impl<A> ExpectReport for Option<A> {
  //     type Unwrap = A;

  //     fn expect_report(self, msg: &str) -> Self::Unwrap {
  //         match self {
  //             Some(v) => v,
  //             None => crate::fail!("{}", msg),
  //         }
  //     }
  // }

  // impl<A: fmt::Debug> ExpectNoneReport for Option<A> {
  //     fn expect_none_report(self, msg: &str) {
  //         if let Some(x) = self {
  //             crate::fail!("{}: {:?}", msg, x)
  //         }
  //     }
  // }

  // impl<K: Serial + Ord> SerialCtx for BTreeSet<K> {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_set_no_length(self, out)
  //     }
  // }

  // impl<K: Deserial + Ord + Copy> DeserialCtx for BTreeSet<K> {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         if ensure_ordered {
  //             deserial_set_no_length(source, len)
  //         } else {
  //             deserial_set_no_length_no_order_check(source, len)
  //         }
  //     }
  // }

  // impl<K: Serial + Ord, V: Serial> SerialCtx for BTreeMap<K, V> {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_map_no_length(self, out)
  //     }
  // }

  // impl<K: Deserial + Ord + Copy, V: Deserial> DeserialCtx for BTreeMap<K, V> {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         if ensure_ordered {
  //             deserial_map_no_length(source, len)
  //         } else {
  //             deserial_map_no_length_no_order_check(source, len)
  //         }
  //     }
  // }

  // /// Serialization for HashSet given a size_len.
  // /// Values are not serialized in any particular order.
  // impl<K: Serial> SerialCtx for HashSet<K> {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_hashset_no_length(self, out)
  //     }
  // }

  // /// Deserialization for HashSet given a size_len.
  // /// Values are not verified to be in any particular order and setting
  // /// ensure_ordering have no effect.
  // impl<K: Deserial + Eq + Hash> DeserialCtx for HashSet<K> {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         _ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         deserial_hashset_no_length(source, len)
  //     }
  // }

  // /// Serialization for HashMap given a size_len.
  // /// Keys are not serialized in any particular order.
  // impl<K: Serial, V: Serial> SerialCtx for HashMap<K, V> {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_hashmap_no_length(self, out)
  //     }
  // }

  // /// Deserialization for HashMap given a size_len.
  // /// Keys are not verified to be in any particular order and setting
  // /// ensure_ordering have no effect.
  // impl<K: Deserial + Eq + Hash, V: Deserial> DeserialCtx for HashMap<K, V> {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         _ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         deserial_hashmap_no_length(source, len)
  //     }
  // }

  // impl<T: Serial> SerialCtx for &[T] {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_vector_no_length(self, out)
  //     }
  // }

  // impl<T: Deserial> DeserialCtx for Vec<T> {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         _ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         deserial_vector_no_length(source, len)
  //     }
  // }

  // impl SerialCtx for &str {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_vector_no_length(&self.as_bytes().to_vec(), out)
  //     }
  // }

  // impl SerialCtx for String {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         self.as_str().serial_ctx(size_len, out)
  //     }
  // }

  // impl DeserialCtx for String {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         _ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         let bytes = deserial_vector_no_length(source, len)?;
  //         let res = String::from_utf8(bytes).map_err(|_| ParseError::default())?;
  //         Ok(res)
  //     }
  // }
#+end_src

** Resulting output
#+begin_src sh :eval no-export-query :results output silent
  cargo clean
#+end_src

#+begin_src sh :eval no-export-query :results output silent
  cd ../.. && cargo install --path language
#+end_src

#+begin_src sh :eval no-export-query :results output silent
  cd ../.. && cargo build
#+end_src

#+begin_src sh :eval never :results output silent
  cargo hacspec -o ConcordiumImpls.v concordium_impls --init
#+end_src

#+begin_src sh :results output silent
  cargo hacspec -o ConcordiumImpls.v concordium_impls --update
#+end_src

** Generation of backend output

#+name: split-file
#+begin_src python :wrap "src coq :tangle ConcordiumImpls.v :results output silent" :exports none :results code :var ARG="0 -1" :var FILENAME="ConcordiumImpls.v" :eval never
  import functools

  lower, upper = map(int, ARG.split())
  if upper != -1:
    upper = lower + upper

  def boundery(start, end, lines, i):
    test = lines[i][:len(start)] == start
    res_str = ""

    in_end = lambda i: (i < len(lines) and len(list(filter(lambda x: x in lines[i], end))) > 0)

    if test:
      # if end in lines[i]:
      if in_end(i):
	res_str = lines[i]
      else:
	while i < len(lines) and not in_end(i): # end not in lines[i]:
	  res_str += lines[i]
	  i += 1
	res_str += lines[i]
    return (test, res_str, i)

  lines = []
  with open(FILENAME) as f:
    lines = f.readlines()

  result = []
  i  = 0
  while i < len(lines) and (upper == -1 or upper > len(result)):
    a,b,c = functools.reduce(lambda b, a: b if b[0] else boundery(a[0], a[1], lines, b[2]),
			     [["(**", set({"**)"})],
			      ["From",set({".\n"})],
			      ["Require",set({".\n"})],
			      ["Import",set({".\n"})],
			      ["Open Scope",set({".\n"})],
			      ["Inductive",set({".\n"})],
			      ["Definition",set({".\n"})],
			      ["Instance",set({".\n"})],
			      ["Notation",set({".\n"})],
			      ["Theorem",set({".\n"})],
			      ["Global Instance",set({".\n"})],
			      ["Proof",set({"Admitted", "Qed"})],
			      ["QuickChick",set({".\n"})],
			      ],
			     (False, "", i))
    if a:
      result.append(b)
      i = c
    elif lines[i].isspace():
      space = ""
      while i < len(lines) and lines[i].isspace():
	space += lines[i]
	i += 1
      i -= 1
      result.append(space)
    else:
      result.append("ERR:" + lines[i])
    i += 1

  result_str = ""
  for s in (result[lower:] if upper == -1 else result[lower:upper]):
    result_str += s

  return result_str
#+end_src

#+NAME: next
#+begin_src python :var ARG="0 0" :var linum="0 0" :results output silent :exports none
  a,b = map(int, linum.split())
  c,d = map(int, ARG.split())
  print (a+b+c,d)
#+end_src

#+NAME: seginit
#+begin_src python :wrap "src coq :results output silent" :result code :exports none :var loc=(file-name-directory buffer-file-name)
  with open("../_CoqProject") as f:
      result = ""
      for l in f:
	  if l[:2] == "-R":
	      pre, post = l[3:].split()
	      result += "Add Rec LoadPath \"" + pre + "\" as " + post + ".\n"
	  # elif l[:4] == "src/":
	  #     result += "Load " + l[4:-2] + "\n"
      return "Reset Initial.\nCd \""+loc+"../\".\n" + result
#+end_src
#+RESULTS: seginit
#+begin_src coq :results output silent
Reset Initial.
Cd "/home/au538501/Documents/LocalHacspec/hacspec/coq/src/../".
Add Rec LoadPath "src/" as Hacspec.
#+end_src

*** The includes
#+NAME: linum0
#+CALL: next(ARG="0 9", linum="0 0") :exports none
#+NAME: seg0
#+CALL: split-file(ARG=linum0) :eval
#+RESULTS: seg0
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
(** This file was automatically generated using Hacspec **)
Require Import Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.
Require Import Hacspec.Lib.

#+end_src

*** Types and default implementations
#+NAME: linum1
#+CALL: next(ARG="0 2", linum=linum0) :exports none
#+NAME: seg1
#+CALL: split-file(ARG=linum1) :eval
#+RESULTS: seg1
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'reject'" := (int32) : hacspec_scope.

#+end_src

#+NAME: linum2
#+CALL: next(ARG="0 2", linum=linum1) :exports none
#+NAME: seg2
#+CALL: split-file(ARG=linum2) :eval
#+RESULTS: seg2
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition reject_impl_deafult  : reject :=
  min.

#+end_src

#+NAME: linum3
#+CALL: next(ARG="0 2", linum=linum2) :exports none
#+NAME: seg3
#+CALL: split-file(ARG=linum3) :eval
#+RESULTS: seg3
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'option_reject'" := ((option reject)) : hacspec_scope.

#+end_src

#+NAME: linum4
#+CALL: next(ARG="0 2", linum=linum3) :exports none
#+NAME: seg4
#+CALL: split-file(ARG=linum4) :eval
#+RESULTS: seg4
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition new_reject_impl (x_0 : int32) : option_reject :=
  (if ((x_0) <.? (@repr WORDSIZE32 0)):bool then (@Some reject (x_0)) else (
      @None int32)).

#+end_src

*** Error handling
#+NAME: linum5
#+CALL: next(ARG="0 5", linum=linum4) :exports none
#+NAME: seg5
#+CALL: split-file(ARG=linum5) :eval
#+RESULTS: seg5
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition reject_impl_convert_from_unit  : reject :=
  (min) .+ (@repr WORDSIZE32 1).

Theorem ensures_reject_impl_convert_from_unit : forall result_1 ,
@reject_impl_convert_from_unit  = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof. 
  intros ; subst.
  reflexivity.
Qed.


#+end_src

#+NAME: linum6
#+CALL: next(ARG="0 5", linum=linum5) :exports none
#+NAME: seg6
#+CALL: split-file(ARG=linum6) :eval
#+RESULTS: seg6
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition reject_impl_convert_from_parse_error  : reject :=
  (min) .+ (@repr WORDSIZE32 2).

Theorem ensures_reject_impl_convert_from_parse_error : forall result_1 ,
@reject_impl_convert_from_parse_error  = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof. 
  intros ; subst.
  reflexivity.
Qed.

#+end_src

#+NAME: linum7
#+CALL: next(ARG="0 7", linum=linum6) :exports none
#+NAME: seg7
#+CALL: split-file(ARG=linum7) :eval
#+RESULTS: seg7
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Inductive log_error :=
| Full : log_error
| Malformed : log_error.

Definition reject_impl_from_log_error (le_2 : log_error) : reject :=
  match le_2 with
  | Full => (min) .+ (@repr WORDSIZE32 3)
  | Malformed => (min) .+ (@repr WORDSIZE32 4)
  end.

Theorem ensures_reject_impl_from_log_error : forall result_1 (le_2 : log_error),
@reject_impl_from_log_error le_2 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.  
  intros ; subst.
  destruct le_2 ; reflexivity.
Qed.

#+end_src

#+NAME: linum8
#+CALL: next(ARG="0 7", linum=linum7) :exports none
#+NAME: seg8
#+CALL: split-file(ARG=linum8) :eval
#+RESULTS: seg8
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Inductive new_contract_name_error :=
| NewContractNameErrorMissingInitPrefix : new_contract_name_error
| NewContractNameErrorTooLong : new_contract_name_error
| NewContractNameErrorContainsDot : new_contract_name_error
| NewContractNameErrorInvalidCharacters : new_contract_name_error.

Definition reject_impl_from_new_contract_name_error
  (nre_3 : new_contract_name_error)
  : reject :=
  match nre_3 with
  | NewContractNameErrorMissingInitPrefix => (min) .+ (@repr WORDSIZE32 5)
  | NewContractNameErrorTooLong => (min) .+ (@repr WORDSIZE32 6)
  | NewContractNameErrorContainsDot => (min) .+ (@repr WORDSIZE32 9)
  | NewContractNameErrorInvalidCharacters => (min) .+ (@repr WORDSIZE32 10)
  end.

Theorem ensures_reject_impl_from_new_contract_name_error : forall result_1 (
  nre_3 : new_contract_name_error),
@reject_impl_from_new_contract_name_error nre_3 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof. 
  intros ; subst.
  destruct nre_3 ; reflexivity.
Qed.

#+end_src

#+NAME: linum9
#+CALL: next(ARG="0 7", linum=linum8) :exports none
#+NAME: seg9
#+CALL: split-file(ARG=linum9) :eval
#+RESULTS: seg9
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Inductive new_receive_name_error :=
| NewReceiveNameErrorMissingDotSeparator : new_receive_name_error
| NewReceiveNameErrorTooLong : new_receive_name_error
| NewReceiveNameErrorInvalidCharacters : new_receive_name_error.

Definition reject_impl_from_new_receive_name_error
  (nre_4 : new_receive_name_error)
  : reject :=
  match nre_4 with
  | NewReceiveNameErrorMissingDotSeparator => (min) .+ (@repr WORDSIZE32 7)
  | NewReceiveNameErrorTooLong => (min) .+ (@repr WORDSIZE32 8)
  | NewReceiveNameErrorInvalidCharacters => (min) .+ (@repr WORDSIZE32 11)
  end.

Theorem ensures_reject_impl_from_new_receive_name_error : forall result_1 (
  nre_4 : new_receive_name_error),
@reject_impl_from_new_receive_name_error nre_4 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  destruct nre_4 ; reflexivity.
Qed.

#+end_src

*** Contract state
#+NAME: linum10
#+CALL: next(ARG="0 2", linum=linum9) :exports none
#+NAME: seg10
#+CALL: split-file(ARG=linum10) :eval
#+RESULTS: seg10
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'contract_state'" := (int32) : hacspec_scope.

#+end_src

#+NAME: linum11
#+CALL: next(ARG="0 4", linum=linum10) :exports none
#+NAME: seg11
#+CALL: split-file(ARG=linum11) :eval
#+RESULTS: seg11
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'seek_result'" := ((result (contract_state × int64
  ) unit)) : hacspec_scope.

Inductive seek_from :=
| Start : int64 -> seek_from
| End : int64 -> seek_from
| Current : int64 -> seek_from.

#+end_src

#+NAME: linum12
#+CALL: next(ARG="0 4", linum=linum11) :exports none
#+NAME: seg12
#+CALL: split-file(ARG=linum12) :eval
#+RESULTS: seg12
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'uint32_option'" := ((option int32)) : hacspec_scope.

Notation "'iint64_option'" := ((option int64)) : hacspec_scope.

#+end_src

#+NAME: linum13
#+CALL: next(ARG="0 2", linum=linum12) :exports none
#+NAME: seg13
#+CALL: split-file(ARG=linum13) :eval
#+RESULTS: seg13
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition contract_state_impl_seek
  (current_position_5 : contract_state)
  (pos_6 : seek_from)
  `{forall delta_7 : int64,
  pos_6 = End (delta_7) ->
  exists b_8 : int32,
  (pub_uint32_checked_add (current_position_5) (@cast _ uint32 _ (
        delta_7))) =.? (@Some int32 (b_8))}
  : seek_result :=
  match pos_6 with
  | Start offset_9 => @Ok (contract_state × int64) unit ((
      @cast _ uint32 _ (offset_9),
      offset_9
    ))
  | End delta_10 => (if ((delta_10) >=.? (@repr WORDSIZE64 0)):bool then (
      match pub_uint32_checked_add (current_position_5) (@cast _ uint32 _ (
          delta_10)) with
      | Some b_11 => @Ok (contract_state × int64) unit ((
          b_11,
          @cast _ uint64 _ (delta_10)
        ))
      | None => @Err (contract_state × int64) unit (tt)
      end) else (match pub_int64_checked_abs (delta_10) with
      | Some b_12 => @Ok (contract_state × int64) unit ((
          (@repr WORDSIZE32 4) .- (@cast _ uint32 _ (b_12)),
          @cast _ uint64 _ ((@repr WORDSIZE32 4) .- (@cast _ uint32 _ (b_12)))
        ))
      | None => @Err (contract_state × int64) unit (tt)
      end))
  | Current delta_13 => (if ((delta_13) >=.? (@repr WORDSIZE64 0)):bool then (
      match pub_uint32_checked_add (current_position_5) (@cast _ uint32 _ (
          delta_13)) with
      | Some offset_14 => @Ok (contract_state × int64) unit ((
          offset_14,
          @cast _ uint64 _ (offset_14)
        ))
      | None => @Err (contract_state × int64) unit (tt)
      end) else (match pub_int64_checked_abs (delta_13) with
      | Some b_15 => match pub_uint32_checked_sub (current_position_5) (
        @cast _ uint32 _ (b_15)) with
      | Some offset_16 => @Ok (contract_state × int64) unit ((
          offset_16,
          @cast _ uint64 _ (offset_16)
        ))
      | None => @Err (contract_state × int64) unit (tt)
      end
      | None => @Err (contract_state × int64) unit (tt)
      end))
  end.

#+end_src

**** Contract state - Read Trait
#+NAME: linum14
#+CALL: next(ARG="0 5", linum=linum13) :exports none
#+NAME: seg14
#+CALL: split-file(ARG=linum14) :eval
#+RESULTS: seg14
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition load_state_hacspec
  (buf_17 : public_byte_seq)
  (offset_18 : int32)
  : (public_byte_seq × int32) :=
  (buf_17, @repr WORDSIZE32 1).

Theorem ensures_load_state_hacspec : forall result_1 (
  buf_17 : public_byte_seq) (offset_18 : int32),
@load_state_hacspec buf_17 offset_18 = result_1 ->
(result_1) !=.? ((buf_17, @repr WORDSIZE32 2)).
Proof.
  intros ; subst.
  unfold negb.
  cbn.
  rewrite list_eqdec_refl.
  cbn.
  rewrite (@eq_false WORDSIZE32 (repr 1) (repr 2)) ; easy.
Qed.  

#+end_src

#+NAME: linum15
#+CALL: next(ARG="0 8", linum=linum14) :exports none
#+NAME: seg15
#+CALL: split-file(ARG=linum15) :eval
#+RESULTS: seg15
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition contract_state_impl_read_read
  (current_position_19 : contract_state)
  (buf_20 : public_byte_seq)
  : (contract_state × uint_size) :=
  let '(buf_21, num_read_22) :=
    load_state_hacspec (buf_20) (current_position_19) in 
  ((current_position_19) .+ (num_read_22), @cast _ uint32 _ (num_read_22)).

Definition contract_state_impl_read_read_u64
  (current_position_23 : contract_state)
  (num_read_24 : int32)
  : (contract_state × bool) :=
  (
    (current_position_23) .+ (num_read_24),
    (num_read_24) =.? (@repr WORDSIZE32 8)
  ).

Definition contract_state_impl_read_read_u32
  (current_position_25 : contract_state)
  (num_read_26 : int32)
  : (contract_state × bool) :=
  (
    (current_position_25) .+ (num_read_26),
    (num_read_26) =.? (@repr WORDSIZE32 4)
  ).

Definition contract_state_impl_read_read_u8
  (current_position_27 : contract_state)
  (num_read_28 : int32)
  : (contract_state × bool) :=
  (
    (current_position_27) .+ (num_read_28),
    (num_read_28) =.? (@repr WORDSIZE32 1)
  ).

#+end_src

**** Contract state - Write Trait
#+NAME: linum16
#+CALL: next(ARG="0 4", linum=linum15) :exports none
#+NAME: seg16
#+CALL: split-file(ARG=linum16) :eval
#+RESULTS: seg16
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition write_impl_for_contract_state_test
  (current_position_29 : contract_state)
  (len_30 : int32)
  : bool :=
  option_is_none (pub_uint32_checked_add (current_position_29) (len_30)).

Definition write_impl_for_contract_state
  (current_position_31 : contract_state)
  (num_bytes_32 : int32)
  : (contract_state × uint_size) :=
  ((current_position_31) .+ (num_bytes_32), @cast _ uint32 _ (num_bytes_32)).

#+end_src

**** Contract State - Misc.
#+NAME: linum17
#+CALL: next(ARG="0 10", linum=linum16) :exports none
#+NAME: seg17
#+CALL: split-file(ARG=linum17) :eval
#+RESULTS: seg17
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition has_contract_state_impl_for_contract_state_open  : contract_state :=
  @repr WORDSIZE32 0.

Definition has_contract_state_impl_for_contract_state_reserve_0
  (len_33 : int32)
  (cur_size_34 : int32)
  : bool :=
  (cur_size_34) <.? (len_33).

Definition has_contract_state_impl_for_contract_state_reserve_1
  (res_35 : int32)
  : bool :=
  (res_35) =.? (@repr WORDSIZE32 1).

Definition has_contract_state_impl_for_contract_state_truncate_0
  (cur_size_36 : int32)
  (new_size_37 : int32)
  : bool :=
  (cur_size_36) >.? (new_size_37).

Definition has_contract_state_impl_for_contract_state_truncate_1
  (current_position_38 : contract_state)
  (new_size_39 : int32)
  : contract_state :=
  (if ((new_size_39) <.? (current_position_38)):bool then (new_size_39) else (
      current_position_38)).

#+end_src

*** Parameter
#+NAME: linum18
#+CALL: next(ARG="0 4", linum=linum17) :exports none
#+NAME: seg18
#+CALL: split-file(ARG=linum18) :eval
#+RESULTS: seg18
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'parameter'" := (int32) : hacspec_scope.

Definition read_impl_for_parameter_read
  (current_position_40 : parameter)
  (num_read_41 : int32)
  : (parameter × uint_size) :=
  ((current_position_40) .+ (num_read_41), @cast _ uint32 _ (num_read_41)).

#+end_src

*** Attributes Cursor
#+NAME: linum19
#+CALL: next(ARG="0 -1", linum=linum18) :exports none
#+NAME: seg19
#+CALL: split-file(ARG=linum19) :eval
#+RESULTS: seg19
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'attributes_cursor'" := ((int32 × int16)) : hacspec_scope.

Definition has_policy_impl_for_policy_attributes_cursor_next_test
  (policy_attribute_items_42 : attributes_cursor)
  : bool :=
  let '(_, remaining_items_43) :=
    policy_attribute_items_42 in 
  (remaining_items_43) =.? (@repr WORDSIZE16 0).

Definition has_policy_impl_for_policy_attributes_cursor_next_tag_invalid
  (policy_attribute_items_44 : attributes_cursor)
  (tag_value_len_1_45 : int8)
  (num_read_46 : int32)
  : (attributes_cursor × bool) :=
  let '(current_position_47, remaining_items_48) :=
    policy_attribute_items_44 in 
  let policy_attribute_items_49 : (int32 × int16) :=
    ((current_position_47) .+ (num_read_46), remaining_items_48) in 
  (policy_attribute_items_49, (tag_value_len_1_45) >.? (@repr WORDSIZE8 31)).

Definition has_policy_impl_for_policy_attributes_cursor_next
  (policy_attribute_items_50 : attributes_cursor)
  (num_read_51 : int32)
  : attributes_cursor :=
  let '(current_position_52, remaining_items_53) :=
    policy_attribute_items_50 in 
  (
    (current_position_52) .+ (num_read_51),
    (remaining_items_53) .- (@repr WORDSIZE16 1)
  ).

#+end_src
