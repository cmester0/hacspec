#+TITLE: Concordium Smartcontract Infrastructure Implementations
#+AUTHOR: Lasse Letager Hansen

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file

* Concordium "Impls" specification
** Config
#+BEGIN_SRC toml :tangle ../../examples/concordium_impls/Cargo.toml :eval never
  [package]
  name = "concordium_impls"
  version = "0.1.0"
  authors = [""]
  edition = "2018"

  [lib]
  path = "src/concordium_impls.rs"

  [dependencies]
  hacspec-lib = { path = "../../lib" }
  hacspec-attributes = { path = "../../utils/attributes", version = "0.1.0-beta.1" , features = ["print_attributes", "hacspec_unsafe"] } # , features = ["hacspec_unsafe"] , , optional = true
  # pearlite-syn = { path = "../../../../creusot/pearlite-syn" }
  creusot-contracts = { path = "../../../../creusot/creusot-contracts" }
  concordium-contracts-common = { path = "../../../../concordium-rust-smart-contracts/concordium-contracts-common" }
  concordium-std = { path = "../../../../concordium-rust-smart-contracts/concordium-std" }

  [features]
  use_attributes = ["hacspec-attributes/print_attributes", "hacspec-attributes/hacspec_unsafe"]

  [dev-dependencies]
  hacspec-dev = { path = "../../utils/dev" }
  criterion = "0.3"
  rand = "0.8"
#+END_SRC

** Imports
#+BEGIN_SRC rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern crate hacspec_lib;

  use hacspec_lib::*;

  // #[cfg(feature = "hacspec_attributes")]
  #[cfg(feature = "hacspec")]
  use hacspec_attributes::*;

  // Rust-hacspec Interface
  #[cfg(not(feature = "hacspec"))]
  extern crate concordium_std;
  #[cfg(not(feature = "hacspec"))]
  use concordium_std::*;

  #[cfg(not(feature = "hacspec"))]
  // use ::std::collections::{BTreeMap, BTreeSet};
  use ::std::{
      collections::{BTreeMap, BTreeSet},
      convert::{self, TryFrom, TryInto},
      hash::Hash,
      mem, num, // prims,
      // prims::*,
      // traits::*,
      // types::*,
      vec::Vec,
      // String,
  };

  // #[cfg(not(feature = "hacspec"))]
  // extern crate concordium_contracts_common;
  // #[cfg(not(feature = "hacspec"))]
  // use concordium_contracts_common::*;

  #[cfg(not(feature = "hacspec"))]
  use mem::MaybeUninit;

  // Creusot
  #[cfg(not(feature = "hacspec"))]
  extern crate creusot_contracts;
  #[cfg(not(feature = "hacspec"))]
  use creusot_contracts::*;
#+END_SRC

** Rust code
*** Reject
The ~Rust~ definition for Reject is
#+begin_src rust :tangle no :eval never
  /// An error message, signalling rejection of a smart contract invocation.
  /// The client will see the error code as a reject reason; if a schema is
  /// provided, the error message corresponding to the error code will be
  /// displayed. The valid range for an error code is from i32::MIN to  -1.
  #[derive(Eq, PartialEq, Debug)]
  #[repr(transparent)]
  pub struct Reject {
      pub error_code: crate::num::NonZeroI32,
  }

  /// Default error is i32::MIN.
  impl Default for Reject {
      #[inline(always)]
      fn default() -> Self {
	  Self {
	      error_code: unsafe { crate::num::NonZeroI32::new_unchecked(i32::MIN) },
	  }
      }
  }

  impl Reject {
      /// This returns `None` for all values >= 0 and `Some` otherwise.
      pub fn new(x: i32) -> Option<Self> {
	  if x < 0 {
	      let error_code = unsafe { crate::num::NonZeroI32::new_unchecked(x) };
	      Some(Reject { error_code })
	  } else {
	      None
	  }
      }
  }
#+end_src
# NonZeroI32 is located in rust/library/core/src/num/nonzero.rs
We modle reject as the underlying data, that is the src_rust[:eval never]{i32} error code. The default constructor is i32 min.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  #[derive(Eq, PartialEq, Debug)]
  #[repr(transparent)]
  pub struct Reject {
      pub error_code: crate::num::NonZeroI32,
  }

  pub type RejectHacspec = i32;

  pub fn reject_impl_deafult() -> RejectHacspec {
      i32::MIN
  }

#+end_src
We then implement the new operations for Reject.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub fn new_reject_impl(x: i32) -> Option<RejectHacspec> {
      if x < 0i32 {
	  Option::<i32>::Some(x)
      } else {
	  Option::<i32>::None
      }
  }

#+end_src
We define the coercion function for Reject, and implement the traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_reject(hacspec_reject: RejectHacspec) -> Reject {
      Reject {
	  error_code: unsafe { num::NonZeroI32::new_unchecked(hacspec_reject) },
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// Default error is i32::MIN.
  impl Default for Reject {
      #[inline(always)]
      fn default() -> Self {
	  Self {
	      error_code: unsafe { crate::num::NonZeroI32::new_unchecked(i32::MIN) },
	  }
      }
  }

  #[cfg(not(feature = "hacspec"))]
  impl Reject {
      /// This returns `None` for all values >= 0 and `Some` otherwise.
      pub fn new(x: i32) -> Option<Self> {
	  if x < 0 {
	      let error_code = unsafe { crate::num::NonZeroI32::new_unchecked(x) };
	      Some(Reject { error_code })
	  } else {
	      None
	  }
      }
  }  
#+end_src

**** Reject - From trait
#+begin_src rust :tangle no :eval never
  impl convert::From<()> for Reject {
      #[inline(always)]
      fn from(_: ()) -> Self {
	  Reject {
	      error_code: unsafe { num::NonZeroI32::new_unchecked(i32::MIN + 1) },
	  }
      }
  }

  impl convert::From<ParseError> for Reject {
      #[inline(always)]
      fn from(_: ParseError) -> Self {
	  Reject {
	      error_code: unsafe { num::NonZeroI32::new_unchecked(i32::MIN + 2) },
	  }
      }
  }
#+end_src

We modle the unsafe block with unchecked non zero as a precondition using requires giving us the hacspec equivalent
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[ensures(result != 0i32)]
  pub fn reject_impl_convert_from_unit() -> RejectHacspec {
      i32::MIN + 1i32
  }

  #[ensures(result != 0i32)]
  pub fn reject_impl_convert_from_parse_error() -> RejectHacspec {
      i32::MIN + 2i32
  }
#+end_src
We then implement the traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  impl convert::From<()> for Reject {
      #[inline(always)]
      fn from(_: ()) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_convert_from_unit())
      }
  }
  
  #[cfg(not(feature = "hacspec"))]
  impl convert::From<ParseError> for Reject {
      #[inline(always)]
      fn from(_: ParseError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_convert_from_parse_error())
      }
  }
#+end_src
We define a log error type and function converting from it to the reject type
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  /// Errors that can occur during logging.
  #[derive(Copy, Clone)] // , Debug, Eq, PartialEq
  #[repr(u8)]
  pub enum LogError {
      /// The log is full.
      Full,
      /// The message to log was malformed (e.g., too long)
      Malformed,
  }

  #[ensures(result != 0i32)]
  pub fn reject_impl_from_log_error(le: LogError) -> RejectHacspec {
      match le {
	  LogError::Full => i32::MIN + 3i32,
	  LogError::Malformed => i32::MIN + 4i32,
      }
  }

#+end_src
We then implement the traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Full is mapped to i32::MIN+3, Malformed is mapped to i32::MIN+4.
  impl From<LogError> for Reject {
      #[inline(always)]
      fn from(le: LogError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_from_log_error(le))
      }
  }

#+end_src
We define a type for new contract name errors and conversion from it to reject
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[derive(Clone)] // , Debug, PartialEq, Eq
  pub enum NewContractNameError {
      NewContractNameErrorMissingInitPrefix,
      NewContractNameErrorTooLong,
      NewContractNameErrorContainsDot,
      NewContractNameErrorInvalidCharacters,
  }

  #[ensures(result != 0i32)]
  pub fn reject_impl_from_new_contract_name_error(nre: NewContractNameError) -> RejectHacspec {
      match nre {
	  NewContractNameError::NewContractNameErrorMissingInitPrefix => i32::MIN + 5i32,
	  NewContractNameError::NewContractNameErrorTooLong => i32::MIN + 6i32,
	  NewContractNameError::NewContractNameErrorContainsDot => i32::MIN + 9i32,
	  NewContractNameError::NewContractNameErrorInvalidCharacters => i32::MIN + 10i32,
      }
  }

#+end_src
We then implement the traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  /// MissingInitPrefix is mapped to i32::MIN + 5,
  /// TooLong to i32::MIN + 6,
  /// ContainsDot to i32::MIN + 9, and
  /// InvalidCharacters to i32::MIN + 10.
  impl From<NewContractNameError> for Reject {
      fn from(nre: NewContractNameError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_from_new_contract_name_error(nre))
      }
  }

#+end_src
We define a type for new receive name errors and conversion from it to reject
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[derive(Clone)] // , Debug, PartialEq, Eq
  pub enum NewReceiveNameError {
      NewReceiveNameErrorMissingDotSeparator,
      NewReceiveNameErrorTooLong,
      NewReceiveNameErrorInvalidCharacters,
  }

  #[ensures(result != 0i32)]
  pub fn reject_impl_from_new_receive_name_error(nre: NewReceiveNameError) -> RejectHacspec {
      match nre {
	  NewReceiveNameError::NewReceiveNameErrorMissingDotSeparator => i32::MIN + 7i32,
	  NewReceiveNameError::NewReceiveNameErrorTooLong => i32::MIN + 8i32,
	  NewReceiveNameError::NewReceiveNameErrorInvalidCharacters => i32::MIN + 11i32,
      }
  }

#+end_src
We then implement the traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  /// MissingDotSeparator is mapped to i32::MIN + 7,
  /// TooLong to i32::MIN + 8, and
  /// InvalidCharacters to i32::MIN + 11.
  impl From<NewReceiveNameError> for Reject {
      fn from(nre: NewReceiveNameError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_from_new_receive_name_error(nre))
      }
  }

#+end_src

*** Contract state
We define contract state as its inner state namely the current position of the src_rust[:eval never]{u32} type.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  /// A type representing the constract state bytes.
  #[derive(Default)]
  pub struct ContractState {
      pub(crate) current_position: u32,
  }

  pub type ContractStateHacspec = u32;
  
#+end_src
**** Contract State -- Seek
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[derive(Copy, Clone)] // , Debug, PartialEq, Eq
  pub enum SeekFrom {
      /// Sets the offset to the provided number of bytes.
      Start(u64),

      /// Sets the offset to the size of this object plus the specified number of
      /// bytes.
      ///
      /// It is possible to seek beyond the end of an object, but it's an error to
      /// seek before byte 0.
      End(i64),

      /// Sets the offset to the current position plus the specified number of
      /// bytes.
      ///
      /// It is possible to seek beyond the end of an object, but it's an error to
      /// seek before byte 0.
      Current(i64),
  }

  pub type U32Option = Option<u32>;
  pub type I64Option = Option<i64>;

  // #[requires(forall<delta : i64> pos === SeekFrom::End(delta) ==> exists<b : u32> current_position.checked_add(delta as u32) == U32Option::Some(b))]
  pub fn contract_state_impl_seek(current_position: ContractStateHacspec, pos: SeekFrom) -> Result<(ContractStateHacspec, u64), ()> {
      match pos {
	  SeekFrom::Start(offset) => Result::<(ContractStateHacspec, u64), ()>::Ok((offset as u32, offset)),
	  SeekFrom::End(delta) => {
	      if delta >= 0_i64 {
		  match current_position.checked_add(delta as u32) {
		      U32Option::Some(b) => Result::<(ContractStateHacspec, u64), ()>::Ok((b, delta as u64)),
		      U32Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
		  }
	      } else {
		  match delta.checked_abs() {
		      I64Option::Some(b) =>
		      {
			  Result::<(ContractStateHacspec, u64), ()>::Ok(((4_u32 - (b as u32)), (4_u32 - (b as u32)) as u64))
		      }
		      I64Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
		  }
	      }
	  }
	  SeekFrom::Current(delta) => {
	      if delta >= 0_i64 {
		  match current_position.checked_add(delta as u32) {
		      U32Option::Some(offset) => Result::<(ContractStateHacspec, u64), ()>::Ok((offset, offset as u64)),
		      U32Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
		  }
	      } else {
		  match delta.checked_abs() {
		      I64Option::Some(b) => match current_position.checked_sub(b as u32) {
			  U32Option::Some(offset) => Result::<(ContractStateHacspec, u64), ()>::Ok((offset, offset as u64)),
			  U32Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
		      },
		      I64Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
		  }
	      }
	  }
      }
  }
#+end_src
We then implement the traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_contract_state(
      rust_contract_state: &mut ContractState,
  ) -> ContractStateHacspec {
      rust_contract_state.current_position.clone()
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_contract_state(
      rust_contract_state: &mut ContractState,
      hacspec_contract_state: ContractStateHacspec,
  ) {
      rust_contract_state.current_position = hacspec_contract_state;
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_seek_result(
      rust_contract_state: &mut ContractState,
      hacspec_seek_result: Result<(ContractStateHacspec, u64), ()>,
  ) -> Result<u64, ()> {
      let (hacspec_result, rust_result) = hacspec_seek_result?;
      coerce_hacspec_to_rust_contract_state(rust_contract_state, hacspec_result);
      Ok(rust_result)
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_seek_from(rust_seek_from: concordium_std::SeekFrom) -> SeekFrom {
      match rust_seek_from {
	  concordium_std::SeekFrom::Start(v) => SeekFrom::Start(v),
	  concordium_std::SeekFrom::End(v) => SeekFrom::End(v),
	  concordium_std::SeekFrom::Current(v) => SeekFrom::Current(v),
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// # Contract state trait implementations.
  impl Seek for ContractState {
      type Err = ();

      fn seek(&mut self, pos: concordium_std::SeekFrom) -> Result<u64, Self::Err> {
	  let contract_state = coerce_rust_to_hacspec_contract_state(self);
	  coerce_hacspec_to_rust_seek_result(
	      self,
	      contract_state_impl_seek(
		  contract_state,
		  coerce_rust_to_hacspec_seek_from(pos),
	      ),
	  )
      }
  }
#+end_src

**** Contract State -- Load
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_public_byte_seq(buf: &[u8]) -> PublicByteSeq {
      PublicByteSeq::from_native_slice(buf)
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_public_byte_seq(buf: PublicByteSeq) -> Vec<u8> {
      let mut temp_vec: Vec<u8> = Vec::new();
      for i in 0..buf.len() {
	  temp_vec.push(buf.index(i).clone())
      }
      temp_vec
  }
#+end_src

#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn load_state(start: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn load_state_creusot(start: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { load_state(start, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  fn load_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn load_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      let result = load_state_creusot(temp.as_mut_ptr(), buf.len() as u32, offset);
      (
	  coerce_rust_to_hacspec_public_byte_seq(&temp),
	  result,
      )
  }

#+end_src

**** Contract State -- Read
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub fn contract_state_impl_read_read(
      current_position: ContractStateHacspec,
      buf : PublicByteSeq,
  ) -> (ContractStateHacspec, usize) {
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, num_read as usize)
  }

  /// Read a u32 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u64(
      current_position: ContractStateHacspec,
  ) -> (ContractStateHacspec, u64) {
      // let mut bytes: MaybeUninit<[u8; 8]> = MaybeUninit::uninit();
      let buf = PublicByteSeq::new(8);
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, u64_from_le_bytes(u64Word::from_seq(&buf))) // num_read as u64
  }

  /// Read a u32 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u32(
      current_position: ContractStateHacspec,
  ) -> (ContractStateHacspec, u32) {
      // let mut bytes: MaybeUninit<[u8; 4]> = MaybeUninit::uninit();
      let buf = PublicByteSeq::new(4);
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, u32_from_le_bytes(u32Word::from_seq(&buf))) // num_read as u64
  }

  /// Read a u8 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u8(
      current_position: ContractStateHacspec,
  ) -> (ContractStateHacspec, u8) {
      let buf = PublicByteSeq::new(1);
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, buf[0]) // num_read as u64
  }

#+end_src
We then implement the traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  impl Read for ContractState {
      fn read(&mut self, buf: &mut [u8]) -> ParseResult<usize> {
	  let (cs, nr) = contract_state_impl_read_read(
	      coerce_rust_to_hacspec_contract_state(self),
	      coerce_rust_to_hacspec_public_byte_seq(buf),
	  );
	  coerce_hacspec_to_rust_contract_state(self, cs);
	  Ok(nr)
      }

      // TODO: !! Probably incorrect !!
      /// Read a `u32` in little-endian format. This is optimized to not
      /// initialize a dummy value before calling an external function.
      fn read_u64(&mut self) -> ParseResult<u64> {
	  let (cs, nr) =
	      contract_state_impl_read_read_u64(coerce_rust_to_hacspec_contract_state(self));
	  coerce_hacspec_to_rust_contract_state(self, cs);
	  Ok(nr)
	  // if num_read == 8 {
	  //     unsafe { Ok(u64::from_le_bytes(bytes.assume_init())) }
	  // } else {
	  //     Err(ParseError::default())
	  // }
      }

      /// Read a `u32` in little-endian format. This is optimized to not
      /// initialize a dummy value before calling an external function.
      fn read_u32(&mut self) -> ParseResult<u32> {
	  let (cs, nr) =
	      contract_state_impl_read_read_u32(coerce_rust_to_hacspec_contract_state(self));
	  coerce_hacspec_to_rust_contract_state(self, cs);
	  Ok(nr)

	  // let mut bytes: MaybeUninit<[u8; 4]> = MaybeUninit::uninit();
	  // let num_read =
	  //     unsafe { load_state(bytes.as_mut_ptr() as *mut u8, 4, self.current_position) };
	  // self.current_position += num_read;
	  // if num_read == 4 {
	  //     unsafe { Ok(u32::from_le_bytes(bytes.assume_init())) }
	  // } else {
	  //     Err(ParseError::default())
	  // }
      }

      /// Read a `u8` in little-endian format. This is optimized to not
      /// initialize a dummy value before calling an external function.
      fn read_u8(&mut self) -> ParseResult<u8> {
	  let (cs, nr) =
	      contract_state_impl_read_read_u8(coerce_rust_to_hacspec_contract_state(self));
	  coerce_hacspec_to_rust_contract_state(self, cs);
	  Ok(nr)
      }
  }
#+end_src

**** Contract State -- Write
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn write_state(start: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn write_state_creusot(start: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { write_state(start, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  fn write_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn write_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      let result = write_state_creusot(temp.as_mut_ptr(), buf.len() as u32, offset);
      (
	  coerce_rust_to_hacspec_public_byte_seq(&temp),
	  result,
      )
  }

  pub fn contract_state_impl_write(
      current_position: ContractStateHacspec,
      buf : PublicByteSeq
  ) -> Result<(ContractStateHacspec, usize), ()> {
      if current_position.checked_add(buf.len() as u32).is_none() {
	  Result::<(ContractStateHacspec, usize), ()>::Err(())?;
      }
      let (buf, num_bytes) = write_state_hacspec(buf, current_position);
      Result::<(ContractStateHacspec, usize), ()>::Ok((current_position + num_bytes, num_bytes as usize))
  }

#+end_src
We then implement the traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  impl Write for ContractState {
      type Err = ();

      fn write(&mut self, buf: &[u8]) -> Result<usize, Self::Err> {
	  let (cs, nr) = contract_state_impl_write(
	      coerce_rust_to_hacspec_contract_state(self),
	      coerce_rust_to_hacspec_public_byte_seq(buf),
	  )?;
	  coerce_hacspec_to_rust_contract_state(self, cs);
	  Ok(nr)
      }
  }
#+end_src

**** Contract State -- Misc.
State size extern
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn state_size() -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn state_size_creusot() -> u32 {
      unsafe { state_size() }
  }

  #[cfg(feature = "hacspec")]
  fn state_size_hacspec() -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn state_size_hacspec() -> u32 {
      state_size_creusot()
  }
  
#+end_src
Resize state extern
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Resize state to the new value (truncate if new size is smaller). Return 0 if
      // this was unsuccesful (new state too big), or 1 if successful.
      pub(crate) fn resize_state(new_size: u32) -> u32; // returns 0 or 1.
							// get current state size in bytes.
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn resize_state_creusot(new_size: u32) -> u32 {
      unsafe { resize_state(new_size) }
  }

  #[cfg(feature = "hacspec")]
  fn resize_state_hacspec(new_size: u32) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn resize_state_hacspec(new_size: u32) -> u32 {
      resize_state_creusot(new_size)
  }
#+end_src

#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub fn has_contract_state_impl_for_contract_state_open() -> ContractStateHacspec {
      0_u32
  }

  // pub fn has_contract_state_impl_for_contract_state_reserve_0(len: u32, cur_size: u32) -> bool {
  //     cur_size < len
  // }

  // pub fn has_contract_state_impl_for_contract_state_reserve_1(res: u32) -> bool {
  //     res == 1_u32
  // }

  pub fn has_contract_state_impl_for_contract_state_reserve(
      contract_state: ContractStateHacspec,
      len: u32,
  ) -> bool {
      let cur_size = state_size_hacspec();
      if cur_size < len {
	  resize_state_hacspec(len) == 1_u32
      } else {
	  true
      }
  }

  pub fn has_contract_state_impl_for_contract_state_truncate(
      current_position : ContractStateHacspec,
      cur_size: u32,
      new_size: u32,
  ) -> ContractStateHacspec {
      if cur_size > new_size {
	  resize_state_hacspec(new_size);
      }
      if new_size < current_position {
	  new_size
      }
      else {
	  current_position
      }
  }
#+end_src
We then implement the traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  impl HasContractState<()> for ContractState {
      type ContractStateData = ();

      #[inline(always)]
      fn open(_: Self::ContractStateData) -> Self {
	  ContractState {
	      current_position: has_contract_state_impl_for_contract_state_open(),
	  }
      }

      fn reserve(&mut self, len: u32) -> bool {
	  has_contract_state_impl_for_contract_state_reserve(
	      coerce_rust_to_hacspec_contract_state(self),
	      len,
	  )
      }

      #[inline(always)]
      fn size(&self) -> u32 {
	  state_size_hacspec()
      }

      fn truncate(&mut self, new_size: u32) {
	  let current_position = coerce_rust_to_hacspec_contract_state(self);
	  coerce_hacspec_to_rust_contract_state(
	      self,
	      has_contract_state_impl_for_contract_state_truncate(
		  current_position,
		  self.size(),
		  new_size,
	      ),
	  )
      }
  }
  
#+end_src

*** Parameter
Extern for parameter section
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Write a section of the parameter to the given location. Return the number
      // of bytes written. The location is assumed to contain enough memory to
      // write the requested length into.
      pub(crate) fn get_parameter_section(param_bytes: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_parameter_section_creusot(start: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { get_parameter_section(start, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  fn get_parameter_section_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_parameter_section_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      let result = get_parameter_section_creusot(temp.as_mut_ptr(), buf.len() as u32, offset);
      (
	  coerce_rust_to_hacspec_public_byte_seq(&temp),
	  result,
      )
  }

#+end_src
We define parameter
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  #[derive(Default)]
  /// A type representing the parameter to init and receive methods.
  pub struct Parameter {
      pub(crate) current_position: u32,
  }

  pub type ParameterHacspec = u32;

  pub fn read_impl_for_parameter_read(
      current_position: ParameterHacspec,
      buf: PublicByteSeq,
  ) -> (ParameterHacspec, usize) {
      let (buf, num_read) = get_parameter_section_hacspec(buf, current_position);
      (current_position + num_read, num_read as usize)
  }

#+end_src
We then implement the traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_parameter(
      rust_parameter: &mut Parameter,
  ) -> ParameterHacspec {
      rust_parameter.current_position.clone()
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_parameter(
      rust_parameter: &mut Parameter,
      hacspec_parameter: ParameterHacspec,
  ) {
      rust_parameter.current_position = hacspec_parameter;
  }

  
  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for Parameter
  impl Read for Parameter {
      fn read(&mut self, buf: &mut [u8]) -> ParseResult<usize> {
	  let (cs, nr) = read_impl_for_parameter_read(
	      coerce_rust_to_hacspec_parameter(self),
	      coerce_rust_to_hacspec_public_byte_seq(buf),
	  );
	  coerce_hacspec_to_rust_parameter(self, cs);
	  Ok(nr)
      }
  }

#+end_src
Extern for parameter size and ~HasParameter~ trait.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Get the size of the parameter to the method (either init or receive).
      pub(crate) fn get_parameter_size() -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_parameter_size_creusot() -> u32 {
      unsafe { get_parameter_size() }
  }

  #[cfg(feature = "hacspec")]
  fn get_parameter_size_hacspec() -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_parameter_size_hacspec() -> u32 {
      get_parameter_size_creusot()
  }

  #[cfg(not(feature = "hacspec"))]
  impl HasParameter for Parameter {
      #[inline(always)]
      fn size(&self) -> u32 {
	  get_parameter_size_hacspec()
      }
  }

#+end_src
*** ChainMetaExtern
Get slot time extern
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Getters for the chain meta data
    /// Slot time (in milliseconds) from chain meta data
    pub(crate) fn get_slot_time() -> u64;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_slot_time_creusot() -> u64 {
      unsafe { get_slot_time() }
  }

  #[cfg(feature = "hacspec")]
  fn get_slot_time_hacspec() -> u64 {
      1u64
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_slot_time_hacspec() -> u64 {
      get_slot_time_creusot()
  }
#+end_src
We define and implement traits for ~ChainMetaExtern~.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  #[doc(hidden)]
  pub struct ChainMetaExtern {}

  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for the chain metadata.
  impl HasChainMetadata for ChainMetaExtern {
      #[inline(always)]
      fn slot_time(&self) -> SlotTime {
	  Timestamp::from_timestamp_millis(get_slot_time_hacspec() )
      }
  }
#+end_src

*** AttributesCursor
Get policy section extern
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Write a section of the policy to the given location. Return the number
    // of bytes written. The location is assumed to contain enough memory to
    // write the requested length into.
    pub(crate) fn get_policy_section(policy_bytes: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_policy_section_creusot(policy_bytes: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { get_policy_section(policy_bytes, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  fn get_policy_section_hacspec(policy_bytes: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (policy_bytes, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_policy_section_hacspec(policy_bytes: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(policy_bytes.clone())[..];
      let result = get_policy_section_creusot(temp.as_mut_ptr(), policy_bytes.len() as u32, offset);
      (
	  coerce_rust_to_hacspec_public_byte_seq(&temp),
	  result,
      )
  }

#+end_src


#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  /// A type representing the attributes, lazily acquired from the host.
  #[derive(Default)]
  pub struct AttributesCursor {
      /// Current position of the cursor, starting from 0.
      /// Note that this is only for the variable attributes.
      /// `created_at` and `valid_to` will require.
      pub(crate) current_position: u32,
      /// The number of remaining items in the policy.
      pub(crate) remaining_items: u16,
  }

  // pub struct AttributeTag(pub u8);
  pub type AttributesCursorHacspec = (u32, u16);

  // pub fn has_policy_impl_for_policy_attributes_cursor_next_test(
  //     policy_attribute_items: AttributesCursorHacspec,
  // ) -> bool {
  //     let (_, remaining_items) = policy_attribute_items;
  //     remaining_items == 0_u16
  // }

  // pub fn has_policy_impl_for_policy_attributes_cursor_next_tag_invalid(
  //     policy_attribute_items: AttributesCursorHacspec,
  //     tag_value_len_1: u8,
  //     num_read: u32,
  // ) -> (AttributesCursorHacspec, bool) {
  //     let (current_position, remaining_items) = policy_attribute_items;
  //     let policy_attribute_items = (current_position + num_read, remaining_items);
  //     (policy_attribute_items, tag_value_len_1 > 31_u8)
  // }

  pub fn has_policy_impl_for_policy_attributes_cursor_next_item(
      policy_attribute_items: AttributesCursorHacspec,
      buf: PublicByteSeq,
  ) -> Option<(AttributesCursorHacspec, (u8, u8))> {

      let (mut current_position, mut remaining_items) = policy_attribute_items;

      // // TODO: implement ? for option types and uncomment
      // if remaining_items == 0u16 {
      //     Option::<(AttributesCursorHacspec, (AttributeTag, u8))>::None?;
      // }

      let mut tag_value_len = PublicByteSeq::new(2);
      let (tag_value_len, num_read) = get_policy_section_hacspec(tag_value_len, current_position);
      current_position = current_position + num_read;

      // // TODO: implement ? for option types and uncomment
      // if tag_value_len[1] > 31u8 {
      //     // Should not happen because all attributes fit into 31 bytes.
      //     Option::<(AttributesCursorHacspec, (AttributeTag, u8))>::None?;
      // }

      let (buf, num_read) = get_policy_section_hacspec(buf, current_position);
      current_position = current_position + num_read;
      remaining_items = remaining_items - 1u16;
      Option::<(AttributesCursorHacspec, (u8, u8))>::Some(((current_position, remaining_items), (tag_value_len[0], tag_value_len[1])))
  }
  
#+end_src
We then define traits
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_attributes_cursor(
      rust_attributes_cursor: &mut AttributesCursor,
  ) -> AttributesCursorHacspec {
      (rust_attributes_cursor.current_position.clone(), rust_attributes_cursor.remaining_items.clone())
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_attributes_cursor(
      rust_attributes_cursor: &mut AttributesCursor,
      hacspec_attributes_cursor: AttributesCursorHacspec,
  ) {
      let (current_position, remaining_items) = hacspec_attributes_cursor;
      rust_attributes_cursor.current_position = current_position;
      rust_attributes_cursor.remaining_items = remaining_items;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Policy on the credential of the account.
  ///
  /// This is one of the key features of the Concordium blockchain. Each account
  /// on the chain is backed by an identity. The policy is verified and signed by
  /// the identity provider before an account can be created on the chain.
  ///
  /// The type is parameterized by the choice of `Attributes`. These are either
  /// borrowed or owned, in the form of an iterator over key-value pairs or a
  /// vector of such. This flexibility is needed so that attributes can be
  /// accessed efficiently, as well as constructed conveniently for testing.
  #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
  #[derive(Debug, Clone)]
  pub struct Policy<Attributes> {
      /// Identity of the identity provider who signed the identity object that
      /// this policy is derived from.
      pub identity_provider: IdentityProvider,
      /// Timestamp at the beginning of the month when the identity object backing
      /// this policy was created. This timestamp has very coarse granularity
      /// in order for the identity provider to not be able to link identities
      /// they have created with accounts that users created on the chain.
      /// as a timestamp (which has millisecond granularity) in order to make it
      /// easier to compare with, e.g., `slot_time`.
      pub created_at: Timestamp,
      /// Beginning of the month where the identity is __no longer valid__.
      pub valid_to: Timestamp,
      /// List of attributes, in ascending order of the tag.
      pub items: Attributes,
  }

  #[cfg(not(feature = "hacspec"))]
  impl HasPolicy for Policy<AttributesCursor> {
      fn identity_provider(&self) -> IdentityProvider {
	  self.identity_provider
      }

      fn created_at(&self) -> Timestamp {
	  self.created_at
      }

      fn valid_to(&self) -> Timestamp {
	  self.valid_to
      }

      fn next_item(&mut self, buf: &mut [u8; 31]) -> Option<(AttributeTag, u8)> {	  
	  let (ac, (at, v)) = has_policy_impl_for_policy_attributes_cursor_next_item(
	      coerce_rust_to_hacspec_attributes_cursor(&mut self.items),
	      coerce_rust_to_hacspec_public_byte_seq(buf),
	  )?;
	  coerce_hacspec_to_rust_attributes_cursor(&mut self.items, ac);
	  Some ((AttributeTag(at),v))
      }
  }
#+end_src

*** Policy iterator
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  /// An iterator over policies using host functions to supply the data.
  /// The main interface to using this type is via the methods of the [Iterator](https://doc.rust-lang.org/std/iter/trait.Iterator.html)
  /// and [ExactSizeIterator](https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html) traits.
  pub struct PoliciesIterator {
      /// Position in the policies binary serialization.
      pos: u32,
      /// Number of remaining items in the stream.
      remaining_items: u16,
  }

  pub type PoliciesIteratorHacspec = (u32, u16);

  // TODO: use PolicyAttributesCursorHacspec for implementation above instead of just AttributesCursorHacspec
  pub type PolicyAttributesCursorHacspec = (u32, u64, u64, AttributesCursorHacspec); // IdentityProvider, Timestamp, Timestamp, AttributesCursor

  fn iterator_impl_for_policies_iterator_next(policies_iterator : PoliciesIteratorHacspec) -> Option<(PoliciesIteratorHacspec, PolicyAttributesCursorHacspec)> {
      let (mut pos, _) = policies_iterator;
      // // TODO: implement ? for option types and uncomment
      // if remaining_items == 0 {
      //     None?;
      // }

      // 2 for total size of this section, 4 for identity_provider,
      // 8 bytes for created_at, 8 for valid_to, and 2 for
      // the length
      let (buf, _) = get_policy_section_hacspec(PublicByteSeq::new(2 + 4 + 8 + 8 + 2), pos);
      let skip_part: PublicByteSeq = buf.slice_range(0..2);
      let ip_part: PublicByteSeq = buf.slice_range(2..2 + 4);
      let created_at_part: PublicByteSeq = buf.slice_range(2 + 4..2 + 4 + 8);
      let valid_to_part: PublicByteSeq = buf.slice_range(2 + 4 + 8..2 + 4 + 8 + 8);
      let len_part: PublicByteSeq = buf.slice_range(2 + 4 + 8 + 8..2 + 4 + 8 + 8 + 2);
      let identity_provider = u32_from_le_bytes(u32Word::from_seq(&ip_part)); // IdentityProvider = u32 // UnsignedPublicInteger
      let created_at = u64_from_le_bytes(u64Word::from_seq(&created_at_part)); // Timestamp = Timestamp::from_timestamp_millis(u64)
      let valid_to = u64_from_le_bytes(u64Word::from_seq(&valid_to_part)); // Timestamp = u64)
      let mut remaining_items = u16_from_le_bytes(u16Word::from_seq(&len_part));
      let attributes_start = pos + 2u32 + 4u32 + 8u32 + 8u32 + 2u32;
      pos = pos + (u16_from_le_bytes(u16Word::from_seq(&skip_part)) as u32) + 2u32;
      remaining_items = remaining_items - 1u16;
      Option::<(PoliciesIteratorHacspec, PolicyAttributesCursorHacspec)>::Some(((pos, remaining_items),
	    (
	  identity_provider,
	  created_at,
	  valid_to,
	  (
	      attributes_start,
	      remaining_items,
	  ),
      )))
  }

  #[cfg(not(feature = "hacspec"))]
  impl Iterator for PoliciesIterator {
      type Item = Policy<AttributesCursor>;

      fn next(&mut self) -> Option<Self::Item> {
	  let ((pos, remaining_items), (identity_provider, created_at, valid_to, (cp,ri))) = iterator_impl_for_policies_iterator_next((self.pos, self.remaining_items))?;

	  // TODO: make into coerce function
	  self.pos = pos;
	  self.remaining_items = remaining_items;

	  Some(Policy {
	      identity_provider,
	      created_at: Timestamp::from_timestamp_millis(created_at),
	      valid_to: Timestamp::from_timestamp_millis(valid_to),
	      items: AttributesCursor {
		  current_position: cp,
		  remaining_items: ri,
	      },
	  })
      }

      fn size_hint(&self) -> (usize, Option<usize>) {
	  let rem = self.remaining_items as usize;
	  (rem, Some(rem))
      }
  }

  #[cfg(not(feature = "hacspec"))]
  impl ExactSizeIterator for PoliciesIterator {
      #[inline(always)]
      fn len(&self) -> usize {
	  self.remaining_items as usize
      }
  }

#+end_src

*** External context
# TODO: Can we implement something like 'ExternContext<T>', which is genralized over a type 'T', in hacspec ??
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never :tangle no
  #[cfg(not(feature = "hacspec"))]
  impl<T: sealed::ContextType> HasCommonData for ExternContext<T> {
      type MetadataType = ChainMetaExtern;
      type ParamType = Parameter;
      type PolicyIteratorType = PoliciesIterator;
      type PolicyType = Policy<AttributesCursor>;

      #[inline(always)]
      fn metadata(&self) -> &Self::MetadataType {
	  &ChainMetaExtern {}
      }

      fn policies(&self) -> PoliciesIterator {
	  let mut buf: MaybeUninit<[u8; 2]> = MaybeUninit::uninit();
	  let buf = unsafe {
	      get_policy_section(buf.as_mut_ptr() as *mut u8, 2, 0);
	      buf.assume_init()
	  };
	  PoliciesIterator {
	      pos: 2, // 2 because we already read 2 bytes.
	      remaining_items: u16::from_le_bytes(buf),
	  }
      }

      #[inline(always)]
      fn parameter_cursor(&self) -> Self::ParamType {
	  Parameter {
	      current_position: 0,
	  }
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for the init context
  impl HasInitContext for ExternContext<crate::types::InitContextExtern> {
      type InitData = ();

      /// Create a new init context by using an external call.
      fn open(_: Self::InitData) -> Self {
	  ExternContext::default()
      }

      #[inline(always)]
      fn init_origin(&self) -> AccountAddress {
	  let mut bytes: MaybeUninit<[u8; ACCOUNT_ADDRESS_SIZE]> = MaybeUninit::uninit();
	  let ptr = bytes.as_mut_ptr();
	  let address = unsafe {
	      get_init_origin(ptr as *mut u8);
	      bytes.assume_init()
	  };
	  AccountAddress(address)
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for the receive context
  impl HasReceiveContext for ExternContext<crate::types::ReceiveContextExtern> {
      type ReceiveData = ();

      /// Create a new receive context
      fn open(_: Self::ReceiveData) -> Self {
	  ExternContext::default()
      }

      #[inline(always)]
      fn invoker(&self) -> AccountAddress {
	  let mut bytes: MaybeUninit<[u8; ACCOUNT_ADDRESS_SIZE]> = MaybeUninit::uninit();
	  let ptr = bytes.as_mut_ptr();
	  let address = unsafe {
	      get_receive_invoker(ptr as *mut u8);
	      bytes.assume_init()
	  };
	  AccountAddress(address)
      }

      #[inline(always)]
      fn self_address(&self) -> ContractAddress {
	  let mut bytes: MaybeUninit<[u8; 16]> = MaybeUninit::uninit();
	  let ptr = bytes.as_mut_ptr();
	  let address = unsafe {
	      get_receive_self_address(ptr as *mut u8);
	      bytes.assume_init()
	  };
	  match from_bytes(&address) {
	      Ok(v) => v,
	      Err(_) => crate::trap(),
	  }
      }

      #[inline(always)]
      fn self_balance(&self) -> Amount {
	  Amount::from_micro_gtu(unsafe { get_receive_self_balance() })
      }

      #[inline(always)]
      fn sender(&self) -> Address {
	  let mut bytes: MaybeUninit<[u8; 33]> = MaybeUninit::uninit();
	  let ptr = bytes.as_mut_ptr() as *mut u8;
	  unsafe {
	      get_receive_sender(ptr);
	      let tag = *ptr;
	      match tag {
		  0u8 => {
		      match from_bytes(core::slice::from_raw_parts(
			  ptr.add(1),
			  ACCOUNT_ADDRESS_SIZE,
		      )) {
			  Ok(v) => Address::Account(v),
			  Err(_) => crate::trap(),
		      }
		  }
		  1u8 => match from_bytes(core::slice::from_raw_parts(ptr.add(1), 16)) {
		      Ok(v) => Address::Contract(v),
		      Err(_) => crate::trap(),
		  },
		  _ => crate::trap(), // unreachable!("Host violated precondition."),
	      }
	  }
      }

      #[inline(always)]
      fn owner(&self) -> AccountAddress {
	  let mut bytes: MaybeUninit<[u8; ACCOUNT_ADDRESS_SIZE]> = MaybeUninit::uninit();
	  let ptr = bytes.as_mut_ptr();
	  let address = unsafe {
	      get_receive_owner(ptr as *mut u8);
	      bytes.assume_init()
	  };
	  AccountAddress(address)
      }
  }
#+end_src

*** Logger
# TODO: Implement logger
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never :tangle no  
  // #[cfg(not(feature = "hacspec"))]
  // /// #Implementations of the logger.
  // impl HasLogger for Logger {
  //     #[inline(always)]
  //     fn init() -> Self {
  //         Self { _private: () }
  //     }

  //     fn log_raw(&mut self, event: &[u8]) -> Result<(), LogError> {
  //         let res = unsafe { log_event(event.as_ptr(), event.len() as u32) };
  //         match res {
  //             1 => Ok(()),
  //             0 => Err(LogError::Full),
  //             _ => Err(LogError::Malformed),
  //         }
  //     }
  // }

#+end_src
*** Action
Extern accept
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn accept() -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn accept_creusot() -> u32 {
      unsafe { accept() }
  }

  #[cfg(feature = "hacspec")]
  fn accept_hacspec() -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn accept_hacspec() -> u32 {
      accept_creusot()
  }
  
#+end_src
Extern simple transfer
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Basic action to send tokens to an account.
    pub(crate) fn simple_transfer(addr_bytes: *const u8, amount: u64) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn simple_transfer_creusot(addr_bytes: *const u8, amount: u64) -> u32 {
      unsafe { simple_transfer(addr_bytes, amount) }
  }

  #[cfg(feature = "hacspec")]
  fn simple_transfer_hacspec(buf: PublicByteSeq, amount: u64) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn simple_transfer_hacspec(buf: PublicByteSeq, amount: u64) -> u32 {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      simple_transfer_creusot(temp.as_ptr(), amount)
  }

#+end_src
Extern send
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Send a message to a smart contract.
    pub(crate) fn send(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: *const u8,
        receive_name_len: u32,
        amount: u64,
        parameter: *const u8,
        parameter_len: u32,
    ) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn send_creusot(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: *const u8,
        receive_name_len: u32,
        amount: u64,
        parameter: *const u8,
        parameter_len: u32,
    ) -> u32 {
      unsafe { send(addr_index, addr_subindex, receive_name, receive_name_len, amount, parameter, parameter_len) }
  }

  #[cfg(feature = "hacspec")]
  fn send_hacspec(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: PublicByteSeq,
        amount: u64,
        parameter: PublicByteSeq,
    ) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn send_hacspec(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: PublicByteSeq,
        amount: u64,
        parameter: PublicByteSeq,
    ) -> u32 {
      let temp_receive_name = &mut coerce_hacspec_to_rust_public_byte_seq(receive_name.clone())[..];
      let temp_parameter = &mut coerce_hacspec_to_rust_public_byte_seq(parameter.clone())[..];
      send_creusot(addr_index, addr_subindex, temp_receive_name.as_ptr(), receive_name.len() as u32, amount, temp_parameter.as_ptr(), parameter.len() as u32)
  }

#+end_src
Extern combine and
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Combine two actions using normal sequencing. This is using the stack of
    // actions already produced.
    pub(crate) fn combine_and(l: u32, r: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn combine_and_creusot(l: u32, r: u32) -> u32 {
      unsafe { combine_and(l, r) }
  }

  #[cfg(feature = "hacspec")]
  fn combine_and_hacspec(l: u32, r: u32) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn combine_and_hacspec(l: u32, r: u32) -> u32 {
      combine_and_creusot(l,r)
  }

#+end_src
Extern combine or
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Combine two actions using normal sequencing. This is using the stack of
    // actions already produced.
    pub(crate) fn combine_or(l: u32, r: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn combine_or_creusot(l: u32, r: u32) -> u32 {
      unsafe { combine_or(l, r) }
  }

  #[cfg(feature = "hacspec")]
  fn combine_or_hacspec(l: u32, r: u32) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn combine_or_hacspec(l: u32, r: u32) -> u32 {
      combine_or_creusot(l,r)
  }

#+end_src

#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Actions that can be produced at the end of a contract execution. This
  /// type is deliberately not cloneable so that we can enforce that
  /// `and_then` and `or_else` can only be used when more than one event is
  /// created.
  ///
  /// This type is marked as `must_use` since functions that produce
  /// values of the type are effectful.
  #[must_use]
  pub struct Action {
      pub(crate) _private: u32,
  }

  #[cfg(not(feature = "hacspec"))]
  impl Action {
      pub fn tag(&self) -> u32 { self._private }
  }


  #[cfg(not(feature = "hacspec"))]
  /// #Implementation of actions.
  /// These actions are implemented by direct calls to host functions.
  impl HasActions for Action {
      #[inline(always)]
      fn accept() -> Self {
	  Action {
	      _private: accept_hacspec(),
	  }
      }

      #[inline(always)]
      fn simple_transfer(acc: &AccountAddress, amount: Amount) -> Self {
	  let res = simple_transfer_hacspec(coerce_rust_to_hacspec_public_byte_seq(&acc.0), amount.micro_gtu);
	  Action { _private: res }
      }

      #[inline(always)]
      fn send_raw(
	  ca: &ContractAddress,
	  receive_name: ReceiveName,
	  amount: Amount,
	  parameter: &[u8],
      ) -> Self {
	  let receive_bytes = receive_name.get_chain_name().as_bytes();
	  let res = 
	      send_hacspec(
		  ca.index,
		  ca.subindex,
		  coerce_rust_to_hacspec_public_byte_seq(&receive_bytes),
		  amount.micro_gtu,
		  coerce_rust_to_hacspec_public_byte_seq(&parameter),
	      );
	  Action { _private: res }
      }

      #[inline(always)]
      fn and_then(self, then: Self) -> Self {
	  let res = combine_and_hacspec(self._private, then._private);
	  Action { _private: res }
      }

      #[inline(always)]
      fn or_else(self, el: Self) -> Self {
	  let res = combine_or_hacspec(self._private, el._private);
	  Action { _private: res }
      }
  }

#+end_src

*** Remaining todo
This file should replace the import of the concordium ~impls.rs~ file.
#+begin_src rust :tangle no :eval never
  // /// Allocates a Vec of bytes prepended with its length as a `u32` into memory,
  // /// and prevents them from being dropped. Returns the pointer.
  // /// Used to pass bytes from a Wasm module to its host.
  // #[doc(hidden)]
  // pub fn put_in_memory(input: &[u8]) -> *mut u8 {
  //     let bytes_length = input.len() as u32;
  //     let mut bytes = to_bytes(&bytes_length);
  //     bytes.extend_from_slice(input);
  //     let ptr = bytes.as_mut_ptr();
  //     #[cfg(feature = "std")]
  //     ::std::mem::forget(bytes);
  //     #[cfg(not(feature = "std"))]
  //     core::mem::forget(bytes);
  //     ptr
  // }

  // /// Wrapper for
  // /// [HasActions::send_raw](./trait.HasActions.html#tymethod.send_raw), which
  // /// automatically serializes the parameter. Note that if the parameter is
  // /// already a byte array or convertible to a byte array without allocations it
  // /// is preferrable to use [send_raw](./trait.HasActions.html#tymethod.send_raw).
  // /// It is more efficient and avoids memory allocations.
  // pub fn send<A: HasActions, P: Serial>(
  //     ca: &ContractAddress,
  //     receive_name: ReceiveName,
  //     amount: Amount,
  //     parameter: &P,
  // ) -> A {
  //     let param_bytes = to_bytes(parameter);
  //     A::send_raw(ca, receive_name, amount, &param_bytes)
  // }

  // impl<A, E> UnwrapAbort for Result<A, E> {
  //     type Unwrap = A;

  //     #[inline]
  //     fn unwrap_abort(self) -> Self::Unwrap {
  //         match self {
  //             Ok(x) => x,
  //             Err(_) => crate::trap(),
  //         }
  //     }
  // }

  // #[cfg(not(feature = "std"))]
  // use core::fmt;
  // #[cfg(feature = "std")]
  // use std::fmt;

  // impl<A, E: fmt::Debug> ExpectReport for Result<A, E> {
  //     type Unwrap = A;

  //     fn expect_report(self, msg: &str) -> Self::Unwrap {
  //         match self {
  //             Ok(x) => x,
  //             Err(e) => crate::fail!("{}: {:?}", msg, e),
  //         }
  //     }
  // }

  // impl<A: fmt::Debug, E> ExpectErrReport for Result<A, E> {
  //     type Unwrap = E;

  //     fn expect_err_report(self, msg: &str) -> Self::Unwrap {
  //         match self {
  //             Ok(a) => crate::fail!("{}: {:?}", msg, a),
  //             Err(e) => e,
  //         }
  //     }
  // }

  // impl<A> UnwrapAbort for Option<A> {
  //     type Unwrap = A;

  //     #[inline(always)]
  //     fn unwrap_abort(self) -> Self::Unwrap {
  //         self.unwrap_or_else(|| crate::trap())
  //     }
  // }

  // impl<A> ExpectReport for Option<A> {
  //     type Unwrap = A;

  //     fn expect_report(self, msg: &str) -> Self::Unwrap {
  //         match self {
  //             Some(v) => v,
  //             None => crate::fail!("{}", msg),
  //         }
  //     }
  // }

  // impl<A: fmt::Debug> ExpectNoneReport for Option<A> {
  //     fn expect_none_report(self, msg: &str) {
  //         if let Some(x) = self {
  //             crate::fail!("{}: {:?}", msg, x)
  //         }
  //     }
  // }

  // impl<K: Serial + Ord> SerialCtx for BTreeSet<K> {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_set_no_length(self, out)
  //     }
  // }

  // impl<K: Deserial + Ord + Copy> DeserialCtx for BTreeSet<K> {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         if ensure_ordered {
  //             deserial_set_no_length(source, len)
  //         } else {
  //             deserial_set_no_length_no_order_check(source, len)
  //         }
  //     }
  // }

  // impl<K: Serial + Ord, V: Serial> SerialCtx for BTreeMap<K, V> {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_map_no_length(self, out)
  //     }
  // }

  // impl<K: Deserial + Ord + Copy, V: Deserial> DeserialCtx for BTreeMap<K, V> {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         if ensure_ordered {
  //             deserial_map_no_length(source, len)
  //         } else {
  //             deserial_map_no_length_no_order_check(source, len)
  //         }
  //     }
  // }

  // /// Serialization for HashSet given a size_len.
  // /// Values are not serialized in any particular order.
  // impl<K: Serial> SerialCtx for HashSet<K> {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_hashset_no_length(self, out)
  //     }
  // }

  // /// Deserialization for HashSet given a size_len.
  // /// Values are not verified to be in any particular order and setting
  // /// ensure_ordering have no effect.
  // impl<K: Deserial + Eq + Hash> DeserialCtx for HashSet<K> {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         _ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         deserial_hashset_no_length(source, len)
  //     }
  // }

  // /// Serialization for HashMap given a size_len.
  // /// Keys are not serialized in any particular order.
  // impl<K: Serial, V: Serial> SerialCtx for HashMap<K, V> {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_hashmap_no_length(self, out)
  //     }
  // }

  // /// Deserialization for HashMap given a size_len.
  // /// Keys are not verified to be in any particular order and setting
  // /// ensure_ordering have no effect.
  // impl<K: Deserial + Eq + Hash, V: Deserial> DeserialCtx for HashMap<K, V> {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         _ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         deserial_hashmap_no_length(source, len)
  //     }
  // }

  // impl<T: Serial> SerialCtx for &[T] {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_vector_no_length(self, out)
  //     }
  // }

  // impl<T: Deserial> DeserialCtx for Vec<T> {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         _ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         deserial_vector_no_length(source, len)
  //     }
  // }

  // impl SerialCtx for &str {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         schema::serial_length(self.len(), size_len, out)?;
  //         serial_vector_no_length(&self.as_bytes().to_vec(), out)
  //     }
  // }

  // impl SerialCtx for String {
  //     fn serial_ctx<W: Write>(
  //         &self,
  //         size_len: schema::SizeLength,
  //         out: &mut W,
  //     ) -> Result<(), W::Err> {
  //         self.as_str().serial_ctx(size_len, out)
  //     }
  // }

  // impl DeserialCtx for String {
  //     fn deserial_ctx<R: Read>(
  //         size_len: schema::SizeLength,
  //         _ensure_ordered: bool,
  //         source: &mut R,
  //     ) -> ParseResult<Self> {
  //         let len = schema::deserial_length(source, size_len)?;
  //         let bytes = deserial_vector_no_length(source, len)?;
  //         let res = String::from_utf8(bytes).map_err(|_| ParseError::default())?;
  //         Ok(res)
  //     }
  // }
#+end_src

** Rust Tests
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never

#+end_src

** Resulting output
#+begin_src sh :eval no-export-query :results output silent
  cargo clean
#+end_src

#+begin_src sh :eval no-export-query :results output silent
  cd ../.. && cargo install --path language
#+end_src

#+begin_src sh :eval no-export-query :results output silent
  cd ../.. && cargo build
#+end_src

#+begin_src sh :eval never :results output silent
  cargo hacspec -o ConcordiumImpls.v concordium_impls --init
#+end_src

#+begin_src sh :results output silent
  cargo hacspec -o ConcordiumImpls.v concordium_impls --update
#+end_src

** Generation of backend output

#+name: split-file
#+begin_src python :wrap "src coq :tangle ConcordiumImpls.v :results output silent" :exports none :results code :var ARG="0 -1" :var FILENAME="ConcordiumImpls.v" :eval never
  import functools

  lower, upper = map(int, ARG.split())
  if upper != -1:
    upper = lower + upper

  def boundery(start, end, lines, i):
    test = lines[i][:len(start)] == start
    res_str = ""

    in_end = lambda i: (i < len(lines) and len(list(filter(lambda x: x in lines[i], end))) > 0)

    if test:
      # if end in lines[i]:
      if in_end(i):
	res_str = lines[i]
      else:
	while i < len(lines) and not in_end(i): # end not in lines[i]:
	  res_str += lines[i]
	  i += 1
	res_str += lines[i]
    return (test, res_str, i)

  lines = []
  with open(FILENAME) as f:
    lines = f.readlines()

  result = []
  i  = 0
  while i < len(lines) and (upper == -1 or upper > len(result)):
    a,b,c = functools.reduce(lambda b, a: b if b[0] else boundery(a[0], a[1], lines, b[2]),
			     [["(**", set({"**)"})],
			      ["From",set({".\n"})],
			      ["Require",set({".\n"})],
			      ["Import",set({".\n"})],
			      ["Open Scope",set({".\n"})],
			      ["Inductive",set({".\n"})],
			      ["Definition",set({".\n"})],
			      ["Instance",set({".\n"})],
			      ["Notation",set({".\n"})],
			      ["Theorem",set({".\n"})],
			      ["Global Instance",set({".\n"})],
			      ["Proof",set({"Admitted", "Qed"})],
			      ["QuickChick",set({".\n"})],
			      ],
			     (False, "", i))
    if a:
      result.append(b)
      i = c
    elif lines[i].isspace():
      space = ""
      while i < len(lines) and lines[i].isspace():
	space += lines[i]
	i += 1
      i -= 1
      result.append(space)
    else:
      result.append("ERR:" + lines[i])
    i += 1

  result_str = ""
  for s in (result[lower:] if upper == -1 else result[lower:upper]):
    result_str += s

  return result_str
#+end_src

#+NAME: next
#+begin_src python :var ARG="0 0" :var linum="0 0" :results output silent :exports none
  a,b = map(int, linum.split())
  c,d = map(int, ARG.split())
  print (a+b+c,d)
#+end_src

#+NAME: empty
#+begin_src python :results output silent :exports none
#+end_src


#+NAME: seginit
#+begin_src python :wrap "src coq :results output silent" :result code :exports none :var loc=(file-name-directory buffer-file-name)
  with open("../_CoqProject") as f:
      result = ""
      for l in f:
	  if l[:2] == "-R":
	      pre, post = l[3:].split()
	      result += "Add Rec LoadPath \"" + pre + "\" as " + post + ".\n"
	  # elif l[:4] == "src/":
	  #     result += "Load " + l[4:-2] + "\n"
      return "Reset Initial.\nCd \""+loc+"../\".\n" + result
#+end_src
#+RESULTS: seginit
#+begin_src coq :results output silent
Reset Initial.
Cd "/home/au538501/Documents/LocalHacspec/hacspec/coq/src/../".
Add Rec LoadPath "src/" as Hacspec.
#+end_src

*** The includes
#+NAME: linum0
#+CALL: next(ARG="0 9", linum="0 0") :exports none
#+NAME: seg0
#+CALL: split-file(ARG=linum0) :eval
#+RESULTS: seg0
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
(** This file was automatically generated using Hacspec **)
Require Import Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.
Require Import Hacspec.Lib.

#+end_src

*** Types and default implementations
#+NAME: linum1
#+CALL: next(ARG="0 2", linum=linum0) :exports none
#+NAME: seg1
#+CALL: split-file(ARG=linum1) :eval
#+RESULTS: seg1
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'reject_hacspec_t'" := (int32) : hacspec_scope.

#+end_src

#+NAME: linum2
#+CALL: next(ARG="0 2", linum=linum1) :exports none
#+NAME: seg2
#+CALL: split-file(ARG=linum2) :eval
#+RESULTS: seg2
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition reject_impl_deafult  : reject_hacspec_t :=
  min_v.

#+end_src

# removed linum3

#+NAME: linum4
#+CALL: next(ARG="0 2", linum=linum2) :exports none
#+NAME: seg4
#+CALL: split-file(ARG=linum4) :eval
#+RESULTS: seg4
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition new_reject_impl (x_0 : int32) : (option reject_hacspec_t) :=
  (if ((x_0) <.? (@repr WORDSIZE32 0)):bool then (@Some int32 (x_0)) else (
      @None int32)).

#+end_src

*** Error handling
#+NAME: linum5
#+CALL: next(ARG="0 5", linum=linum4) :exports none
#+NAME: seg5
#+CALL: split-file(ARG=linum5) :eval
#+RESULTS: seg5
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition reject_impl_convert_from_unit  : reject_hacspec_t :=
  (min_v) .+ (@repr WORDSIZE32 1).

Theorem ensures_reject_impl_convert_from_unit : forall result_1 ,
@reject_impl_convert_from_unit  = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  reflexivity.
Qed.

#+end_src

#+NAME: linum6
#+CALL: next(ARG="0 5", linum=linum5) :exports none
#+NAME: seg6
#+CALL: split-file(ARG=linum6) :eval
#+RESULTS: seg6
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition reject_impl_convert_from_parse_error  : reject_hacspec_t :=
  (min_v) .+ (@repr WORDSIZE32 2).

Theorem ensures_reject_impl_convert_from_parse_error : forall result_1 ,
@reject_impl_convert_from_parse_error  = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  reflexivity.
Qed.

#+end_src

#+NAME: linum7
#+CALL: next(ARG="0 7", linum=linum6) :exports none
#+NAME: seg7
#+CALL: split-file(ARG=linum7) :eval
#+RESULTS: seg7
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Inductive log_error_t :=
| Full : log_error_t
| Malformed : log_error_t.

Definition reject_impl_from_log_error (le_2 : log_error_t) : reject_hacspec_t :=
  match le_2 with
  | Full => (min_v) .+ (@repr WORDSIZE32 3)
  | Malformed => (min_v) .+ (@repr WORDSIZE32 4)
  end.

Theorem ensures_reject_impl_from_log_error : forall result_1 (
  le_2 : log_error_t),
@reject_impl_from_log_error le_2 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  destruct le_2 ; reflexivity.
Qed.

#+end_src

#+NAME: linum8
#+CALL: next(ARG="0 7", linum=linum7) :exports none
#+NAME: seg8
#+CALL: split-file(ARG=linum8) :eval
#+RESULTS: seg8
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Inductive new_contract_name_error_t :=
| NewContractNameErrorMissingInitPrefix : new_contract_name_error_t
| NewContractNameErrorTooLong : new_contract_name_error_t
| NewContractNameErrorContainsDot : new_contract_name_error_t
| NewContractNameErrorInvalidCharacters : new_contract_name_error_t.

Definition reject_impl_from_new_contract_name_error
  (nre_3 : new_contract_name_error_t)
  : reject_hacspec_t :=
  match nre_3 with
  | NewContractNameErrorMissingInitPrefix => (min_v) .+ (@repr WORDSIZE32 5)
  | NewContractNameErrorTooLong => (min_v) .+ (@repr WORDSIZE32 6)
  | NewContractNameErrorContainsDot => (min_v) .+ (@repr WORDSIZE32 9)
  | NewContractNameErrorInvalidCharacters => (min_v) .+ (@repr WORDSIZE32 10)
  end.

Theorem ensures_reject_impl_from_new_contract_name_error : forall result_1 (
  nre_3 : new_contract_name_error_t),
@reject_impl_from_new_contract_name_error nre_3 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  destruct nre_3 ; reflexivity.
Qed.

#+end_src

#+NAME: linum9
#+CALL: next(ARG="0 7", linum=linum8) :exports none
#+NAME: seg9
#+CALL: split-file(ARG=linum9) :eval
#+RESULTS: seg9
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Inductive new_receive_name_error_t :=
| NewReceiveNameErrorMissingDotSeparator : new_receive_name_error_t
| NewReceiveNameErrorTooLong : new_receive_name_error_t
| NewReceiveNameErrorInvalidCharacters : new_receive_name_error_t.

Definition reject_impl_from_new_receive_name_error
  (nre_4 : new_receive_name_error_t)
  : reject_hacspec_t :=
  match nre_4 with
  | NewReceiveNameErrorMissingDotSeparator => (min_v) .+ (@repr WORDSIZE32 7)
  | NewReceiveNameErrorTooLong => (min_v) .+ (@repr WORDSIZE32 8)
  | NewReceiveNameErrorInvalidCharacters => (min_v) .+ (@repr WORDSIZE32 11)
  end.

Theorem ensures_reject_impl_from_new_receive_name_error : forall result_1 (
  nre_4 : new_receive_name_error_t),
@reject_impl_from_new_receive_name_error nre_4 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  destruct nre_4 ; reflexivity.
Qed.

#+end_src

*** Contract state
#+NAME: linum10
#+CALL: next(ARG="0 2", linum=linum9) :exports none
#+NAME: seg10
#+CALL: split-file(ARG=linum10) :eval
#+RESULTS: seg10
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'contract_state_hacspec_t'" := (int32) : hacspec_scope.

#+end_src

#+NAME: linum11
#+CALL: next(ARG="0 2", linum=linum10) :exports none
#+NAME: seg11
#+CALL: split-file(ARG=linum11) :eval
#+RESULTS: seg11
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Inductive seek_from_t :=
| Start : int64 -> seek_from_t
| End : int64 -> seek_from_t
| Current : int64 -> seek_from_t.

#+end_src

#+NAME: linum12
#+CALL: next(ARG="0 4", linum=linum11) :exports none
#+NAME: seg12
#+CALL: split-file(ARG=linum12) :eval
#+RESULTS: seg12
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'uint32_option_t'" := ((option int32)) : hacspec_scope.

Notation "'iint64_option_t'" := ((option int64)) : hacspec_scope.

#+end_src

#+NAME: linum13
#+CALL: next(ARG="0 2", linum=linum12) :exports none
#+NAME: seg13
#+CALL: split-file(ARG=linum13) :eval
#+RESULTS: seg13
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition contract_state_impl_seek
  (current_position_5 : contract_state_hacspec_t)
  (pos_6 : seek_from_t)
  : (result (contract_state_hacspec_t × int64) unit) :=
  match pos_6 with
  | Start offset_7 => @Ok (contract_state_hacspec_t × int64) unit ((
      @cast _ uint32 _ (offset_7),
      offset_7
    ))
  | End delta_8 => (if ((delta_8) >=.? (@repr WORDSIZE64 0)):bool then (
      match pub_uint32_checked_add (current_position_5) (@cast _ uint32 _ (
          delta_8)) with
      | Some b_9 => @Ok (contract_state_hacspec_t × int64) unit ((
          b_9,
          @cast _ uint64 _ (delta_8)
        ))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end) else (match pub_int64_checked_abs (delta_8) with
      | Some b_10 => @Ok (contract_state_hacspec_t × int64) unit ((
          (@repr WORDSIZE32 4) .- (@cast _ uint32 _ (b_10)),
          @cast _ uint64 _ ((@repr WORDSIZE32 4) .- (@cast _ uint32 _ (b_10)))
        ))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end))
  | Current delta_11 => (if ((delta_11) >=.? (@repr WORDSIZE64 0)):bool then (
      match pub_uint32_checked_add (current_position_5) (@cast _ uint32 _ (
          delta_11)) with
      | Some offset_12 => @Ok (contract_state_hacspec_t × int64) unit ((
          offset_12,
          @cast _ uint64 _ (offset_12)
        ))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end) else (match pub_int64_checked_abs (delta_11) with
      | Some b_13 => match pub_uint32_checked_sub (current_position_5) (
        @cast _ uint32 _ (b_13)) with
      | Some offset_14 => @Ok (contract_state_hacspec_t × int64) unit ((
          offset_14,
          @cast _ uint64 _ (offset_14)
        ))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end))
  end.

#+end_src

**** Contract state - Read Trait
#+NAME: linum14
#+CALL: next(ARG="0 2", linum=linum13) :exports none
#+NAME: seg14
#+CALL: split-file(ARG=linum14) :eval
#+RESULTS: seg14
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition load_state_hacspec
  (buf_15 : public_byte_seq)
  (offset_16 : int32)
  : (public_byte_seq × int32) :=
  (buf_15, @repr WORDSIZE32 1).

#+end_src

#+NAME: linum15
#+CALL: next(ARG="0 8", linum=linum14) :exports none
#+NAME: seg15
#+CALL: split-file(ARG=linum15) :eval
#+RESULTS: seg15
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition contract_state_impl_read_read
  (current_position_17 : contract_state_hacspec_t)
  (buf_18 : public_byte_seq)
  : (contract_state_hacspec_t × uint_size) :=
  let '(buf_19, num_read_20) :=
    load_state_hacspec (buf_18) (current_position_17) in 
  ((current_position_17) .+ (num_read_20), @cast _ uint32 _ (num_read_20)).

Definition contract_state_impl_read_read_u64
  (current_position_21 : contract_state_hacspec_t)
  : (contract_state_hacspec_t × int64) :=
  let buf_22 : seq int8 :=
    seq_new_ (default) (usize 8) in 
  let '(buf_23, num_read_24) :=
    load_state_hacspec (buf_22) (current_position_21) in 
  (
    (current_position_21) .+ (num_read_24),
    u64_from_le_bytes (array_from_seq (8) (buf_23))
  ).

Definition contract_state_impl_read_read_u32
  (current_position_25 : contract_state_hacspec_t)
  : (contract_state_hacspec_t × int32) :=
  let buf_26 : seq int8 :=
    seq_new_ (default) (usize 4) in 
  let '(buf_27, num_read_28) :=
    load_state_hacspec (buf_26) (current_position_25) in 
  (
    (current_position_25) .+ (num_read_28),
    u32_from_le_bytes (array_from_seq (4) (buf_27))
  ).

Definition contract_state_impl_read_read_u8
  (current_position_29 : contract_state_hacspec_t)
  : (contract_state_hacspec_t × int8) :=
  let buf_30 : seq int8 :=
    seq_new_ (default) (usize 1) in 
  let '(buf_31, num_read_32) :=
    load_state_hacspec (buf_30) (current_position_29) in 
  ((current_position_29) .+ (num_read_32), seq_index (buf_31) (usize 0)).

#+end_src

**** Contract state - Write Trait
#+NAME: linum16
#+CALL: next(ARG="0 2", linum=linum15) :exports none
#+NAME: seg16
#+CALL: split-file(ARG=linum16) :eval
#+RESULTS: seg16
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition write_state_hacspec
  (buf_33 : public_byte_seq)
  (offset_34 : int32)
  : (public_byte_seq × int32) :=
  (buf_33, @repr WORDSIZE32 1).

#+end_src

#+NAME: linum16half
#+CALL: next(ARG="0 6", linum=linum16) :exports none
#+NAME: seg16half
#+CALL: split-file(ARG=linum16half) :eval
#+RESULTS: seg16half
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition contract_state_impl_write
  (current_position_35 : contract_state_hacspec_t)
  (buf_36 : public_byte_seq)
  : (result (contract_state_hacspec_t × uint_size) unit) :=
  ifbnd option_is_none (pub_uint32_checked_add (current_position_35) (pub_u32 (
        seq_len (buf_36)))) : bool
  thenbnd (bind (@Err (contract_state_hacspec_t × uint_size) unit (tt)) (
      fun _ => Ok (tt)))
  else (tt) >> (fun 'tt =>
  let '(buf_37, num_bytes_38) :=
    write_state_hacspec (buf_36) (current_position_35) in 
  @Ok (contract_state_hacspec_t × uint_size) unit ((
      (current_position_35) .+ (num_bytes_38),
      @cast _ uint32 _ (num_bytes_38)
    ))).

Definition state_size_hacspec  : int32 :=
  @repr WORDSIZE32 1.

Definition resize_state_hacspec (new_size_39 : int32) : int32 :=
  @repr WORDSIZE32 1.

#+end_src


**** Contract State - Misc.
#+NAME: linum17
#+CALL: next(ARG="0 8", linum="68 6") :exports none
#+NAME: seg17
#+CALL: split-file(ARG=linum17) :eval
#+RESULTS: seg17
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition has_contract_state_impl_for_contract_state_open
  
  : contract_state_hacspec_t :=
  @repr WORDSIZE32 0.

Definition has_contract_state_impl_for_contract_state_reserve
  (contract_state_40 : contract_state_hacspec_t)
  (len_41 : int32)
  : bool :=
  let cur_size_42 : int32 :=
    state_size_hacspec  in 
  (if ((cur_size_42) <.? (len_41)):bool then ((resize_state_hacspec (
          len_41)) =.? (@repr WORDSIZE32 1)) else (true)).

Definition has_contract_state_impl_for_contract_state_truncate
  (current_position_43 : contract_state_hacspec_t)
  (cur_size_44 : int32)
  (new_size_45 : int32)
  : contract_state_hacspec_t :=
  let 'tt :=
    if (cur_size_44) >.? (new_size_45):bool then (let _ : int32 :=
        resize_state_hacspec (new_size_45) in 
      tt) else (tt) in 
  (if ((new_size_45) <.? (current_position_43)):bool then (new_size_45) else (
      current_position_43)).

Definition get_parameter_section_hacspec
  (buf_46 : public_byte_seq)
  (offset_47 : int32)
  : (public_byte_seq × int32) :=
  (buf_46, @repr WORDSIZE32 1).

#+end_src

*** Parameter
#+NAME: linum18
#+CALL: next(ARG="0 10", linum=linum17) :exports none
#+NAME: seg18
#+CALL: split-file(ARG=linum18) :eval
#+RESULTS: seg18
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'parameter_hacspec_t'" := (int32) : hacspec_scope.

Definition read_impl_for_parameter_read
  (current_position_48 : parameter_hacspec_t)
  (buf_49 : public_byte_seq)
  : (parameter_hacspec_t × uint_size) :=
  let '(buf_50, num_read_51) :=
    get_parameter_section_hacspec (buf_49) (current_position_48) in 
  ((current_position_48) .+ (num_read_51), @cast _ uint32 _ (num_read_51)).

Definition get_parameter_size_hacspec  : int32 :=
  @repr WORDSIZE32 1.

Definition get_slot_time_hacspec  : int64 :=
  @repr WORDSIZE64 1.

Definition get_policy_section_hacspec
  (policy_bytes_52 : public_byte_seq)
  (offset_53 : int32)
  : (public_byte_seq × int32) :=
  (policy_bytes_52, @repr WORDSIZE32 1).

#+end_src

*** Attributes Cursor
#+NAME: linum19
#+CALL: next(ARG="0 4", linum=linum18) :exports none
#+NAME: seg19
#+CALL: split-file(ARG=linum19) :eval
#+RESULTS: seg19
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'attributes_cursor_hacspec_t'" := ((int32 × int16)) : hacspec_scope.

Definition has_policy_impl_for_policy_attributes_cursor_next_item
  (policy_attribute_items_54 : attributes_cursor_hacspec_t)
  (buf_55 : public_byte_seq)
  : (option (attributes_cursor_hacspec_t × (int8 × int8))) :=
  let '(current_position_56, remaining_items_57) :=
    policy_attribute_items_54 in 
  let tag_value_len_58 : seq int8 :=
    seq_new_ (default) (usize 2) in 
  let '(tag_value_len_59, num_read_60) :=
    get_policy_section_hacspec (tag_value_len_58) (current_position_56) in 
  let current_position_56 :=
    (current_position_56) .+ (num_read_60) in 
  let '(buf_61, num_read_62) :=
    get_policy_section_hacspec (buf_55) (current_position_56) in 
  let current_position_56 :=
    (current_position_56) .+ (num_read_62) in 
  let remaining_items_57 :=
    (remaining_items_57) .- (@repr WORDSIZE16 1) in 
  @Some (attributes_cursor_hacspec_t × (int8 × int8)) ((
      (current_position_56, remaining_items_57),
      (
        seq_index (tag_value_len_59) (usize 0),
        seq_index (tag_value_len_59) (usize 1)
      )
    )).

#+end_src

*** Policies iterator
#+NAME: linum20
#+CALL: next(ARG="0 6", linum=linum19) :exports none
#+NAME: seg20
#+CALL: split-file(ARG=linum20) :eval
#+RESULTS: seg20
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'policies_iterator_hacspec_t'" := ((int32 × int16)) : hacspec_scope.

Notation "'policy_attributes_cursor_hacspec_t'" := ((
  int32 ×
  int64 ×
  int64 ×
  attributes_cursor_hacspec_t
)) : hacspec_scope.

Definition iterator_impl_for_policies_iterator_next
  (policies_iterator_63 : policies_iterator_hacspec_t)
  : (option (policies_iterator_hacspec_t × policy_attributes_cursor_hacspec_t
    )) :=
  let '(pos_64, _) :=
    policies_iterator_63 in 
  let '(buf_65, _) :=
    get_policy_section_hacspec (seq_new_ (default) (((((usize 2) + (
                usize 4)) + (usize 8)) + (usize 8)) + (usize 2))) (pos_64) in 
  let skip_part_66 : public_byte_seq :=
    seq_slice_range (buf_65) ((usize 0, usize 2)) in 
  let ip_part_67 : public_byte_seq :=
    seq_slice_range (buf_65) ((usize 2, (usize 2) + (usize 4))) in 
  let created_at_part_68 : public_byte_seq :=
    seq_slice_range (buf_65) ((
        (usize 2) + (usize 4),
        ((usize 2) + (usize 4)) + (usize 8)
      )) in 
  let valid_to_part_69 : public_byte_seq :=
    seq_slice_range (buf_65) ((
        ((usize 2) + (usize 4)) + (usize 8),
        (((usize 2) + (usize 4)) + (usize 8)) + (usize 8)
      )) in 
  let len_part_70 : public_byte_seq :=
    seq_slice_range (buf_65) ((
        (((usize 2) + (usize 4)) + (usize 8)) + (usize 8),
        ((((usize 2) + (usize 4)) + (usize 8)) + (usize 8)) + (usize 2)
      )) in 
  let identity_provider_71 : int32 :=
    u32_from_le_bytes (array_from_seq (4) (ip_part_67)) in 
  let created_at_72 : int64 :=
    u64_from_le_bytes (array_from_seq (8) (created_at_part_68)) in 
  let valid_to_73 : int64 :=
    u64_from_le_bytes (array_from_seq (8) (valid_to_part_69)) in 
  let remaining_items_74 : int16 :=
    u16_from_le_bytes (array_from_seq (2) (len_part_70)) in 
  let attributes_start_75 : int32 :=
    (((((pos_64) .+ (@repr WORDSIZE32 2)) .+ (@repr WORDSIZE32 4)) .+ (
          @repr WORDSIZE32 8)) .+ (@repr WORDSIZE32 8)) .+ (
      @repr WORDSIZE32 2) in 
  let pos_64 :=
    ((pos_64) .+ (@cast _ uint32 _ (u16_from_le_bytes (array_from_seq (2) (
              skip_part_66))))) .+ (@repr WORDSIZE32 2) in 
  let remaining_items_74 :=
    (remaining_items_74) .- (@repr WORDSIZE16 1) in 
  @Some (policies_iterator_hacspec_t × policy_attributes_cursor_hacspec_t) ((
      (pos_64, remaining_items_74),
      (
        identity_provider_71,
        created_at_72,
        valid_to_73,
        (attributes_start_75, remaining_items_74)
      )
    )).

#+end_src

*** Action
#+NAME: linum21
#+CALL: next(ARG="0 -1", linum=linum20) :exports none
#+NAME: seg21
#+CALL: split-file(ARG=linum21) :eval
#+RESULTS: seg21
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition accept_hacspec  : int32 :=
  @repr WORDSIZE32 1.

Definition simple_transfer_hacspec
  (buf_76 : public_byte_seq)
  (amount_77 : int64)
  : int32 :=
  @repr WORDSIZE32 1.

Definition send_hacspec
  (addr_index_78 : int64)
  (addr_subindex_79 : int64)
  (receive_name_80 : public_byte_seq)
  (amount_81 : int64)
  (parameter_82 : public_byte_seq)
  : int32 :=
  @repr WORDSIZE32 1.

Definition combine_and_hacspec (l_83 : int32) (r_84 : int32) : int32 :=
  @repr WORDSIZE32 1.

Definition combine_or_hacspec (l_85 : int32) (r_86 : int32) : int32 :=
  @repr WORDSIZE32 1.

#+end_src


* COMMENT Call everything
# ,A3=seg3
#+CALL: empty(A0=seg0,A1=seg1,A2=seg2,A4=seg4,A5=seg5,A6=seg6,A7=seg7,A8=seg8,A9=seg9,A10=seg10,A11=seg11,A12=seg12,A13=seg13,A14=seg14,A15=seg15,A16=seg16,A17=seg17,A18=seg18,A19=seg19,A20=seg20()) :tangle no :exports none
