#+TITLE: Concordium Smartcontract Infrastructure Implementations
#+AUTHOR: Lasse Letager Hansen

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file

#+name: split-file
#+begin_src python :wrap "src coq :tangle Concordium_Impls.v :results output silent" :exports none :results code :var ARG="0 -1" :var FILENAME="Concordium_Impls.v" :eval never
  import functools

  lower, upper = map(int, ARG.split())
  if upper != -1:
    upper = lower + upper

  def boundery(start, end, lines, i):
    test = lines[i][:len(start)] == start
    res_str = ""

    in_end = lambda i: (i < len(lines) and len(list(filter(lambda x: x in lines[i], end))) > 0)

    if test:
      # if end in lines[i]:
      if in_end(i):
	res_str = lines[i]
      else:
	while i < len(lines) and not in_end(i): # end not in lines[i]:
	  res_str += lines[i]
	  i += 1
	res_str += lines[i]
    return (test, res_str, i)

  lines = []
  with open(FILENAME) as f:
    lines = f.readlines()

  result = []
  i  = 0
  while i < len(lines) and (upper == -1 or upper > len(result)):
    a,b,c = functools.reduce(lambda b, a: b if b[0] else boundery(a[0], a[1], lines, b[2]),
			     [["(**", set({"**)"})],
			      ["From",set({".\n"})],
			      ["Require",set({".\n"})],
			      ["Import",set({".\n"})],
			      ["Open Scope",set({".\n"})],
			      ["Inductive",set({".\n"})],
			      ["Definition",set({".\n"})],
			      ["Instance",set({".\n"})],
			      ["Notation",set({".\n"})],
			      ["Theorem",set({".\n"})],
			      ["Global Instance",set({".\n"})],
			      ["Proof",set({"Admitted", "Qed"})],
			      ["QuickChick",set({".\n"})],
			      ],
			     (False, "", i))
    if a:
      result.append(b)
      i = c
    elif lines[i].isspace():
      space = ""
      while i < len(lines) and lines[i].isspace():
	space += lines[i]
	i += 1
      i -= 1
      result.append(space)
    else:
      result.append("ERR:" + lines[i])
    i += 1

  result_str = ""
  for s in (result[lower:] if upper == -1 else result[lower:upper]):
    result_str += s

  return result_str
#+end_src

#+NAME: next
#+begin_src python :var ARG="0 0" :var linum="0 0" :results output silent :exports none
  a,b = map(int, linum.split())
  c,d = map(int, ARG.split())
  print (a+b+c,d)
#+end_src

* Concordium specification
** Config
#+BEGIN_SRC toml :tangle ../../examples/concordium/Cargo.toml :eval never
  [package]
  name = "hacspec-concordium"
  version = "0.1.0"
  authors = [""]
  edition = "2018"

  [lib]
  path = "src/lib.rs"

  [dependencies]
  hacspec-lib = { path = "../../lib" }
  hacspec-attributes = { path = "../../utils/attributes", version = "0.1.0-beta.1" , features = ["print_attributes", "hacspec_unsafe"] } # , features = ["hacspec_unsafe"] , , optional = true
  creusot-contracts = { path = "../../../../creusot/creusot-contracts" }
  concordium-contracts-common = { path = "../../../../concordium-rust-smart-contracts/concordium-contracts-common" ,  version = "=0.4" , default-features = false }

  # Reduce code size, at the cost of performance in allocation heavy-code.
  wee_alloc="0.4.5"

  [features]
  use_attributes = ["hacspec-attributes/print_attributes", "hacspec-attributes/hacspec_unsafe"]

  [dev-dependencies]
  hacspec-dev = { path = "../../utils/dev" }
  criterion = "0.3"
  rand = "0.8"
  quickcheck = "1"
  quickcheck_macros = "1"
#+END_SRC
*** Imports
#+BEGIN_SRC rust :tangle ../../examples/concordium/src/lib.rs :eval never
  #![cfg_attr(not(feature = "std"), no_std, feature(alloc_error_handler, core_intrinsics))]

  #[cfg(not(feature = "hacspec"))]
  #[cfg(not(feature = "std"))]
  pub extern crate alloc;

  // TODO:
  // #[cfg(not(feature = "std"))]
  // #[alloc_error_handler]
  // fn on_oom(_layout: alloc::alloc::Layout) -> ! {
  //     #[cfg(target_arch = "wasm32")]
  //     unsafe {
  // 	core::arch::wasm32::unreachable()
  //     }
  //     #[cfg(not(target_arch = "wasm32"))]
  //     loop {}
  // }

  /// Terminate execution immediately without panicking.
  /// When the `std` feature is enabled this is just [std::process::abort](https://doc.rust-lang.org/std/process/fn.abort.html).
  /// When `std` is not present and the target architecture is `wasm32` this will
  /// simply emit the [unreachable](https://doc.rust-lang.org/core/arch/wasm32/fn.unreachable.html) instruction.
  #[cfg(not(feature = "hacspec"))]
  #[cfg(feature = "std")]
  pub use std::process::abort as trap;
  #[cfg(not(feature = "hacspec"))]
  #[cfg(all(not(feature = "std"), target_arch = "wasm32"))]
  #[inline(always)]
  pub fn trap() -> ! { unsafe { core::arch::wasm32::unreachable() } }
  #[cfg(not(feature = "hacspec"))]
  #[cfg(all(not(feature = "std"), not(target_arch = "wasm32")))]
  #[inline(always)]
  pub fn trap() -> ! { core::intrinsics::abort() }

  // TODO:
  // #[cfg(not(feature = "std"))]
  // #[panic_handler]
  // fn abort_panic(_info: &core::panic::PanicInfo) -> ! {
  //     #[cfg(target_arch = "wasm32")]
  //     unsafe {
  // 	core::arch::wasm32::unreachable()
  //     }
  //     #[cfg(not(target_arch = "wasm32"))]
  //     loop {}
  // }

  // Provide some re-exports to make it easier to use the library.
  // This should be expanded in the future.
  /// Re-export.
  #[cfg(not(feature = "hacspec"))]
  #[cfg(not(feature = "std"))]
  pub use alloc::{borrow::ToOwned, string, string::String, string::ToString, vec, vec::Vec};
  /// Re-export.
  #[cfg(not(feature = "hacspec"))]
  #[cfg(not(feature = "std"))]
  pub use core::{convert, hash, marker, mem, num, result::*};
  #[cfg(not(feature = "hacspec"))]
  #[cfg(feature = "std")]
  pub(crate) use std::vec;

  /// Re-export.
  #[cfg(not(feature = "hacspec"))]
  #[cfg(feature = "std")]
  pub use std::{convert, hash, marker, mem, num, string::String, vec::Vec};

  #[cfg(not(feature = "hacspec"))]
  pub mod collections {
      #[cfg(not(feature = "std"))]
      use alloc::collections;
      #[cfg(feature = "std")]
      use std::collections;

      pub use collections::*;
      pub use concordium_contracts_common::{HashMap, HashSet};
  }

  #[cfg(not(feature = "hacspec"))]
  /// Chain constants that impose limits on various aspects of smart contract
  /// execution.
  pub use concordium_contracts_common::*;
  // TODO: implement concordium_std_derive
  // pub use concordium_std_derive::*;

  #[cfg(not(feature = "hacspec"))]
  extern crate wee_alloc;
  // Use `wee_alloc` as the global allocator to reduce code size.
  #[cfg(not(feature = "hacspec"))]
  #[global_allocator]
  static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

  // pub mod test_infrastructure;
  pub mod hacspec_concordium_types;
  pub mod hacspec_concordium_traits;
  pub mod hacspec_concordium_impls;

  #[cfg(not(feature = "hacspec"))]
  use hacspec_concordium_types::*;
  #[cfg(not(feature = "hacspec"))]
  use hacspec_concordium_traits::*;
  #[cfg(not(feature = "hacspec"))]
  use hacspec_concordium_impls::*;
#+END_SRC

* Concordium "Types" specification
** Rust code
:PROPERTIES:
:header-args:  :tangle ../../examples/concordium/src/hacspec_concordium_types.rs
:END:

# :tangle ../../examples/concordium/src/concordium-types.rs

*** Imports
#+BEGIN_SRC rust :tangle ../../examples/concordium/src/hacspec_concordium_types.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  use crate::num::NonZeroI32;
#+END_SRC

*** Types code
#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// A type representing the constract state bytes.
  #[derive(Default)]
  pub struct ContractState {
      pub(crate) current_position: u32,
  }

  #[cfg(not(feature = "hacspec"))]
  #[derive(Default)]
  /// A type representing the parameter to init and receive methods.
  pub struct Parameter {
      pub(crate) current_position: u32,
  }

  #[cfg(not(feature = "hacspec"))]
  /// A type representing the attributes, lazily acquired from the host.
  #[derive(Default)]
  pub struct AttributesCursor {
      /// Current position of the cursor, starting from 0.
      /// Note that this is only for the variable attributes.
      /// `created_at` and `valid_to` will require.
      pub(crate) current_position: u32,
      /// The number of remaining items in the policy.
      pub(crate) remaining_items:  u16,
  }

  #[cfg(not(feature = "hacspec"))]
  /// A type representing the logger.
  #[derive(Default)]
  pub struct Logger {
      pub(crate) _private: (),
  }

  // #[cfg(not(feature = "hacspec"))]
  /// Errors that can occur during logging.
  #[derive(Debug, Copy, Clone, Eq, PartialEq)]
  #[repr(u8)]
  pub enum LogError {
      /// The log is full.
      Full,
      /// The message to log was malformed (e.g., too long)
      Malformed,
  }

  #[cfg(not(feature = "hacspec"))]
  /// Actions that can be produced at the end of a contract execution. This
  /// type is deliberately not cloneable so that we can enforce that
  /// `and_then` and `or_else` can only be used when more than one event is
  /// created.
  ///
  /// This type is marked as `must_use` since functions that produce
  /// values of the type are effectful.
  #[must_use]
  pub struct Action {
      pub(crate) _private: u32,
  }

  #[cfg(not(feature = "hacspec"))]
  impl Action {
      pub fn tag(&self) -> u32 { self._private }
  }

  #[cfg(not(feature = "hacspec"))]
  /// An error message, signalling rejection of a smart contract invocation.
  /// The client will see the error code as a reject reason; if a schema is
  /// provided, the error message corresponding to the error code will be
  /// displayed. The valid range for an error code is from i32::MIN to  -1.
  #[derive(Eq, PartialEq)] // TODO: Creusot issue re-add "Debug" attribute 
  #[repr(transparent)]
  pub struct Reject {
      pub error_code: NonZeroI32,
  }

  #[cfg(not(feature = "hacspec"))]
  /// Default error is i32::MIN.
  impl Default for Reject {
      #[inline(always)]
      fn default() -> Self {
	  Self {
	      error_code: unsafe { NonZeroI32::new_unchecked(i32::MIN) },
	  }
      }
  }

  #[cfg(not(feature = "hacspec"))]
  impl Reject {
      /// This returns `None` for all values >= 0 and `Some` otherwise.
      pub fn new(x: i32) -> Option<Self> {
	  if x < 0 {
	      let error_code = unsafe { NonZeroI32::new_unchecked(x) };
	      Some(Reject {
		  error_code,
	      })
	  } else {
	      None
	  }
      }
  }

  // Macros for failing a contract function

  // #[cfg(not(feature = "hacspec"))]
  // /// The `bail` macro can be used for cleaner error handling. If the function has
  // /// result type `Result` invoking `bail` will terminate execution early with an
  // /// error.
  // /// If an argument is supplied, this will be used as the error, otherwise it
  // /// requires the type `E` in `Result<_, E>` to implement the `Default` trait.
  // #[macro_export]
  // macro_rules! bail {
  //     () => {{
  // 	return Err(Default::default());
  //     }};
  //     ($arg:expr) => {{
  // 	// format_err!-like formatting
  // 	// logs are only retained in case of rejection when testing.
  // 	return Err($arg);
  //     }};
  // }

  // #[cfg(not(feature = "hacspec"))]
  // /// The `ensure` macro can be used for cleaner error handling. It is analogous
  // /// to `assert`, but instead of panicking it uses `bail` to terminate execution
  // /// of the function early.
  // #[macro_export]
  // macro_rules! ensure {
  //     ($p:expr) => {
  // 	if !$p {
  // 	    $crate::bail!();
  // 	}
  //     };
  //     ($p:expr, $arg:expr) => {{
  // 	if !$p {
  // 	    $crate::bail!($arg);
  // 	}
  //     }};
  // }

  // #[cfg(not(feature = "hacspec"))]
  // /// ## Variants of `ensure` for ease of use in certain contexts.
  // /// Ensure the first two arguments are equal, using `bail` otherwise.
  // #[macro_export]
  // macro_rules! ensure_eq {
  //     ($l:expr, $r:expr) => {
  // 	$crate::ensure!($l == $r)
  //     };
  //     ($l:expr, $r:expr, $arg:expr) => {
  // 	$crate::ensure!($l == $r, $arg)
  //     };
  // }

  // #[cfg(not(feature = "hacspec"))]
  // #[macro_export]
  // /// Ensure the first two arguments are __not__ equal, using `bail` otherwise.
  // macro_rules! ensure_ne {
  //     ($l:expr, $r:expr) => {
  // 	$crate::ensure!($l != $r)
  //     };
  //     ($l:expr, $r:expr, $arg:expr) => {
  // 	$crate::ensure!($l != $r, $arg)
  //     };
  // }

  // Macros for failing a test

  // #[cfg(not(feature = "hacspec"))]
  // /// The `fail` macro is used for testing as a substitute for the panic macro.
  // /// It reports back error information to the host.
  // /// Used only in testing.
  // #[cfg(feature = "std")]
  // #[macro_export]
  // macro_rules! fail {
  //     () => {
  // 	{
  // 	    $crate::test_infrastructure::report_error("", file!(), line!(), column!());
  // 	    panic!()
  // 	}
  //     };
  //     ($($arg:tt),+) => {
  // 	{
  // 	    let msg = format!($($arg),+);
  // 	    $crate::test_infrastructure::report_error(&msg, file!(), line!(), column!());
  // 	    panic!("{}", msg)
  // 	}
  //     };
  // }

  // #[cfg(not(feature = "hacspec"))]
  // /// The `fail` macro is used for testing as a substitute for the panic macro.
  // /// It reports back error information to the host.
  // /// Used only in testing.
  // #[cfg(not(feature = "std"))]
  // #[macro_export]
  // macro_rules! fail {
  //     () => {
  // 	{
  // 	    $crate::test_infrastructure::report_error("", file!(), line!(), column!());
  // 	    panic!()
  // 	}
  //     };
  //     ($($arg:tt),+) => {
  // 	{
  // 	    let msg = &$crate::alloc::format!($($arg),+);
  // 	    $crate::test_infrastructure::report_error(&msg, file!(), line!(), column!());
  // 	    panic!("{}", msg)
  // 	}
  //     };
  // }

  // #[cfg(not(feature = "hacspec"))]
  // /// The `claim` macro is used for testing as a substitute for the assert macro.
  // /// It checks the condition and if false it reports back an error.
  // /// Used only in testing.
  // #[macro_export]
  // macro_rules! claim {
  //     ($cond:expr) => {
  // 	if !$cond {
  // 	    $crate::fail!()
  // 	}
  //     };
  //     ($cond:expr,) => {
  // 	if !$cond {
  // 	    $crate::fail!()
  // 	}
  //     };
  //     ($cond:expr, $($arg:tt),+) => {
  // 	if !$cond {
  // 	    $crate::fail!($($arg),+)
  // 	}
  //     };
  // }

  // #[cfg(not(feature = "hacspec"))]
  // /// Ensure the first two arguments are equal, just like `assert_eq!`, otherwise
  // /// reports an error. Used only in testing.
  // #[macro_export]
  // macro_rules! claim_eq {
  //     ($left:expr, $right:expr) => {
  // 	$crate::claim!($left == $right, "left and right are not equal\nleft: {:?}\nright: {:?}", $left, $right)
  //     };
  //     ($left:expr, $right:expr,) => {
  // 	$crate::claim_eq!($left, $right)
  //     };
  //     ($left:expr, $right:expr, $($arg:tt),+) => {
  // 	$crate::claim!($left == $right, $($arg),+)
  //     };
  // }

  // #[cfg(not(feature = "hacspec"))]
  // /// Ensure the first two arguments are *not* equal, just like `assert_ne!`,
  // /// otherwise reports an error.
  // /// Used only in testing.
  // #[macro_export]
  // macro_rules! claim_ne {
  //     ($left:expr, $right:expr) => {
  // 	$crate::claim!($left != $right)
  //     };
  //     ($left:expr, $right:expr,) => {
  // 	$crate::claim!($left != $right)
  //     };
  //     ($left:expr, $right:expr, $($arg:tt),+) => {
  // 	$crate::claim!($left != $right, $($arg),+)
  //     };
  // }

  #[cfg(not(feature = "hacspec"))]
  /// The expected return type of the receive method of a smart contract.
  ///
  /// Optionally, to define a custom type for error instead of using
  /// Reject, allowing to track the reason for rejection, *but only in unit
  /// tests*.
  ///
  /// See also the documentation for [bail!](macro.bail.html) for how to use
  /// custom error types.
  ///
  /// # Example
  /// Defining a custom error type
  /// ```rust
  /// enum MyCustomError {
  ///     SomeError
  /// }
  ///
  /// #[receive(contract = "mycontract", name = "receive")]
  /// fn contract_receive<R: HasReceiveContext, L: HasLogger, A: HasActions>(
  ///     ctx: &R,
  ///     receive_amount: Amount,
  ///     logger: &mut L,
  ///     state: &mut State,
  /// ) -> Result<A, MyCustomError> { ... }
  /// ```
  pub type ReceiveResult<A> = Result<A, Reject>;

  #[cfg(not(feature = "hacspec"))]
  /// The expected return type of the init method of the smart contract,
  /// parametrized by the state type of the smart contract.
  ///
  /// Optionally, to define a custom type for error instead of using Reject,
  /// allowing the track the reason for rejection, *but only in unit tests*.
  ///
  /// See also the documentation for [bail!](macro.bail.html) for how to use
  /// custom error types.
  ///
  /// # Example
  /// Defining a custom error type
  /// ```rust
  /// enum MyCustomError {
  ///     SomeError
  /// }
  ///
  /// #[init(contract = "mycontract")]
  /// fn contract_init<R: HasReceiveContext, L: HasLogger, A: HasActions>(
  ///     ctx: &R,
  ///     receive_amount: Amount,
  ///     logger: &mut L,
  /// ) -> Result<State, MyCustomError> { ... }
  /// ```
  pub type InitResult<S> = Result<S, Reject>;


  #[cfg(not(feature = "hacspec"))]
  /// Context backed by host functions.
  #[derive(Default)]
  #[doc(hidden)]
  pub struct ExternContext<T: sealed::ContextType> {
      marker: crate::marker::PhantomData<T>, // TODO: remove concordium_std ?? // marker:: ??
  }

  #[cfg(not(feature = "hacspec"))]
  #[doc(hidden)]
  pub struct ChainMetaExtern {}

  #[cfg(not(feature = "hacspec"))]
  #[derive(Default)]
  #[doc(hidden)]
  pub struct InitContextExtern;
  #[cfg(not(feature = "hacspec"))]
  #[derive(Default)]
  #[doc(hidden)]
  pub struct ReceiveContextExtern;

  #[cfg(not(feature = "hacspec"))]
  pub(crate) mod sealed {
      use super::*;
      /// Marker trait intended to indicate which context type we have.
      /// This is deliberately a sealed trait, so that it is only implementable
      /// by types in this crate.
      pub trait ContextType {}
      impl ContextType for InitContextExtern {}
      impl ContextType for ReceiveContextExtern {}
  }
#+END_SRC

* Concordium "Traits" specification
** Rust code
:PROPERTIES:
:header-args:  :tangle ../../examples/concordium/src/hacspec_concordium_traits.rs
:END:
*** Imports
#+BEGIN_SRC rust :eval never

  #[cfg(not(feature = "hacspec"))]
  use crate::collections::{BTreeMap, BTreeSet, HashSet, HashMap};

  #[cfg(not(feature = "hacspec"))]
  use crate::hash::Hash;
  
  #[cfg(not(feature = "hacspec"))]
  extern crate concordium_contracts_common;
  #[cfg(not(feature = "hacspec"))]
  use concordium_contracts_common::*;

  // Creusot
  #[cfg(not(feature = "hacspec"))]
  extern crate creusot_contracts;
  #[cfg(not(feature = "hacspec"))]
  use creusot_contracts::{
      ensures,
      requires,
      trusted	  
      };
#+END_SRC

#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  use crate::*;
  #[cfg(not(feature = "hacspec"))]
  use hacspec_concordium_types::*; // crate::
  // use vec::Vec;
  // use trap;
#+END_SRC

*** Traits code
#+BEGIN_SRC rust :eval never
  // //! This module implements traits for the contract interface.
  // //! This allows setting-up mock objects for testing individual
  // //! contract invocations.

  // TODO: Import create for alloc::vec::Vec and uncomment alloc::vec::Vec
  // #[cfg(not(feature = "hacspec"))]
  // #[cfg(not(feature = "std"))]
  // use alloc::vec::Vec;

  // #[cfg(not(feature = "hacspec"))]
  // use crate::types::LogError;
  // #[cfg(not(feature = "hacspec"))]
  // use concordium_contracts_common::*;

  #[cfg(not(feature = "hacspec"))]
  /// Objects which can access parameters to contracts.
  ///
  /// This trait has a Read supertrait which means that structured parameters can
  /// be directly deserialized by using `.get()` function from the `Get` trait.
  ///
  /// The reuse of `Read` methods is the reason for the slightly strange choice of
  /// methods of this trait.
  pub trait HasParameter: Read {
      /// Get the size of the parameter to the method.
      fn size(&self) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Objects which can access chain metadata.
  pub trait HasChainMetadata {
      /// Get time in milliseconds at the beginning of this block.
      fn slot_time(&self) -> SlotTime;
  }

  #[cfg(not(feature = "hacspec"))]
  /// A type which has access to a policy of a credential.
  /// Since policies can be large this is deliberately written in a relatively
  /// low-level style to enable efficient traversal of all the attributes without
  /// any allocations.
  pub trait HasPolicy {
      /// Identity provider who signed the identity object the credential is
      /// derived from.
      fn identity_provider(&self) -> IdentityProvider;
      /// Beginning of the month in milliseconds since unix epoch when the
      /// credential was created.
      fn created_at(&self) -> Timestamp;
      /// Beginning of the month where the credential is no longer valid, in
      /// milliseconds since unix epoch.
      fn valid_to(&self) -> Timestamp;
      /// Get the next attribute, storing it in the provided buffer.
      /// The return value, if `Some`, is a pair of an attribute tag, and the
      /// length, `n` of the attribute value. In this case, the attribute
      /// value is written in the first `n` bytes of the provided buffer. The
      /// rest of the buffer is unchanged.
      ///
      /// The reason this function is added here, and we don't simply implement
      /// an Iterator for this type is that with the supplied buffer we can
      /// iterate through the elements more efficiently, without any allocations,
      /// the consumer being responsible for allocating the buffer.
      fn next_item(&mut self, buf: &mut [u8; 31]) -> Option<(AttributeTag, u8)>;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Common data accessible to both init and receive methods.
  pub trait HasCommonData {
      type PolicyType: HasPolicy;
      type MetadataType: HasChainMetadata;
      type ParamType: HasParameter + Read;
      type PolicyIteratorType: ExactSizeIterator<Item = Self::PolicyType>;
      /// Policies of the sender of the message.
      /// For init methods this is the would-be creator of the contract,
      /// for the receive this is the policies of the immediate sender.
      ///
      /// In the latter case, if the sender is an account then it is the policies
      /// of the account, if it is a contract then it is the policies of the
      /// creator of the contract.
      fn policies(&self) -> Self::PolicyIteratorType;
      /// Get the reference to chain metadata
      fn metadata(&self) -> &Self::MetadataType;
      /// Get the cursor to the parameter.
      fn parameter_cursor(&self) -> Self::ParamType;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Types which can act as init contexts.
  pub trait HasInitContext<Error: Default = ()>: HasCommonData {
      /// Data needed to open the context.
      type InitData;
      /// Open the init context for reading and accessing values.
      fn open(data: Self::InitData) -> Self;
      /// Who invoked this init call.
      fn init_origin(&self) -> AccountAddress;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Types which can act as receive contexts.
  pub trait HasReceiveContext<Error: Default = ()>: HasCommonData {
      type ReceiveData;

      /// Open the receive context for reading and accessing values.
      fn open(data: Self::ReceiveData) -> Self;
      /// Who is the account that initiated the top-level transaction this
      /// invocation is a part of.
      fn invoker(&self) -> AccountAddress;
      /// The address of the contract being invoked.
      fn self_address(&self) -> ContractAddress;
      /// Balance on the contract before the call was made.
      fn self_balance(&self) -> Amount;
      /// The immediate sender of the message. In general different from the
      /// invoker.
      fn sender(&self) -> Address;
      /// Account which created the contract instance.
      fn owner(&self) -> AccountAddress;
  }

  #[cfg(not(feature = "hacspec"))]
  /// A type that can serve as the contract state type.
  pub trait HasContractState<Error: Default = ()>
  where
      Self: Read,
      Self: Write<Err = Error>,
      Self: Seek<Err = Error>, {
      type ContractStateData;
      /// Open the contract state. Only one instance can be opened at the same
      /// time.
      fn open(_: Self::ContractStateData) -> Self;

      /// Get the current size of contract state.
      fn size(&self) -> u32;

      /// Truncate the state to the given size. If the given size is more than the
      /// current state size this operation does nothing. The new position is at
      /// most at the end of the stream.
      fn truncate(&mut self, new_size: u32);

      /// Make sure that the memory size is at least that many bytes in size.
      /// Returns true iff this was successful. The new bytes are initialized as
      /// 0.
      fn reserve(&mut self, len: u32) -> bool;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Objects which can serve as loggers.
  ///
  /// Logging functionality can be used by smart contracts to record events that
  /// might be of interest to external parties. These events are not used on the
  /// chain, and cannot be observed by other contracts, but they are stored by the
  /// node, and can be queried to provide information to off-chain actors.
  pub trait HasLogger {
      /// Initialize a logger.
      fn init() -> Self;

      /// Log the given slice as-is. If logging is not successful an error will be
      /// returned.
      fn log_raw(&mut self, event: &[u8]) -> Result<(), LogError>;

      #[inline(always)]
      /// Log a serializable event by serializing it with a supplied serializer.
      fn log<S: Serial>(&mut self, event: &S) -> Result<(), LogError> {
	  let mut out = Vec::new();
	  if event.serial(&mut out).is_err() {
	      trap(); // should not happen
	  }
	  self.log_raw(&out)
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// An object that can serve to construct actions.
  ///
  /// The actions that a smart contract can produce as a
  /// result of its execution. These actions form a tree and are executed by
  /// the scheduler in the predefined order.
  pub trait HasActions {
      /// Default accept action.
      fn accept() -> Self;
  
      /// Send a given amount to an account.
      fn simple_transfer(acc: &AccountAddress, amount: Amount) -> Self;

      /// Send a message to a contract.
      fn send_raw(
	  ca: &ContractAddress,
	  receive_name: ReceiveName,
	  amount: Amount,
	  parameter: &[u8],
      ) -> Self;

      /// If the execution of the first action succeeds, run the second action
      /// as well.
      fn and_then(self, then: Self) -> Self;

      /// If the execution of the first action fails, try the second.
      fn or_else(self, el: Self) -> Self;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Add optimized unwrap behaviour that aborts the process instead of
  /// panicking.
  pub trait UnwrapAbort {
      /// The underlying result type of the unwrap, in case of success.
      type Unwrap;
      /// Unwrap or call [trap](./fn.trap.html). In contrast to
      /// the unwrap methods on [Option::unwrap](https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap)
      /// this method will tend to produce smaller code, at the cost of the
      /// ability to handle the panic.
      /// This is intended to be used only in `Wasm` code, where panics cannot be
      /// handled anyhow.
      fn unwrap_abort(self) -> Self::Unwrap;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Analogue of the `expect` methods on types such as [Option](https://doc.rust-lang.org/std/option/enum.Option.html),
  /// but useful in a Wasm setting.
  pub trait ExpectReport {
      type Unwrap;
      /// Like the default `expect` on, e.g., `Result`, but calling
      /// [fail](macro.fail.html) with the given message, instead of `panic`.
      fn expect_report(self, msg: &str) -> Self::Unwrap;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Analogue of the `expect_err` methods on [Result](https://doc.rust-lang.org/std/result/enum.Result.html),
  /// but useful in a Wasm setting.
  pub trait ExpectErrReport {
      type Unwrap;
      /// Like the default `expect_err` on, e.g., `Result`, but calling
      /// [fail](macro.fail.html) with the given message, instead of `panic`.
      fn expect_err_report(self, msg: &str) -> Self::Unwrap;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Analogue of the `expect_none` methods on [Option](https://doc.rust-lang.org/std/option/enum.Option.html),
  /// but useful in a Wasm setting.
  pub trait ExpectNoneReport {
      /// Like the default `expect_none_report` on, e.g., `Option`, but calling
      /// [fail](macro.fail.html) with the given message, instead of `panic`.
      fn expect_none_report(self, msg: &str);
  }

  #[cfg(not(feature = "hacspec"))]
  /// The `SerialCtx` trait provides a means of writing structures into byte-sinks
  /// (`Write`) using contextual information.
  /// The contextual information is:
  ///
  ///   - `size_length`: The number of bytes used to record the length of the
  ///     data.
  pub trait SerialCtx {
      /// Attempt to write the structure into the provided writer, failing if
      /// if the length cannot be represented in the provided `size_length` or
      /// only part of the structure could be written.
      ///
      /// NB: We use Result instead of Option for better composability with other
      /// constructs.
      fn serial_ctx<W: Write>(
	  &self,
	  size_length: schema::SizeLength,
	  out: &mut W,
      ) -> Result<(), W::Err>;
  }

  #[cfg(not(feature = "hacspec"))]
  /// The `DeserialCtx` trait provides a means of reading structures from
  /// byte-sources (`Read`) using contextual information.
  /// The contextual information is:
  ///
  ///   - `size_length`: The expected number of bytes used for the length of the
  ///     data.
  ///   - `ensure_ordered`: Whether the ordering should be ensured, for example
  ///     that keys in `BTreeMap` and `BTreeSet` are in strictly increasing order.
  pub trait DeserialCtx: Sized {
      /// Attempt to read a structure from a given source and context, failing if
      /// an error occurs during deserialization or reading.
      fn deserial_ctx<R: Read>(
	  size_length: schema::SizeLength,
	  ensure_ordered: bool,
	  source: &mut R,
      ) -> ParseResult<Self>;
  }
#+END_SRC

* Concordium "Prims" specification
** Rust code
:PROPERTIES:
:header-args:  :tangle ../../examples/concordium/src/hacspec_concordium_impls.rs
:END:

Load state extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn load_state(start: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn load_state_creusot(start: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { load_state(start, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  fn load_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn load_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      let result = load_state_creusot(temp.as_mut_ptr(), buf.len() as u32, offset);
      (
	  coerce_rust_to_hacspec_public_byte_seq(&temp),
	  result,
      )
  }

#+end_src
Write state extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn write_state(start: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn write_state_creusot(start: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { write_state(start, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  fn write_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn write_state_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      let result = write_state_creusot(temp.as_mut_ptr(), buf.len() as u32, offset);
      (
	  coerce_rust_to_hacspec_public_byte_seq(&temp),
	  result,
      )
  }
#+end_src
State size extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn state_size() -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn state_size_creusot() -> u32 {
      unsafe { state_size() }
  }

  #[cfg(feature = "hacspec")]
  fn state_size_hacspec() -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn state_size_hacspec() -> u32 {
      state_size_creusot()
  }
  
#+end_src
Resize state extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Resize state to the new value (truncate if new size is smaller). Return 0 if
      // this was unsuccesful (new state too big), or 1 if successful.
      pub(crate) fn resize_state(new_size: u32) -> u32; // returns 0 or 1.
							// get current state size in bytes.
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn resize_state_creusot(new_size: u32) -> u32 {
      unsafe { resize_state(new_size) }
  }

  #[cfg(feature = "hacspec")]
  fn resize_state_hacspec(new_size: u32) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn resize_state_hacspec(new_size: u32) -> u32 {
      resize_state_creusot(new_size)
  }
#+end_src
Extern for parameter section
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Write a section of the parameter to the given location. Return the number
      // of bytes written. The location is assumed to contain enough memory to
      // write the requested length into.
      pub(crate) fn get_parameter_section(param_bytes: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_parameter_section_creusot(start: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { get_parameter_section(start, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  fn get_parameter_section_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_parameter_section_hacspec(buf: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      let result = get_parameter_section_creusot(temp.as_mut_ptr(), buf.len() as u32, offset);
      (
	  coerce_rust_to_hacspec_public_byte_seq(&temp),
	  result,
      )
  }

#+end_src
Extern for parameter size and ~HasParameter~ trait.
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Get the size of the parameter to the method (either init or receive).
      pub(crate) fn get_parameter_size() -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_parameter_size_creusot() -> u32 {
      unsafe { get_parameter_size() }
  }

  #[cfg(feature = "hacspec")]
  fn get_parameter_size_hacspec() -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_parameter_size_hacspec() -> u32 {
      get_parameter_size_creusot()
  }

  #[cfg(not(feature = "hacspec"))]
  impl HasParameter for Parameter {
      #[inline(always)]
      fn size(&self) -> u32 {
	  get_parameter_size_hacspec()
      }
  }

#+end_src
Get slot time extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Getters for the chain meta data
    /// Slot time (in milliseconds) from chain meta data
    pub(crate) fn get_slot_time() -> u64;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_slot_time_creusot() -> u64 {
      unsafe { get_slot_time() }
  }

  #[cfg(feature = "hacspec")]
  fn get_slot_time_hacspec() -> u64 {
      1u64
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_slot_time_hacspec() -> u64 {
      get_slot_time_creusot()
  }
#+end_src
Get policy section extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Write a section of the policy to the given location. Return the number
    // of bytes written. The location is assumed to contain enough memory to
    // write the requested length into.
    pub(crate) fn get_policy_section(policy_bytes: *mut u8, length: u32, offset: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_policy_section_creusot(policy_bytes: *mut u8, length: u32, offset: u32) -> u32 {
      unsafe { get_policy_section(policy_bytes, length, offset) }
  }

  #[cfg(feature = "hacspec")]
  fn get_policy_section_hacspec(policy_bytes: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (policy_bytes, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_policy_section_hacspec(policy_bytes: PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(policy_bytes.clone())[..];
      let result = get_policy_section_creusot(temp.as_mut_ptr(), policy_bytes.len() as u32, offset);
      (
	  coerce_rust_to_hacspec_public_byte_seq(&temp),
	  result,
      )
  }

#+end_src
Get init origin extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Getter for the init context.
    /// Address of the sender, 32 bytes
    pub(crate) fn get_init_origin(start: *mut u8);
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_init_origin_creusot(start: *mut u8) {
      unsafe { get_init_origin(start) }
  }

  #[cfg(feature = "hacspec")]
  fn get_init_origin_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      start
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_init_origin_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      get_init_origin_creusot(temp.as_mut_ptr());
      coerce_rust_to_hacspec_public_byte_seq(&temp)
  }

#+end_src
Get receive invoker extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    /// Invoker of the top-level transaction, AccountAddress.
    pub(crate) fn get_receive_invoker(start: *mut u8);
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_receive_invoker_creusot(start: *mut u8) {
      unsafe { get_receive_invoker(start) }
  }

  #[cfg(feature = "hacspec")]
  fn get_receive_invoker_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      start
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_receive_invoker_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      get_receive_invoker_creusot(temp.as_mut_ptr());
      coerce_rust_to_hacspec_public_byte_seq(&temp)
  }

#+end_src
Get receive self address extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    /// Address of the contract itself, ContractAddress.
    pub(crate) fn get_receive_self_address(start: *mut u8);
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_receive_self_address_creusot(start: *mut u8) {
      unsafe { get_receive_self_address(start) }
  }

  #[cfg(feature = "hacspec")]
  fn get_receive_self_address_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      start
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_receive_self_address_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      get_receive_self_address_creusot(temp.as_mut_ptr());
      coerce_rust_to_hacspec_public_byte_seq(&temp)
  }

#+end_src
Get receive self balance extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    /// Self-balance of the contract, returns the amount
    pub(crate) fn get_receive_self_balance() -> u64;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_receive_self_balance_creusot() -> u64 {
      unsafe { get_receive_self_balance() }
  }

  #[cfg(feature = "hacspec")]
  fn get_receive_self_balance_hacspec() -> u64 {
      1u64
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_receive_self_balance_hacspec() -> u64 {
      get_receive_self_balance_creusot()
  }

#+end_src
Get receive sender extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    /// Immediate sender of the message (either contract or account).
    pub(crate) fn get_receive_sender(start: *mut u8);
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_receive_sender_creusot(start: *mut u8) {
      unsafe { get_receive_sender(start) }
  }

  #[cfg(feature = "hacspec")]
  fn get_receive_sender_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      start
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_receive_sender_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      get_receive_sender_creusot(temp.as_mut_ptr());
      coerce_rust_to_hacspec_public_byte_seq(&temp)
  }

#+end_src
Get receive owner extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    /// Owner of the contract, AccountAddress.
    pub(crate) fn get_receive_owner(start: *mut u8);
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn get_receive_owner_creusot(start: *mut u8) {
      unsafe { get_receive_owner(start) }
  }

  #[cfg(feature = "hacspec")]
  fn get_receive_owner_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      start
  }

  #[cfg(not(feature = "hacspec"))]
  fn get_receive_owner_hacspec(start: PublicByteSeq) -> PublicByteSeq {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      get_receive_owner_creusot(temp.as_mut_ptr());
      coerce_rust_to_hacspec_public_byte_seq(&temp)
  }

#+end_src
Log event extern
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      // Add a log item. Return values are
      // - -1 if logging failed due to the message being too long
      // - 0 if the log is already full
      // - 1 if data was successfully logged.
      pub(crate) fn log_event(start: *const u8, length: u32) -> i32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn log_event_creusot(start: *const u8, length: u32) -> i32 {
      unsafe { log_event(start, length) }
  }

  #[cfg(feature = "hacspec")]
  fn log_event_hacspec(start: PublicByteSeq) -> (PublicByteSeq, i32) {
      (start, 1i32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn log_event_hacspec(start: PublicByteSeq) -> (PublicByteSeq, i32) {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(start.clone())[..];
      let result = log_event_creusot(temp.as_ptr(), start.len() as u32);
      (coerce_rust_to_hacspec_public_byte_seq(&temp), result)
  }

#+end_src
Extern accept
#+begin_src rust :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn accept() -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn accept_creusot() -> u32 {
      unsafe { accept() }
  }

  #[cfg(feature = "hacspec")]
  fn accept_hacspec() -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn accept_hacspec() -> u32 {
      accept_creusot()
  }
  
#+end_src
Extern simple transfer
#+begin_src rust :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Basic action to send tokens to an account.
    pub(crate) fn simple_transfer(addr_bytes: *const u8, amount: u64) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn simple_transfer_creusot(addr_bytes: *const u8, amount: u64) -> u32 {
      unsafe { simple_transfer(addr_bytes, amount) }
  }

  #[cfg(feature = "hacspec")]
  fn simple_transfer_hacspec(buf: PublicByteSeq, amount: u64) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn simple_transfer_hacspec(buf: PublicByteSeq, amount: u64) -> u32 {
      let temp = &mut coerce_hacspec_to_rust_public_byte_seq(buf.clone())[..];
      simple_transfer_creusot(temp.as_ptr(), amount)
  }

#+end_src
Extern send
#+begin_src rust :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Send a message to a smart contract.
    pub(crate) fn send(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: *const u8,
        receive_name_len: u32,
        amount: u64,
        parameter: *const u8,
        parameter_len: u32,
    ) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn send_creusot(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: *const u8,
        receive_name_len: u32,
        amount: u64,
        parameter: *const u8,
        parameter_len: u32,
    ) -> u32 {
      unsafe { send(addr_index, addr_subindex, receive_name, receive_name_len, amount, parameter, parameter_len) }
  }

  #[cfg(feature = "hacspec")]
  fn send_hacspec(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: PublicByteSeq,
        amount: u64,
        parameter: PublicByteSeq,
    ) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn send_hacspec(
        addr_index: u64,
        addr_subindex: u64,
        receive_name: PublicByteSeq,
        amount: u64,
        parameter: PublicByteSeq,
    ) -> u32 {
      let temp_receive_name = &mut coerce_hacspec_to_rust_public_byte_seq(receive_name.clone())[..];
      let temp_parameter = &mut coerce_hacspec_to_rust_public_byte_seq(parameter.clone())[..];
      send_creusot(addr_index, addr_subindex, temp_receive_name.as_ptr(), receive_name.len() as u32, amount, temp_parameter.as_ptr(), parameter.len() as u32)
  }

#+end_src
Extern combine and
#+begin_src rust :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Combine two actions using normal sequencing. This is using the stack of
    // actions already produced.
    pub(crate) fn combine_and(l: u32, r: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn combine_and_creusot(l: u32, r: u32) -> u32 {
      unsafe { combine_and(l, r) }
  }

  #[cfg(feature = "hacspec")]
  fn combine_and_hacspec(l: u32, r: u32) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn combine_and_hacspec(l: u32, r: u32) -> u32 {
      combine_and_creusot(l,r)
  }

#+end_src
Extern combine or
#+begin_src rust :eval never  
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
    // Combine two actions using normal sequencing. This is using the stack of
    // actions already produced.
    pub(crate) fn combine_or(l: u32, r: u32) -> u32;
  }

  #[cfg(not(feature = "hacspec"))]
  #[trusted]
  pub(crate) fn combine_or_creusot(l: u32, r: u32) -> u32 {
      unsafe { combine_or(l, r) }
  }

  #[cfg(feature = "hacspec")]
  fn combine_or_hacspec(l: u32, r: u32) -> u32 {
      1u32
  }

  #[cfg(not(feature = "hacspec"))]
  fn combine_or_hacspec(l: u32, r: u32) -> u32 {
      combine_or_creusot(l,r)
  }

#+end_src

* Concordium "Impls" specification
** Rust code
:PROPERTIES:
:header-args:  :tangle ../../examples/concordium/src/hacspec_concordium_impls.rs
:END:

*** Imports
#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  use crate::{
      collections::{BTreeMap, BTreeSet},
      convert::{self, TryFrom, TryInto},
      hash::Hash,
      num::NonZeroI32,
      vec::Vec,
      String,
      trap,
  };

  #[cfg(not(feature = "hacspec"))]
  use concordium_contracts_common::*;
#+END_SRC

#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  use crate::*;
  #[cfg(not(feature = "hacspec"))]
  use hacspec_concordium_traits::*;
  #[cfg(not(feature = "hacspec"))]
  use hacspec_concordium_types::*;
#+END_SRC

#+BEGIN_SRC rust :eval never
  #[cfg(not(feature = "hacspec"))]
  extern crate hacspec_lib;

  use hacspec_lib::*;

  // #[cfg(feature = "hacspec_attributes")]
  #[cfg(feature = "hacspec")]
  use hacspec_attributes::*;

  // Creusot
  #[cfg(not(feature = "hacspec"))]
  extern crate creusot_contracts;
  #[cfg(not(feature = "hacspec"))]
  use creusot_contracts::{
      ensures,
      requires,
      trusted	  
      };
#+END_SRC

*** Reject
We modle reject as the underlying data, that is the src_rust[:eval never]{i32} error code. The default constructor is i32 min.
#+begin_src rust :eval never
  pub type RejectHacspec = i32;

  pub fn reject_impl_deafult() -> RejectHacspec {
      i32::MIN
  }

#+end_src
We then implement the new operations for Reject.
#+begin_src rust :eval never
  pub fn new_reject_impl(x: i32) -> Option::<i32> { // Option<RejectHacspec>
      // TODO: fix 'identifier is not a constant' error (Seems to be fixed by some import?)
      if x < 0i32 {
	  Option::<i32>::Some(x)
      } else {
	  Option::<i32>::None
      }
  }

#+end_src
We define the coercion function for Reject, and implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_reject(hacspec_reject: RejectHacspec) -> Reject {
      Reject {
	  error_code: unsafe { NonZeroI32::new_unchecked(hacspec_reject) },
      }
  }
#+end_src

**** Reject - From trait
#+begin_src rust :tangle no :eval never
  impl convert::From<()> for Reject {
      #[inline(always)]
      fn from(_: ()) -> Self {
	  Reject {
	      error_code: unsafe { NonZeroI32::new_unchecked(i32::MIN + 1) },
	  }
      }
  }

  impl convert::From<ParseError> for Reject {
      #[inline(always)]
      fn from(_: ParseError) -> Self {
	  Reject {
	      error_code: unsafe { NonZeroI32::new_unchecked(i32::MIN + 2) },
	  }
      }
  }
#+end_src

We modle the unsafe block with unchecked non zero as a precondition using requires giving us the hacspec equivalent
#+begin_src rust :eval never
  #[ensures(!(result === 0i32))] // !=
  pub fn reject_impl_convert_from_unit() -> RejectHacspec {
      i32::MIN + 1i32
  }

  #[ensures(!(result === 0i32))] // !=
  pub fn reject_impl_convert_from_parse_error() -> RejectHacspec {
      i32::MIN + 2i32
  }
#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl convert::From<()> for Reject {
      #[inline(always)]
      fn from(_: ()) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_convert_from_unit())
      }
  }

  #[cfg(not(feature = "hacspec"))]
  impl convert::From<ParseError> for Reject {
      #[inline(always)]
      fn from(_: ParseError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_convert_from_parse_error())
      }
  }  
#+end_src
We define a log error type and function converting from it to the reject type
#+begin_src rust :eval never
  #[ensures(!(result === 0i32))] // !=
  pub fn reject_impl_from_log_error(le: LogError) -> RejectHacspec {
      match le {
	  LogError::Full => i32::MIN + 3i32,
	  LogError::Malformed => i32::MIN + 4i32,
      }
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Full is mapped to i32::MIN+3, Malformed is mapped to i32::MIN+4.
  impl From<LogError> for Reject {
      #[inline(always)]
      fn from(le: LogError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_from_log_error(le))
      }
  }

#+end_src
We define a type for new contract name errors and conversion from it to reject
#+begin_src rust :eval never
  #[derive(Clone)] // , Debug, PartialEq, Eq
  pub enum NewContractNameError {
      NewContractNameErrorMissingInitPrefix,
      NewContractNameErrorTooLong,
      NewContractNameErrorContainsDot,
      NewContractNameErrorInvalidCharacters,
  }

  #[ensures(!(result === 0i32))] // !=
  pub fn reject_impl_from_new_contract_name_error(nre: NewContractNameError) -> RejectHacspec {
      match nre {
	  NewContractNameError::NewContractNameErrorMissingInitPrefix => i32::MIN + 5i32,
	  NewContractNameError::NewContractNameErrorTooLong => i32::MIN + 6i32,
	  NewContractNameError::NewContractNameErrorContainsDot => i32::MIN + 9i32,
	  NewContractNameError::NewContractNameErrorInvalidCharacters => i32::MIN + 10i32,
      }
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// MissingInitPrefix is mapped to i32::MIN + 5,
  /// TooLong to i32::MIN + 6,
  /// ContainsDot to i32::MIN + 9, and
  /// InvalidCharacters to i32::MIN + 10.
  impl From<NewContractNameError> for Reject {
      fn from(nre: NewContractNameError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_from_new_contract_name_error(nre))
      }
  }

#+end_src
We define a type for new receive name errors and conversion from it to reject
#+begin_src rust :eval never
  #[derive(Clone)] // , Debug, PartialEq, Eq
  pub enum NewReceiveNameError {
      NewReceiveNameErrorMissingDotSeparator,
      NewReceiveNameErrorTooLong,
      NewReceiveNameErrorInvalidCharacters,
  }

  #[ensures(!(result === 0i32))] // !=
  pub fn reject_impl_from_new_receive_name_error(nre: NewReceiveNameError) -> RejectHacspec {
      match nre {
	  NewReceiveNameError::NewReceiveNameErrorMissingDotSeparator => i32::MIN + 7i32,
	  NewReceiveNameError::NewReceiveNameErrorTooLong => i32::MIN + 8i32,
	  NewReceiveNameError::NewReceiveNameErrorInvalidCharacters => i32::MIN + 11i32,
      }
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// MissingDotSeparator is mapped to i32::MIN + 7,
  /// TooLong to i32::MIN + 8, and
  /// InvalidCharacters to i32::MIN + 11.
  impl From<NewReceiveNameError> for Reject {
      fn from(nre: NewReceiveNameError) -> Self {
	  coerce_hacspec_to_rust_reject(reject_impl_from_new_receive_name_error(nre))
      }
  }

#+end_src

*** Contract state
We define contract state as its inner state namely the current position of the src_rust[:eval never]{u32} type.
#+begin_src rust :eval never
  pub type ContractStateHacspec = u32;
  
#+end_src
**** Contract State -- Seek
#+begin_src rust :eval never
  #[derive(Copy, Clone)] // , Debug, PartialEq, Eq
  pub enum SeekFromHacspec {
      /// Sets the offset to the provided number of bytes.
      Start(u64),

      /// Sets the offset to the size of this object plus the specified number of
      /// bytes.
      ///
      /// It is possible to seek beyond the end of an object, but it's an error to
      /// seek before byte 0.
      End(i64),

      /// Sets the offset to the current position plus the specified number of
      /// bytes.
      ///
      /// It is possible to seek beyond the end of an object, but it's an error to
      /// seek before byte 0.
      Current(i64),
  }

  pub type U32Option = Option<u32>;
  pub type I64Option = Option<i64>;

  // #[requires(forall<delta : i64> pos === SeekFrom::End(delta) ==> exists<b : u32> current_position.checked_add(delta as u32) == U32Option::Some(b))]
  pub fn contract_state_impl_seek(current_position: ContractStateHacspec, pos: SeekFromHacspec) -> Result<(ContractStateHacspec, u64), ()> {
      match pos {
	  SeekFromHacspec::Start(offset) => Result::<(ContractStateHacspec, u64), ()>::Ok((offset as u32, offset)),
	  SeekFromHacspec::End(delta) => {
	      if delta >= 0_i64 {
		  match current_position.checked_add(delta as u32) {
		      U32Option::Some(b) => Result::<(ContractStateHacspec, u64), ()>::Ok((b, delta as u64)),
		      U32Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
		  }
	      } else {
		  match delta.checked_abs() {
		      I64Option::Some(b) =>
		      {
			  Result::<(ContractStateHacspec, u64), ()>::Ok(((4_u32 - (b as u32)), (4_u32 - (b as u32)) as u64))
		      }
		      I64Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
		  }
	      }
	  }
	  SeekFromHacspec::Current(delta) => {
	      if delta >= 0_i64 {
		  match current_position.checked_add(delta as u32) {
		      U32Option::Some(offset) => Result::<(ContractStateHacspec, u64), ()>::Ok((offset, offset as u64)),
		      U32Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
		  }
	      } else {
		  match delta.checked_abs() {
		      I64Option::Some(b) => match current_position.checked_sub(b as u32) {
			  U32Option::Some(offset) => Result::<(ContractStateHacspec, u64), ()>::Ok((offset, offset as u64)),
			  U32Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
		      },
		      I64Option::None => Result::<(ContractStateHacspec, u64), ()>::Err(()),
		  }
	      }
	  }
      }
  }
#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_contract_state(
      rust_contract_state: &mut ContractState,
  ) -> ContractStateHacspec {
      rust_contract_state.current_position.clone()
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_contract_state(
      rust_contract_state: &mut ContractState,
      hacspec_contract_state: ContractStateHacspec,
  ) {
      rust_contract_state.current_position = hacspec_contract_state;
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_seek_result(
      rust_contract_state: &mut ContractState,
      hacspec_seek_result: Result<(ContractStateHacspec, u64), ()>,
  ) -> Result<u64, ()> {
      let (hacspec_result, rust_result) = hacspec_seek_result?;
      coerce_hacspec_to_rust_contract_state(rust_contract_state, hacspec_result);
      Ok(rust_result)
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_seek_from(rust_seek_from: SeekFrom) -> SeekFromHacspec {
      match rust_seek_from {
	  SeekFrom::Start(v) => SeekFromHacspec::Start(v),
	  SeekFrom::End(v) => SeekFromHacspec::End(v),
	  SeekFrom::Current(v) => SeekFromHacspec::Current(v),
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// # Contract state trait implementations.
  impl Seek for ContractState {
      type Err = ();

      fn seek(&mut self, pos: SeekFrom) -> Result<u64, Self::Err> {
	  let contract_state = coerce_rust_to_hacspec_contract_state(self);
	  coerce_hacspec_to_rust_seek_result(
	      self,
	      contract_state_impl_seek(
		  contract_state,
		  coerce_rust_to_hacspec_seek_from(pos),
	      ),
	  )
      }
  }
#+end_src

**** Contract State -- Load
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_public_byte_seq(buf: &[u8]) -> PublicByteSeq {
      PublicByteSeq::from_native_slice(buf)
  }

  // TODO: Make creusot friendly version
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_public_byte_seq(buf: PublicByteSeq) -> Vec<u8> {
      // buf.native_slice().iter().collect();
      let mut temp_vec: Vec<u8> = Vec::new();
      for i in 0..buf.len() {
	  temp_vec.push(buf.index(i).clone())
      }
      temp_vec
  }

#+end_src


**** Contract State -- Read
#+begin_src rust :eval never
  pub fn contract_state_impl_read_read(
      current_position: ContractStateHacspec,
      buf : PublicByteSeq,
  ) -> (ContractStateHacspec, usize) {
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, num_read as usize)
  }

  /// Read a u32 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u64(
      current_position: ContractStateHacspec,
  ) -> (ContractStateHacspec, u64) {
      // let mut bytes: MaybeUninit<[u8; 8]> = MaybeUninit::uninit();
      let buf = PublicByteSeq::new(8);
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, u64_from_le_bytes(u64Word::from_seq(&buf))) // num_read as u64
  }

  /// Read a u32 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u32(
      current_position: ContractStateHacspec,
  ) -> (ContractStateHacspec, u32) {
      // let mut bytes: MaybeUninit<[u8; 4]> = MaybeUninit::uninit();
      let buf = PublicByteSeq::new(4);
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, u32_from_le_bytes(u32Word::from_seq(&buf))) // num_read as u64
  }

  /// Read a u8 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  pub fn contract_state_impl_read_read_u8(
      current_position: ContractStateHacspec,
  ) -> (ContractStateHacspec, u8) {
      let buf = PublicByteSeq::new(1);
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, buf[0]) // num_read as u64
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl Read for ContractState {
      fn read(&mut self, buf: &mut [u8]) -> ParseResult<usize> {
	  let (cs, nr) = contract_state_impl_read_read(
	      coerce_rust_to_hacspec_contract_state(self),
	      coerce_rust_to_hacspec_public_byte_seq(buf),
	  );
	  coerce_hacspec_to_rust_contract_state(self, cs);
	  Ok(nr)
      }

      // TODO: !! Probably incorrect !!
      /// Read a `u32` in little-endian format. This is optimized to not
      /// initialize a dummy value before calling an external function.
      fn read_u64(&mut self) -> ParseResult<u64> {
	  let (cs, nr) =
	      contract_state_impl_read_read_u64(coerce_rust_to_hacspec_contract_state(self));
	  coerce_hacspec_to_rust_contract_state(self, cs);
	  Ok(nr)
	  // if num_read == 8 {
	  //     unsafe { Ok(u64::from_le_bytes(bytes.assume_init())) }
	  // } else {
	  //     Err(ParseError::default())
	  // }
      }

      /// Read a `u32` in little-endian format. This is optimized to not
      /// initialize a dummy value before calling an external function.
      fn read_u32(&mut self) -> ParseResult<u32> {
	  let (cs, nr) =
	      contract_state_impl_read_read_u32(coerce_rust_to_hacspec_contract_state(self));
	  coerce_hacspec_to_rust_contract_state(self, cs);
	  Ok(nr)

	  // let mut bytes: MaybeUninit<[u8; 4]> = MaybeUninit::uninit();
	  // let num_read =
	  //     unsafe { load_state(bytes.as_mut_ptr() as *mut u8, 4, self.current_position) };
	  // self.current_position += num_read;
	  // if num_read == 4 {
	  //     unsafe { Ok(u32::from_le_bytes(bytes.assume_init())) }
	  // } else {
	  //     Err(ParseError::default())
	  // }
      }

      /// Read a `u8` in little-endian format. This is optimized to not
      /// initialize a dummy value before calling an external function.
      fn read_u8(&mut self) -> ParseResult<u8> {
	  let (cs, nr) =
	      contract_state_impl_read_read_u8(coerce_rust_to_hacspec_contract_state(self));
	  coerce_hacspec_to_rust_contract_state(self, cs);
	  Ok(nr)
      }
  }
#+end_src

**** Contract State -- Write
#+begin_src rust :eval never
  pub fn contract_state_impl_write(
      current_position: ContractStateHacspec,
      buf : PublicByteSeq
  ) -> Result<(ContractStateHacspec, usize), ()> {
      if current_position.checked_add(buf.len() as u32).is_none() {
	  Result::<(ContractStateHacspec, usize), ()>::Err(())?;
      }
      let (buf, num_bytes) = write_state_hacspec(buf, current_position);
      Result::<(ContractStateHacspec, usize), ()>::Ok((current_position + num_bytes, num_bytes as usize))
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl Write for ContractState {
      type Err = ();

      fn write(&mut self, buf: &[u8]) -> Result<usize, Self::Err> {
	  let (cs, nr) = contract_state_impl_write(
	      coerce_rust_to_hacspec_contract_state(self),
	      coerce_rust_to_hacspec_public_byte_seq(buf),
	  )?;
	  coerce_hacspec_to_rust_contract_state(self, cs);
	  Ok(nr)
      }
  }
#+end_src

**** Contract State -- Misc.

#+begin_src rust :eval never
  pub fn has_contract_state_impl_for_contract_state_open() -> ContractStateHacspec {
      0_u32
  }

  // pub fn has_contract_state_impl_for_contract_state_reserve_0(len: u32, cur_size: u32) -> bool {
  //     cur_size < len
  // }

  // pub fn has_contract_state_impl_for_contract_state_reserve_1(res: u32) -> bool {
  //     res == 1_u32
  // }

  pub fn has_contract_state_impl_for_contract_state_reserve(
      contract_state: ContractStateHacspec,
      len: u32,
  ) -> bool {
      let cur_size = state_size_hacspec();
      if cur_size < len {
	  resize_state_hacspec(len) == 1_u32
      } else {
	  true
      }
  }

  pub fn has_contract_state_impl_for_contract_state_truncate(
      current_position : ContractStateHacspec,
      cur_size: u32,
      new_size: u32,
  ) -> ContractStateHacspec {
      if cur_size > new_size {
	  resize_state_hacspec(new_size);
      }
      if new_size < current_position {
	  new_size
      }
      else {
	  current_position
      }
  }
#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl HasContractState<()> for ContractState {
      type ContractStateData = ();

      #[inline(always)]
      fn open(_: Self::ContractStateData) -> Self {
	  ContractState {
	      current_position: has_contract_state_impl_for_contract_state_open(),
	  }
      }

      fn reserve(&mut self, len: u32) -> bool {
	  has_contract_state_impl_for_contract_state_reserve(
	      coerce_rust_to_hacspec_contract_state(self),
	      len,
	  )
      }

      #[inline(always)]
      fn size(&self) -> u32 {
	  state_size_hacspec()
      }

      fn truncate(&mut self, new_size: u32) {
	  let current_position = coerce_rust_to_hacspec_contract_state(self);
	  coerce_hacspec_to_rust_contract_state(
	      self,
	      has_contract_state_impl_for_contract_state_truncate(
		  current_position,
		  self.size(),
		  new_size,
	      ),
	  )
      }
  }
  
#+end_src

*** Parameter
We define parameter
#+begin_src rust :eval never
  pub type ParameterHacspec = u32;

  pub fn read_impl_for_parameter_read(
      current_position: ParameterHacspec,
      buf: PublicByteSeq,
  ) -> (ParameterHacspec, usize) {
      let (buf, num_read) = get_parameter_section_hacspec(buf, current_position);
      (current_position + num_read, num_read as usize)
  }

#+end_src
We then implement the traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_parameter(
      rust_parameter: &mut Parameter,
  ) -> ParameterHacspec {
      rust_parameter.current_position.clone()
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_parameter(
      rust_parameter: &mut Parameter,
      hacspec_parameter: ParameterHacspec,
  ) {
      rust_parameter.current_position = hacspec_parameter;
  }

  
  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for Parameter
  impl Read for Parameter {
      fn read(&mut self, buf: &mut [u8]) -> ParseResult<usize> {
	  let (cs, nr) = read_impl_for_parameter_read(
	      coerce_rust_to_hacspec_parameter(self),
	      coerce_rust_to_hacspec_public_byte_seq(buf),
	  );
	  coerce_hacspec_to_rust_parameter(self, cs);
	  Ok(nr)
      }
  }

#+end_src
*** ChainMetaExtern
We define and implement traits for ~ChainMetaExtern~.
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for the chain metadata.
  impl HasChainMetadata for ChainMetaExtern {
      #[inline(always)]
      fn slot_time(&self) -> SlotTime {
	  Timestamp::from_timestamp_millis(get_slot_time_hacspec() )
      }
  }
#+end_src

*** AttributesCursor

#+begin_src rust :eval never
  // pub struct AttributeTag(pub u8);
  pub type AttributesCursorHacspec = (u32, u16);

  // pub fn has_policy_impl_for_policy_attributes_cursor_next_test(
  //     policy_attribute_items: AttributesCursorHacspec,
  // ) -> bool {
  //     let (_, remaining_items) = policy_attribute_items;
  //     remaining_items == 0_u16
  // }

  // pub fn has_policy_impl_for_policy_attributes_cursor_next_tag_invalid(
  //     policy_attribute_items: AttributesCursorHacspec,
  //     tag_value_len_1: u8,
  //     num_read: u32,
  // ) -> (AttributesCursorHacspec, bool) {
  //     let (current_position, remaining_items) = policy_attribute_items;
  //     let policy_attribute_items = (current_position + num_read, remaining_items);
  //     (policy_attribute_items, tag_value_len_1 > 31_u8)
  // }

  pub fn has_policy_impl_for_policy_attributes_cursor_next_item(
      policy_attribute_items: AttributesCursorHacspec,
      buf: PublicByteSeq,
  ) -> Option<(AttributesCursorHacspec, (u8, u8))> {

      let (mut current_position, mut remaining_items) = policy_attribute_items;

      // TODO: fix 'identifier is not a constant' error
      if remaining_items == 0u16 {
	  Option::<(AttributesCursorHacspec, (u8, u8))>::None?;
      }

      let (tag_value_len, num_read) = get_policy_section_hacspec(PublicByteSeq::new(2), current_position);
      current_position = current_position + num_read;

      // TODO: fix 'identifier is not a constant' error
      if tag_value_len[1] > 31u8 {
	  // Should not happen because all attributes fit into 31 bytes.
	  Option::<(AttributesCursorHacspec, (u8, u8))>::None?;
      }

      let (buf, num_read) = get_policy_section_hacspec(buf, current_position);
      current_position = current_position + num_read;
      remaining_items = remaining_items - 1u16;
      Option::<(AttributesCursorHacspec, (u8, u8))>::Some(((current_position, remaining_items), (tag_value_len[0], tag_value_len[1])))
  }

#+end_src
We then define traits
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_rust_to_hacspec_attributes_cursor(
      rust_attributes_cursor: &mut AttributesCursor,
  ) -> AttributesCursorHacspec {
      (
	  rust_attributes_cursor.current_position.clone(),
	  rust_attributes_cursor.remaining_items.clone(),
      )
  }

  #[cfg(not(feature = "hacspec"))]
  pub fn coerce_hacspec_to_rust_attributes_cursor(
      rust_attributes_cursor: &mut AttributesCursor,
      hacspec_attributes_cursor: AttributesCursorHacspec,
  ) {
      let (current_position, remaining_items) = hacspec_attributes_cursor;
      rust_attributes_cursor.current_position = current_position;
      rust_attributes_cursor.remaining_items = remaining_items;
  }

  #[cfg(not(feature = "hacspec"))]
  /// Policy on the credential of the account.
  ///
  /// This is one of the key features of the Concordium blockchain. Each account
  /// on the chain is backed by an identity. The policy is verified and signed by
  /// the identity provider before an account can be created on the chain.
  ///
  /// The type is parameterized by the choice of `Attributes`. These are either
  /// borrowed or owned, in the form of an iterator over key-value pairs or a
  /// vector of such. This flexibility is needed so that attributes can be
  /// accessed efficiently, as well as constructed conveniently for testing.
  #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
  #[derive(Clone)] // TODO: Creusot issue readd "Debug" attribute
  pub struct Policy<Attributes> {
      /// Identity of the identity provider who signed the identity object that
      /// this policy is derived from.
      pub identity_provider: IdentityProvider,
      /// Timestamp at the beginning of the month when the identity object backing
      /// this policy was created. This timestamp has very coarse granularity
      /// in order for the identity provider to not be able to link identities
      /// they have created with accounts that users created on the chain.
      /// as a timestamp (which has millisecond granularity) in order to make it
      /// easier to compare with, e.g., `slot_time`.
      pub created_at: Timestamp,
      /// Beginning of the month where the identity is __no longer valid__.
      pub valid_to: Timestamp,
      /// List of attributes, in ascending order of the tag.
      pub items: Attributes,
  }

  // TODO: Creusot issues?
  #[cfg(not(feature = "hacspec"))]
  impl HasPolicy for Policy<AttributesCursor> {
      fn identity_provider(&self) -> IdentityProvider {
	  self.identity_provider
      }

      fn created_at(&self) -> Timestamp {
	  self.created_at
      }

      fn valid_to(&self) -> Timestamp {
	  self.valid_to
      }

      fn next_item(&mut self, buf: &mut [u8; 31]) -> Option<(AttributeTag, u8)> {
	  let (ac, (at, v)) = has_policy_impl_for_policy_attributes_cursor_next_item(
	      coerce_rust_to_hacspec_attributes_cursor(&mut self.items),
	      coerce_rust_to_hacspec_public_byte_seq(&mut buf[..]),
	  )?;
	  coerce_hacspec_to_rust_attributes_cursor(&mut self.items, ac);
	  Some((AttributeTag(at), v))
      }
  }
#+end_src

*** Policy iterator
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// An iterator over policies using host functions to supply the data.
  /// The main interface to using this type is via the methods of the [Iterator](https://doc.rust-lang.org/std/iter/trait.Iterator.html)
  /// and [ExactSizeIterator](https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html) traits.
  pub struct PoliciesIterator {
      /// Position in the policies binary serialization.
      pos: u32,
      /// Number of remaining items in the stream.
      remaining_items: u16,
  }

  pub type PoliciesIteratorHacspec = (u32, u16);

  // TODO: use PolicyAttributesCursorHacspec for implementation above instead of just AttributesCursorHacspec
  pub type PolicyAttributesCursorHacspec = (u32, u64, u64, AttributesCursorHacspec); // IdentityProvider, Timestamp, Timestamp, AttributesCursor

  // TODO: Fix creusot issues?
  fn iterator_impl_for_policies_iterator_next(
      policies_iterator: PoliciesIteratorHacspec,
  ) -> Option<(PoliciesIteratorHacspec, PolicyAttributesCursorHacspec)> {
      let (mut pos, remaining_items) = policies_iterator;
      // TODO: fix 'identifier is not a constant' error
      if remaining_items == 0u16 {
	  Option::<(PoliciesIteratorHacspec, PolicyAttributesCursorHacspec)>::None?;
      }

      // 2 for total size of this section, 4 for identity_provider,
      // 8 bytes for created_at, 8 for valid_to, and 2 for
      // the length
      let (buf, _) = get_policy_section_hacspec(PublicByteSeq::new(2 + 4 + 8 + 8 + 2), pos);
      let skip_part: PublicByteSeq = buf.slice_range(0..2);
      let ip_part: PublicByteSeq = buf.slice_range(2..2 + 4);
      let created_at_part: PublicByteSeq = buf.slice_range(2 + 4..2 + 4 + 8);
      let valid_to_part: PublicByteSeq = buf.slice_range(2 + 4 + 8..2 + 4 + 8 + 8);
      let len_part: PublicByteSeq = buf.slice_range(2 + 4 + 8 + 8..2 + 4 + 8 + 8 + 2);
      let identity_provider = u32_from_le_bytes(u32Word::from_seq(&ip_part)); // IdentityProvider = u32 // UnsignedPublicInteger
      let created_at = u64_from_le_bytes(u64Word::from_seq(&created_at_part)); // Timestamp = Timestamp::from_timestamp_millis(u64)
      let valid_to = u64_from_le_bytes(u64Word::from_seq(&valid_to_part)); // Timestamp = u64)
      let mut remaining_items = u16_from_le_bytes(u16Word::from_seq(&len_part));
      let attributes_start = pos + 2u32 + 4u32 + 8u32 + 8u32 + 2u32;
      pos = pos + (u16_from_le_bytes(u16Word::from_seq(&skip_part)) as u32) + 2u32;
      remaining_items = remaining_items - 1u16;
      Option::<(PoliciesIteratorHacspec, PolicyAttributesCursorHacspec)>::Some((
	  (pos, remaining_items),
	  (
	      identity_provider,
	      created_at,
	      valid_to,
	      (attributes_start, remaining_items),
	  ),
      ))
  }

  // TODO: Fix creusot issues?
  #[cfg(not(feature = "hacspec"))]
  impl Iterator for PoliciesIterator {
      type Item = Policy<AttributesCursor>;

      fn next(&mut self) -> Option<Self::Item> {
	  let ((pos, remaining_items), (identity_provider, created_at, valid_to, (cp, ri))) =
	      iterator_impl_for_policies_iterator_next((self.pos, self.remaining_items))?;

	  // TODO: make into coerce function
	  self.pos = pos;
	  self.remaining_items = remaining_items;

	  Some(Policy {
	      identity_provider,
	      created_at: Timestamp::from_timestamp_millis(created_at),
	      valid_to: Timestamp::from_timestamp_millis(valid_to),
	      items: AttributesCursor {
		  current_position: cp,
		  remaining_items: ri,
	      },
	  })
      }

      fn size_hint(&self) -> (usize, Option<usize>) {
	  let rem = self.remaining_items as usize;
	  (rem, Some(rem))
      }
  }

  #[cfg(not(feature = "hacspec"))]
  impl ExactSizeIterator for PoliciesIterator {
      #[inline(always)]
      fn len(&self) -> usize {
	  self.remaining_items.into() // as usize
      }
  }
#+end_src

*** External context
#+begin_src rust :eval never

  #[cfg(not(feature = "hacspec"))]
  impl<T: sealed::ContextType> HasCommonData for ExternContext<T> {
      type MetadataType = ChainMetaExtern;
      type ParamType = Parameter;
      type PolicyIteratorType = PoliciesIterator;
      type PolicyType = Policy<AttributesCursor>;

      // TODO: fix creusot issue
      #[inline(always)]
      fn metadata(&self) -> &Self::MetadataType {
	  &ChainMetaExtern {}
      }

      fn policies(&self) -> PoliciesIterator {
	  let (buf, _) = get_policy_section_hacspec(PublicByteSeq::new(2), 0);
	  PoliciesIterator {
	      pos: 2, // 2 because we already read 2 bytes.
	      remaining_items: u16_from_le_bytes(u16Word::from_seq(&buf)),
	  }
      }

      #[inline(always)]
      fn parameter_cursor(&self) -> Self::ParamType {
	  Parameter {
	      current_position: 0,
	  }
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for the init context
  impl HasInitContext for ExternContext<InitContextExtern> {
      type InitData = ();

      /// Create a new init context by using an external call.
      fn open(_: Self::InitData) -> Self {
	  ExternContext::default()
      }

      #[inline(always)]
      fn init_origin(&self) -> AccountAddress {
	  let mut address : [u8; ACCOUNT_ADDRESS_SIZE] = Default::default();
	  let temp = coerce_hacspec_to_rust_public_byte_seq(get_init_origin_hacspec(
	      PublicByteSeq::new(ACCOUNT_ADDRESS_SIZE),
	  ));
	  address.clone_from_slice(temp.as_slice());
	  AccountAddress(address)
      }
  }

  #[cfg(not(feature = "hacspec"))]
  /// # Trait implementations for the receive context
  impl HasReceiveContext for ExternContext<ReceiveContextExtern> {
      type ReceiveData = ();

      /// Create a new receive context
      fn open(_: Self::ReceiveData) -> Self {
	  ExternContext::default()
      }

      // TODO: Make usable by creusot
      #[inline(always)]
      fn invoker(&self) -> AccountAddress {
	  let mut address: [u8; ACCOUNT_ADDRESS_SIZE] = Default::default();
	  address.clone_from_slice(
	      &mut coerce_hacspec_to_rust_public_byte_seq(get_receive_invoker_hacspec(
		  PublicByteSeq::new(ACCOUNT_ADDRESS_SIZE),
	      ))[..],
	  );
	  AccountAddress(address)
      }

      // TODO: Make usable by creusot
      #[inline(always)]
      fn self_address(&self) -> ContractAddress {
	  let mut address: [u8; ACCOUNT_ADDRESS_SIZE] = Default::default();
	  address.clone_from_slice(
	      &mut coerce_hacspec_to_rust_public_byte_seq(get_receive_self_address_hacspec(
		  PublicByteSeq::new(ACCOUNT_ADDRESS_SIZE),
	      ))[..],
	  );
	  match concordium_contracts_common::from_bytes(&address) {
	      Ok(v) => v,
	      Err(_) => trap(),
	  }
      }

      #[inline(always)]
      fn self_balance(&self) -> Amount {
	  Amount::from_micro_gtu(get_receive_self_balance_hacspec())
      }

      // TODO: Make usable by creusot
      // TODO: Remove/replace unsafe code !
      #[inline(always)]
      fn sender(&self) -> Address {
	  let ptr : *mut u8 = (&mut coerce_hacspec_to_rust_public_byte_seq(get_receive_sender_hacspec(
	      PublicByteSeq::new(ACCOUNT_ADDRESS_SIZE),
	  ))[..]).as_mut_ptr();
	  let tag = unsafe { *ptr };
	  match tag {
	      0u8 => {
		  match concordium_contracts_common::from_bytes(unsafe { core::slice::from_raw_parts(
		      ptr.add(1),
		      ACCOUNT_ADDRESS_SIZE,
		  )} ) {
		      Ok(v) => Address::Account(v),
		      Err(_) => trap(),
		  }
	      }
	      1u8 => match concordium_contracts_common::from_bytes(unsafe { core::slice::from_raw_parts(ptr.add(1), 16) }) {
		  Ok(v) => Address::Contract(v),
		  Err(_) => trap(),
	      },
	      _ => trap(), // unreachable!("Host violated precondition."),
	  }
      }

      // TODO: Make usable by creusot
      #[inline(always)]
      fn owner(&self) -> AccountAddress {
	  let mut address: [u8; ACCOUNT_ADDRESS_SIZE] = Default::default();
	  address.clone_from_slice(
	      &mut coerce_hacspec_to_rust_public_byte_seq(get_receive_self_address_hacspec(
		  PublicByteSeq::new(ACCOUNT_ADDRESS_SIZE),
	      ))[..],
	  );
	  AccountAddress(address)
      }
  }
#+end_src

*** Logger

#+begin_src rust :eval never
  // #[cfg(not(feature = "hacspec"))]
  // /// A type representing the logger.
  // #[derive(Default)]
  // pub struct Logger {
  //     pub(crate) _private: (),
  // }

  #[cfg(not(feature = "hacspec"))]
  /// #Implementations of the logger.
  impl HasLogger for Logger {
      #[inline(always)]
      fn init() -> Self {
	  Self { _private: () }
      }

      fn log_raw(&mut self, event: &[u8]) -> Result<(), LogError> {
	  let (_, res) = log_event_hacspec(coerce_rust_to_hacspec_public_byte_seq(event));
	  match res {
	      1 => Ok(()),
	      0 => Err(LogError::Full),
	      _ => Err(LogError::Malformed),
	  }
      }
  }
#+end_src
*** Action
#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// #Implementation of actions.
  /// These actions are implemented by direct calls to host functions.
  impl HasActions for Action {
      #[inline(always)]
      fn accept() -> Self {
	  Action {
	      _private: accept_hacspec(),
	  }
      }

      #[inline(always)]
      fn simple_transfer(acc: &AccountAddress, amount: Amount) -> Self {
	  let res = simple_transfer_hacspec(coerce_rust_to_hacspec_public_byte_seq(&acc.0), amount.micro_gtu);
	  Action { _private: res }
      }

      #[inline(always)]
      fn send_raw(
	  ca: &ContractAddress,
	  receive_name: ReceiveName,
	  amount: Amount,
	  parameter: &[u8],
      ) -> Self {
	  let receive_bytes = receive_name.get_chain_name().as_bytes();
	  let res = 
	      send_hacspec(
		  ca.index,
		  ca.subindex,
		  coerce_rust_to_hacspec_public_byte_seq(&receive_bytes),
		  amount.micro_gtu,
		  coerce_rust_to_hacspec_public_byte_seq(&parameter),
	      );
	  Action { _private: res }
      }

      #[inline(always)]
      fn and_then(self, then: Self) -> Self {
	  let res = combine_and_hacspec(self._private, then._private);
	  Action { _private: res }
      }

      #[inline(always)]
      fn or_else(self, el: Self) -> Self {
	  let res = combine_or_hacspec(self._private, el._private);
	  Action { _private: res }
      }
  }

#+end_src

*** Remaining todo
# TODO: Get functionlity of everything into hacspec
#+begin_src rust :eval never
  // TODO: Define functionality in hacspec instead!
  #[cfg(not(feature = "hacspec"))]
  /// Allocates a Vec of bytes prepended with its length as a `u32` into memory,
  /// and prevents them from being dropped. Returns the pointer.
  /// Used to pass bytes from a Wasm module to its host.
  #[doc(hidden)]
  pub fn put_in_memory(input: &[u8]) -> *mut u8 {
      let bytes_length = input.len() as u32;
      let mut bytes = concordium_contracts_common::to_bytes(&bytes_length);
      bytes.extend_from_slice(input);
      let ptr = bytes.as_mut_ptr();
      #[cfg(feature = "std")]
      ::std::mem::forget(bytes);
      #[cfg(not(feature = "std"))]
      core::mem::forget(bytes);
      ptr
  }

#+end_src

#+begin_src rust :eval never
  // TODO: Name collision
  // #[cfg(not(feature = "hacspec"))]
  // /// Wrapper for
  // /// [HasActions::send_raw](./trait.HasActions.html#tymethod.send_raw), which
  // /// automatically serializes the parameter. Note that if the parameter is
  // /// already a byte array or convertible to a byte array without allocations it
  // /// is preferrable to use [send_raw](./trait.HasActions.html#tymethod.send_raw).
  // /// It is more efficient and avoids memory allocations.
  // pub fn send<A: HasActions, P: Serial>(
  //     ca: &ContractAddress,
  //     receive_name: ReceiveName,
  //     amount: Amount,
  //     parameter: &P,
  // ) -> A {
  //     let param_bytes = concordium_contracts_common::to_bytes(parameter);
  //     A::send_raw(ca, receive_name, amount, &param_bytes)
  // }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl<A, E> UnwrapAbort for Result<A, E> {
      type Unwrap = A;

      #[inline]
      fn unwrap_abort(self) -> Self::Unwrap {
	  match self {
	      Ok(x) => x,
	      Err(_) => trap(),
	  }
      }
  }
  
#+end_src

# TODO:
#+begin_src rust :eval never
  // TODO:
  // #[cfg(not(feature = "hacspec"))]
  // #[cfg(not(feature = "std"))]
  // use concordium_contracts_common::fmt; // core::fmt;

  // #[cfg(not(feature = "hacspec"))]
  // #[cfg(feature = "std")]
  // use std::fmt;

  // #[cfg(not(feature = "hacspec"))]
  // impl<A, E: fmt::Debug> ExpectReport for Result<A, E> {
  //     type Unwrap = A;

  //     fn expect_report(self, msg: &str) -> Self::Unwrap {
  // 	match self {
  // 	    Ok(x) => x,
  // 	    Err(e) => fail!("{}: {:?}", msg, e),
  // 	}
  //     }
  // }

#+end_src

# TODO:
#+begin_src rust :eval never
  // TODO:
  // #[cfg(not(feature = "hacspec"))]
  // impl<A: fmt::Debug, E> ExpectErrReport for Result<A, E> {
  //     type Unwrap = E;

  //     fn expect_err_report(self, msg: &str) -> Self::Unwrap {
  // 	match self {
  // 	    Ok(a) => fail!("{}: {:?}", msg, a),
  // 	    Err(e) => e,
  // 	}
  //     }
  // }

#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl<A> UnwrapAbort for Option<A> {
      type Unwrap = A;

      #[inline(always)]
      fn unwrap_abort(self) -> Self::Unwrap {
	  self.unwrap_or_else(|| trap())
      }
  }

#+end_src

# TODO:
#+begin_src rust :eval never
  // TODO:
  // #[cfg(not(feature = "hacspec"))]
  // impl<A> ExpectReport for Option<A> {
  //     type Unwrap = A;

  //     fn expect_report(self, msg: &str) -> Self::Unwrap {
  // 	match self {
  // 	    Some(v) => v,
  // 	    None => fail!("{}", msg),
  // 	}
  //     }
  // }

#+end_src

# TODO:
#+begin_src rust :eval never
  // TODO:
  // #[cfg(not(feature = "hacspec"))]
  // impl<A: fmt::Debug> ExpectNoneReport for Option<A> {
  //     fn expect_none_report(self, msg: &str) {
  // 	if let Some(x) = self {
  // 	    fail!("{}: {:?}", msg, x)
  // 	}
  //     }
  // }

#+end_src

#+begin_src rust :eval never

  #[cfg(not(feature = "hacspec"))]
  /// Write a [BTreeSet](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) as an ascending list of keys, without the length information.
  pub fn serial_set_no_length<W: Write, K: Serial>(
      map: &BTreeSet<K>,
      out: &mut W,
  ) -> Result<(), W::Err> {
      for k in map.iter() {
	  k.serial(out)?;
      }
      Ok(())
  }

  #[cfg(not(feature = "hacspec"))]
  impl<K: Serial + Ord> SerialCtx for BTreeSet<K> {
      fn serial_ctx<W: Write>(
	  &self,
	  size_len: concordium_contracts_common::schema::SizeLength,
	  out: &mut W,
      ) -> Result<(), W::Err> {
	  concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
	  // concordium_std::
	  serial_set_no_length(self, out)
      }
  }

#+end_src

#+begin_src rust :eval never

  #[cfg(not(feature = "hacspec"))]
  /// Read a [BTreeSet](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) as a list of keys, given some length.
  /// NB: This ensures there are no duplicates, hence the specialized type.
  /// Moreover this will only succeed if keys are listed in order.
  pub fn deserial_set_no_length<R: Read, K: Deserial + Ord + Copy>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<BTreeSet<K>> {
      let mut out = BTreeSet::new();
      let mut prev = None;
      for _ in 0..len {
	  let key = source.get()?;
	  let next = Some(key);
	  if next <= prev {
	      return Err(ParseError::default());
	  }
	  out.insert(key);
	  prev = next;
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]
  /// Read a [BTreeSet](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) as an list of key-value pairs given some length.
  /// Slightly faster version of `deserial_set_no_length` as it is skipping the
  /// order checking. The only check that is made to the set is that there are no
  /// duplicates.
  pub fn deserial_set_no_length_no_order_check<R: Read, K: Deserial + Ord>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<BTreeSet<K>> {
      let mut out = BTreeSet::new();
      for _ in 0..len {
	  let key = source.get()?;
	  if !out.insert(key) {
	      return Err(ParseError::default());
	  }
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]
  impl<K: Deserial + Ord + Copy> DeserialCtx for BTreeSet<K> {
      fn deserial_ctx<R: Read>(
	  size_len: concordium_contracts_common::schema::SizeLength,
	  ensure_ordered: bool,
	  source: &mut R,
      ) -> ParseResult<Self> {
	  let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
	  if ensure_ordered {
	      // concordium_std::
	      deserial_set_no_length(source, len)
	  } else {
	      // concordium_std::
	      deserial_set_no_length_no_order_check(source, len)
	  }
      }
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Write a Map as a list of key-value pairs ordered by the key, without the
  /// length information.
  pub fn serial_map_no_length<W: Write, K: Serial, V: Serial>(
      map: &BTreeMap<K, V>,
      out: &mut W,
  ) -> Result<(), W::Err> {
      for (k, v) in map.iter() {
	  k.serial(out)?;
	  v.serial(out)?;
      }
      Ok(())
  }

  #[cfg(not(feature = "hacspec"))]
  impl<K: Serial + Ord, V: Serial> SerialCtx for BTreeMap<K, V> {
      fn serial_ctx<W: Write>(
	  &self,
	  size_len: concordium_contracts_common::schema::SizeLength,
	  out: &mut W,
      ) -> Result<(), W::Err> {
	  concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
	  // concordium_std::
	  serial_map_no_length(self, out)
      }
  }
  
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Read a [BTreeMap](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) as a list of key-value pairs given some length.
  /// NB: This ensures there are no duplicates, hence the specialized type.
  /// Moreover this will only succeed if keys are listed in order.
  pub fn deserial_map_no_length<R: Read, K: Deserial + Ord + Copy, V: Deserial>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<BTreeMap<K, V>> {
      let mut out = BTreeMap::new();
      let mut x = None;
      for _ in 0..len {
	  let k = source.get()?;
	  let v = source.get()?;
	  match x {
	      None => {
		  out.insert(k, v);
	      }
	      Some(kk) => {
		  if k > kk {
		      out.insert(k, v);
		  } else {
		      return Err(ParseError::default());
		  }
	      }
	  }
	  x = Some(k);
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]  
  /// Read a [BTreeMap](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) as a list of key-value pairs given some length.
  /// Slightly faster version of `deserial_map_no_length` as it is skipping the
  /// order checking
  pub fn deserial_map_no_length_no_order_check<R: Read, K: Deserial + Ord, V: Deserial>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<BTreeMap<K, V>> {
      let mut out = BTreeMap::new();
      for _ in 0..len {
	  let k = source.get()?;
	  let v = source.get()?;
	  if out.insert(k, v).is_some() {
	      return Err(ParseError::default());
	  }
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]  
  impl<K: Deserial + Ord + Copy, V: Deserial> DeserialCtx for BTreeMap<K, V> {
      fn deserial_ctx<R: Read>(
	  size_len: concordium_contracts_common::schema::SizeLength,
	  ensure_ordered: bool,
	  source: &mut R,
      ) -> ParseResult<Self> {
	  let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
	  if ensure_ordered {
	      // concordium_std::
	      deserial_map_no_length(source, len)
	  } else {
	      // concordium_std::
	      deserial_map_no_length_no_order_check(source, len)
	  }
      }
  }
  
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Write a [HashSet](https://doc.rust-lang.org/std/collections/struct.HashSet.html) as a list of keys in no particular order, without the length information.
  pub fn serial_hashset_no_length<W: Write, K: Serial>(
      map: &HashSet<K>,
      out: &mut W,
  ) -> Result<(), W::Err> {
      for k in map.iter() {
	  k.serial(out)?;
      }
      Ok(())
  }

  #[cfg(not(feature = "hacspec"))]
  /// Serialization for HashSet given a size_len.
  /// Values are not serialized in any particular order.
  impl<K: Serial> SerialCtx for HashSet<K> {
      fn serial_ctx<W: Write>(
	  &self,
	  size_len: concordium_contracts_common::schema::SizeLength,
	  out: &mut W,
      ) -> Result<(), W::Err> {
	  concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
	  // concordium_std::
	  serial_hashset_no_length(self, out)
      }
  }

#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Read a [HashSet](https://doc.rust-lang.org/std/collections/struct.HashSet.html) as a list of keys, given some length.
  /// NB: This ensures there are no duplicates.
  pub fn deserial_hashset_no_length<R: Read, K: Deserial + Eq + Hash>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<HashSet<K>> {
      let mut out = HashSet::default();
      for _ in 0..len {
	  let key = source.get()?;
	  if !out.insert(key) {
	      return Err(ParseError::default());
	  }
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]  
  /// Deserialization for HashSet given a size_len.
  /// Values are not verified to be in any particular order and setting
  /// ensure_ordering have no effect.
  impl<K: Deserial + Eq + Hash> DeserialCtx for HashSet<K> {
      fn deserial_ctx<R: Read>(
	  size_len: concordium_contracts_common::schema::SizeLength,
	  _ensure_ordered: bool,
	  source: &mut R,
      ) -> ParseResult<Self> {
	  let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
	  deserial_hashset_no_length(source, len)
      }
  }

#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]  
  /// Write a HashMap as a list of key-value pairs in to particular order, without
  /// the length information.
  pub fn serial_hashmap_no_length<W: Write, K: Serial, V: Serial>(
      map: &HashMap<K, V>,
      out: &mut W,
  ) -> Result<(), W::Err> {
      for (k, v) in map.iter() {
	  k.serial(out)?;
	  v.serial(out)?;
      }
      Ok(())
  }

  #[cfg(not(feature = "hacspec"))]  
  /// Serialization for HashMap given a size_len.
  /// Keys are not serialized in any particular order.
  impl<K: Serial, V: Serial> SerialCtx for HashMap<K, V> {
      fn serial_ctx<W: Write>(
	  &self,
	  size_len: concordium_contracts_common::schema::SizeLength,
	  out: &mut W,
      ) -> Result<(), W::Err> {
	  concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
	  serial_hashmap_no_length(self, out)
      }
  }
  
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Read a [HashMap](https://doc.rust-lang.org/std/collections/struct.HashMap.html) as a list of key-value pairs given some length.
  pub fn deserial_hashmap_no_length<R: Read, K: Deserial + Eq + Hash, V: Deserial>(
      source: &mut R,
      len: usize,
  ) -> ParseResult<HashMap<K, V>> {
      let mut out = HashMap::default();
      for _ in 0..len {
	  let k = source.get()?;
	  let v = source.get()?;
	  if out.insert(k, v).is_some() {
	      return Err(ParseError::default());
	  }
      }
      Ok(out)
  }

  #[cfg(not(feature = "hacspec"))]
  /// Deserialization for HashMap given a size_len.
  /// Keys are not verified to be in any particular order and setting
  /// ensure_ordering have no effect.
  impl<K: Deserial + Eq + Hash, V: Deserial> DeserialCtx for HashMap<K, V> {
      fn deserial_ctx<R: Read>(
	  size_len: concordium_contracts_common::schema::SizeLength,
	  _ensure_ordered: bool,
	  source: &mut R,
      ) -> ParseResult<Self> {
	  let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
	  // concordium_std::
	  deserial_hashmap_no_length(source, len)
      }
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  /// Write a slice of elements, without including length information.
  /// This is intended to be used either when the length is statically known,
  /// or when the length is serialized independently as part of a bigger
  /// structure.
  pub fn serial_vector_no_length<W: Write, T: Serial>(xs: &[T], out: &mut W) -> Result<(), W::Err> {
      for x in xs {
	  x.serial(out)?;
      }
      Ok(())
  }

  #[cfg(not(feature = "hacspec"))]
  impl<T: Serial> SerialCtx for &[T] {
      fn serial_ctx<W: Write>(
	  &self,
	  size_len: concordium_contracts_common::schema::SizeLength,
	  out: &mut W,
      ) -> Result<(), W::Err> {
	  concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
	  serial_vector_no_length(self, out)
      }
  }
  
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  pub(crate) static MAX_PREALLOCATED_CAPACITY: usize = 4096;

  #[cfg(not(feature = "hacspec"))]
  /// Read a vector given a length.
  pub fn deserial_vector_no_length<R: Read, T: Deserial>(
      reader: &mut R,
      len: usize,
  ) -> ParseResult<Vec<T>> {
      let mut vec = Vec::with_capacity(core::cmp::min(len, MAX_PREALLOCATED_CAPACITY));
      for _ in 0..len {
	  vec.push(T::deserial(reader)?);
      }
      Ok(vec)
  }

  #[cfg(not(feature = "hacspec"))]
  impl<T: Deserial> DeserialCtx for Vec<T> {
      fn deserial_ctx<R: Read>(
	  size_len: concordium_contracts_common::schema::SizeLength,
	  _ensure_ordered: bool,
	  source: &mut R,
      ) -> ParseResult<Self> {
	  let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
	  deserial_vector_no_length(source, len)
      }
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl SerialCtx for &str {
      fn serial_ctx<W: Write>(
	  &self,
	  size_len: concordium_contracts_common::schema::SizeLength,
	  out: &mut W,
      ) -> Result<(), W::Err> {
	  concordium_contracts_common::schema::serial_length(self.len(), size_len, out)?;
	  serial_vector_no_length(&self.as_bytes().to_vec(), out)
      }
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]
  impl SerialCtx for String {
      fn serial_ctx<W: Write>(
	  &self,
	  size_len: concordium_contracts_common::schema::SizeLength,
	  out: &mut W,
      ) -> Result<(), W::Err> {
	  self.as_str().serial_ctx(size_len, out)
      }
  }
#+end_src

#+begin_src rust :eval never
  #[cfg(not(feature = "hacspec"))]  
  impl DeserialCtx for String {
      fn deserial_ctx<R: Read>(
	  size_len: concordium_contracts_common::schema::SizeLength,
	  _ensure_ordered: bool,
	  source: &mut R,
      ) -> ParseResult<Self> {
	  let len = concordium_contracts_common::schema::deserial_length(source, size_len)?;
	  let bytes = deserial_vector_no_length(source, len)?;
	  let res = String::from_utf8(bytes).map_err(|_| ParseError::default())?;
	  Ok(res)
      }
  }
#+end_src

*** Rust Tests
#+begin_src rust :eval never

#+end_src

** Resulting output
#+begin_src sh :eval no-export-query :results output silent
  cargo clean
#+end_src

#+begin_src sh :eval no-export-query :results output silent
  cd ../.. && cargo install --path language
#+end_src

#+begin_src sh :eval no-export-query :results output silent
  cd ../.. && cargo build
#+end_src

# :eval never
#+begin_src sh :results output silent
  cd ../../language target/debug/cargo-hacspec -o ../coq/src/Concordium_Impls.v -f ../examples/concordium/src/hacspec_concordium_impls.rs --init
#+end_src

#+begin_src sh :results output silent
  cd ../../language target/debug/cargo-hacspec -o ../coq/src/Concordium_Impls.v -f ../examples/concordium/src/hacspec_concordium_impls.rs --update
#+end_src

** Generation of backend output

#+NAME: seginit
#+begin_src python :wrap "src coq :results output silent" :result code :exports none :var loc=(file-name-directory buffer-file-name)
  with open("../_CoqProject") as f:
      result = ""
      for l in f:
	  if l[:2] == "-R":
	      pre, post = l[3:].split()
	      result += "Add Rec LoadPath \"" + pre + "\" as " + post + ".\n"
	  # elif l[:4] == "src/":
	  #     result += "Load " + l[4:-2] + "\n"
      return "Reset Initial.\nCd \""+loc+"../\".\n" + result
#+end_src
#+RESULTS: seginit
#+begin_src coq :results output silent
Reset Initial.
Cd "/home/au538501/Documents/LocalHacspec/hacspec/coq/src/../".
Add Rec LoadPath "src/" as Hacspec.
#+end_src

*** The includes
#+NAME: linum0
#+CALL: next(ARG="0 9", linum="0 0") :exports none
#+NAME: seg0
#+CALL: split-file(ARG=linum0) :eval
#+RESULTS: seg0
#+begin_src coq :tangle Concordium_Impls.v :results output silent
(** This file was automatically generated using Hacspec **)
Require Import Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.
Require Import Hacspec.Lib.

#+end_src

*** Types and default implementations
#+NAME: linum1
#+CALL: next(ARG="0 2", linum=linum0) :exports none
#+NAME: seg1
#+CALL: split-file(ARG=linum1) :eval
#+RESULTS: seg1
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Notation "'reject_hacspec_t'" := (int32) : hacspec_scope.

#+end_src

#+NAME: linum2
#+CALL: next(ARG="0 2", linum=linum1) :exports none
#+NAME: seg2
#+CALL: split-file(ARG=linum2) :eval
#+RESULTS: seg2
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition reject_impl_deafult  : reject_hacspec_t :=
  min_v.

#+end_src

# removed linum3

#+NAME: linum4
#+CALL: next(ARG="0 2", linum=linum2) :exports none
#+NAME: seg4
#+CALL: split-file(ARG=linum4) :eval
#+RESULTS: seg4
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition new_reject_impl (x_0 : int32) : (option reject_hacspec_t) :=
  (if ((x_0) <.? (@repr WORDSIZE32 0)):bool then (@Some int32 (x_0)) else (
      @None int32)).

#+end_src

*** Error handling
#+NAME: linum5
#+CALL: next(ARG="0 5", linum=linum4) :exports none
#+NAME: seg5
#+CALL: split-file(ARG=linum5) :eval
#+RESULTS: seg5
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition reject_impl_convert_from_unit  : reject_hacspec_t :=
  (min_v) .+ (@repr WORDSIZE32 1).

Theorem ensures_reject_impl_convert_from_unit : forall result_1 ,
@reject_impl_convert_from_unit  = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  reflexivity.
Qed.

#+end_src

#+NAME: linum6
#+CALL: next(ARG="0 5", linum=linum5) :exports none
#+NAME: seg6
#+CALL: split-file(ARG=linum6) :eval
#+RESULTS: seg6
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition reject_impl_convert_from_parse_error  : reject_hacspec_t :=
  (min_v) .+ (@repr WORDSIZE32 2).

Theorem ensures_reject_impl_convert_from_parse_error : forall result_1 ,
@reject_impl_convert_from_parse_error  = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  reflexivity.
Qed.

#+end_src

#+NAME: linum7
#+CALL: next(ARG="0 7", linum=linum6) :exports none
#+NAME: seg7
#+CALL: split-file(ARG=linum7) :eval
#+RESULTS: seg7
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Inductive log_error_t :=
| Full : log_error_t
| Malformed : log_error_t.

Definition reject_impl_from_log_error (le_2 : log_error_t) : reject_hacspec_t :=
  match le_2 with
  | Full => (min_v) .+ (@repr WORDSIZE32 3)
  | Malformed => (min_v) .+ (@repr WORDSIZE32 4)
  end.

Theorem ensures_reject_impl_from_log_error : forall result_1 (
  le_2 : log_error_t),
@reject_impl_from_log_error le_2 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  destruct le_2 ; reflexivity.
Qed.

#+end_src

#+NAME: linum8
#+CALL: next(ARG="0 7", linum=linum7) :exports none
#+NAME: seg8
#+CALL: split-file(ARG=linum8) :eval
#+RESULTS: seg8
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Inductive new_contract_name_error_t :=
| NewContractNameErrorMissingInitPrefix : new_contract_name_error_t
| NewContractNameErrorTooLong : new_contract_name_error_t
| NewContractNameErrorContainsDot : new_contract_name_error_t
| NewContractNameErrorInvalidCharacters : new_contract_name_error_t.

Definition reject_impl_from_new_contract_name_error
  (nre_3 : new_contract_name_error_t)
  : reject_hacspec_t :=
  match nre_3 with
  | NewContractNameErrorMissingInitPrefix => (min_v) .+ (@repr WORDSIZE32 5)
  | NewContractNameErrorTooLong => (min_v) .+ (@repr WORDSIZE32 6)
  | NewContractNameErrorContainsDot => (min_v) .+ (@repr WORDSIZE32 9)
  | NewContractNameErrorInvalidCharacters => (min_v) .+ (@repr WORDSIZE32 10)
  end.

Theorem ensures_reject_impl_from_new_contract_name_error : forall result_1 (
  nre_3 : new_contract_name_error_t),
@reject_impl_from_new_contract_name_error nre_3 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  destruct nre_3 ; reflexivity.
Qed.

#+end_src

#+NAME: linum9
#+CALL: next(ARG="0 7", linum=linum8) :exports none
#+NAME: seg9
#+CALL: split-file(ARG=linum9) :eval
#+RESULTS: seg9
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Inductive new_receive_name_error_t :=
| NewReceiveNameErrorMissingDotSeparator : new_receive_name_error_t
| NewReceiveNameErrorTooLong : new_receive_name_error_t
| NewReceiveNameErrorInvalidCharacters : new_receive_name_error_t.

Definition reject_impl_from_new_receive_name_error
  (nre_4 : new_receive_name_error_t)
  : reject_hacspec_t :=
  match nre_4 with
  | NewReceiveNameErrorMissingDotSeparator => (min_v) .+ (@repr WORDSIZE32 7)
  | NewReceiveNameErrorTooLong => (min_v) .+ (@repr WORDSIZE32 8)
  | NewReceiveNameErrorInvalidCharacters => (min_v) .+ (@repr WORDSIZE32 11)
  end.

Theorem ensures_reject_impl_from_new_receive_name_error : forall result_1 (
  nre_4 : new_receive_name_error_t),
@reject_impl_from_new_receive_name_error nre_4 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  destruct nre_4 ; reflexivity.
Qed.

#+end_src

*** Contract state
#+NAME: linum10
#+CALL: next(ARG="0 2", linum=linum9) :exports none
#+NAME: seg10
#+CALL: split-file(ARG=linum10) :eval
#+RESULTS: seg10
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Notation "'contract_state_hacspec_t'" := (int32) : hacspec_scope.

#+end_src

#+NAME: linum11
#+CALL: next(ARG="0 2", linum=linum10) :exports none
#+NAME: seg11
#+CALL: split-file(ARG=linum11) :eval
#+RESULTS: seg11
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Inductive seek_from_t :=
| Start : int64 -> seek_from_t
| End : int64 -> seek_from_t
| Current : int64 -> seek_from_t.

#+end_src

#+NAME: linum12
#+CALL: next(ARG="0 4", linum=linum11) :exports none
#+NAME: seg12
#+CALL: split-file(ARG=linum12) :eval
#+RESULTS: seg12
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Notation "'uint32_option_t'" := ((option int32)) : hacspec_scope.

Notation "'iint64_option_t'" := ((option int64)) : hacspec_scope.

#+end_src

#+NAME: linum13
#+CALL: next(ARG="0 2", linum=linum12) :exports none
#+NAME: seg13
#+CALL: split-file(ARG=linum13) :eval
#+RESULTS: seg13
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition contract_state_impl_seek
  (current_position_5 : contract_state_hacspec_t)
  (pos_6 : seek_from_t)
  : (result (contract_state_hacspec_t × int64) unit) :=
  match pos_6 with
  | Start offset_7 => @Ok (contract_state_hacspec_t × int64) unit ((
      @cast _ uint32 _ (offset_7),
      offset_7
    ))
  | End delta_8 => (if ((delta_8) >=.? (@repr WORDSIZE64 0)):bool then (
      match pub_uint32_checked_add (current_position_5) (@cast _ uint32 _ (
          delta_8)) with
      | Some b_9 => @Ok (contract_state_hacspec_t × int64) unit ((
          b_9,
          @cast _ uint64 _ (delta_8)
        ))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end) else (match pub_int64_checked_abs (delta_8) with
      | Some b_10 => @Ok (contract_state_hacspec_t × int64) unit ((
          (@repr WORDSIZE32 4) .- (@cast _ uint32 _ (b_10)),
          @cast _ uint64 _ ((@repr WORDSIZE32 4) .- (@cast _ uint32 _ (b_10)))
        ))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end))
  | Current delta_11 => (if ((delta_11) >=.? (@repr WORDSIZE64 0)):bool then (
      match pub_uint32_checked_add (current_position_5) (@cast _ uint32 _ (
          delta_11)) with
      | Some offset_12 => @Ok (contract_state_hacspec_t × int64) unit ((
          offset_12,
          @cast _ uint64 _ (offset_12)
        ))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end) else (match pub_int64_checked_abs (delta_11) with
      | Some b_13 => match pub_uint32_checked_sub (current_position_5) (
        @cast _ uint32 _ (b_13)) with
      | Some offset_14 => @Ok (contract_state_hacspec_t × int64) unit ((
          offset_14,
          @cast _ uint64 _ (offset_14)
        ))
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end
      | None => @Err (contract_state_hacspec_t × int64) unit (tt)
      end))
  end.

#+end_src

**** Contract state - Read Trait
#+NAME: linum14
#+CALL: next(ARG="0 2", linum=linum13) :exports none
#+NAME: seg14
#+CALL: split-file(ARG=linum14) :eval
#+RESULTS: seg14
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition load_state_hacspec
  (buf_15 : public_byte_seq)
  (offset_16 : int32)
  : (public_byte_seq × int32) :=
  (buf_15, @repr WORDSIZE32 1).

#+end_src

#+NAME: linum15
#+CALL: next(ARG="0 8", linum=linum14) :exports none
#+NAME: seg15
#+CALL: split-file(ARG=linum15) :eval
#+RESULTS: seg15
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition contract_state_impl_read_read
  (current_position_17 : contract_state_hacspec_t)
  (buf_18 : public_byte_seq)
  : (contract_state_hacspec_t × uint_size) :=
  let '(buf_19, num_read_20) :=
    load_state_hacspec (buf_18) (current_position_17) in 
  ((current_position_17) .+ (num_read_20), @cast _ uint32 _ (num_read_20)).

Definition contract_state_impl_read_read_u64
  (current_position_21 : contract_state_hacspec_t)
  : (contract_state_hacspec_t × int64) :=
  let buf_22 : seq int8 :=
    seq_new_ (default) (usize 8) in 
  let '(buf_23, num_read_24) :=
    load_state_hacspec (buf_22) (current_position_21) in 
  (
    (current_position_21) .+ (num_read_24),
    u64_from_le_bytes (array_from_seq (8) (buf_23))
  ).

Definition contract_state_impl_read_read_u32
  (current_position_25 : contract_state_hacspec_t)
  : (contract_state_hacspec_t × int32) :=
  let buf_26 : seq int8 :=
    seq_new_ (default) (usize 4) in 
  let '(buf_27, num_read_28) :=
    load_state_hacspec (buf_26) (current_position_25) in 
  (
    (current_position_25) .+ (num_read_28),
    u32_from_le_bytes (array_from_seq (4) (buf_27))
  ).

Definition contract_state_impl_read_read_u8
  (current_position_29 : contract_state_hacspec_t)
  : (contract_state_hacspec_t × int8) :=
  let buf_30 : seq int8 :=
    seq_new_ (default) (usize 1) in 
  let '(buf_31, num_read_32) :=
    load_state_hacspec (buf_30) (current_position_29) in 
  ((current_position_29) .+ (num_read_32), seq_index (buf_31) (usize 0)).

#+end_src

**** Contract state - Write Trait
#+NAME: linum16
#+CALL: next(ARG="0 2", linum=linum15) :exports none
#+NAME: seg16
#+CALL: split-file(ARG=linum16) :eval
#+RESULTS: seg16
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition write_state_hacspec
  (buf_33 : public_byte_seq)
  (offset_34 : int32)
  : (public_byte_seq × int32) :=
  (buf_33, @repr WORDSIZE32 1).

#+end_src

#+NAME: linum16half
#+CALL: next(ARG="0 6", linum=linum16) :exports none
#+NAME: seg16half
#+CALL: split-file(ARG=linum16half) :eval
#+RESULTS: seg16half
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition contract_state_impl_write
  (current_position_35 : contract_state_hacspec_t)
  (buf_36 : public_byte_seq)
  : (result (contract_state_hacspec_t × uint_size) unit) :=
  ifbnd option_is_none (pub_uint32_checked_add (current_position_35) (pub_u32 (
        seq_len (buf_36)))) : bool
  thenbnd (bind (@Err (contract_state_hacspec_t × uint_size) unit (tt)) (
      fun _ => Ok (tt)))
  else (tt) >> (fun 'tt =>
  let '(buf_37, num_bytes_38) :=
    write_state_hacspec (buf_36) (current_position_35) in 
  @Ok (contract_state_hacspec_t × uint_size) unit ((
      (current_position_35) .+ (num_bytes_38),
      @cast _ uint32 _ (num_bytes_38)
    ))).

Definition state_size_hacspec  : int32 :=
  @repr WORDSIZE32 1.

Definition resize_state_hacspec (new_size_39 : int32) : int32 :=
  @repr WORDSIZE32 1.

#+end_src


**** Contract State - Misc.
#+NAME: linum17
#+CALL: next(ARG="0 8", linum="68 6") :exports none
#+NAME: seg17
#+CALL: split-file(ARG=linum17) :eval
#+RESULTS: seg17
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition has_contract_state_impl_for_contract_state_open
  
  : contract_state_hacspec_t :=
  @repr WORDSIZE32 0.

Definition has_contract_state_impl_for_contract_state_reserve
  (contract_state_40 : contract_state_hacspec_t)
  (len_41 : int32)
  : bool :=
  let cur_size_42 : int32 :=
    state_size_hacspec  in 
  (if ((cur_size_42) <.? (len_41)):bool then ((resize_state_hacspec (
          len_41)) =.? (@repr WORDSIZE32 1)) else (true)).

Definition has_contract_state_impl_for_contract_state_truncate
  (current_position_43 : contract_state_hacspec_t)
  (cur_size_44 : int32)
  (new_size_45 : int32)
  : contract_state_hacspec_t :=
  let 'tt :=
    if (cur_size_44) >.? (new_size_45):bool then (let _ : int32 :=
        resize_state_hacspec (new_size_45) in 
      tt) else (tt) in 
  (if ((new_size_45) <.? (current_position_43)):bool then (new_size_45) else (
      current_position_43)).

Definition get_parameter_section_hacspec
  (buf_46 : public_byte_seq)
  (offset_47 : int32)
  : (public_byte_seq × int32) :=
  (buf_46, @repr WORDSIZE32 1).

#+end_src

*** Parameter
#+NAME: linum18
#+CALL: next(ARG="0 10", linum=linum17) :exports none
#+NAME: seg18
#+CALL: split-file(ARG=linum18) :eval
#+RESULTS: seg18
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Notation "'parameter_hacspec_t'" := (int32) : hacspec_scope.

Definition read_impl_for_parameter_read
  (current_position_48 : parameter_hacspec_t)
  (buf_49 : public_byte_seq)
  : (parameter_hacspec_t × uint_size) :=
  let '(buf_50, num_read_51) :=
    get_parameter_section_hacspec (buf_49) (current_position_48) in 
  ((current_position_48) .+ (num_read_51), @cast _ uint32 _ (num_read_51)).

Definition get_parameter_size_hacspec  : int32 :=
  @repr WORDSIZE32 1.

Definition get_slot_time_hacspec  : int64 :=
  @repr WORDSIZE64 1.

Definition get_policy_section_hacspec
  (policy_bytes_52 : public_byte_seq)
  (offset_53 : int32)
  : (public_byte_seq × int32) :=
  (policy_bytes_52, @repr WORDSIZE32 1).

#+end_src

*** Attributes Cursor
#+NAME: linum19
#+CALL: next(ARG="0 4", linum=linum18) :exports none
#+NAME: seg19
#+CALL: split-file(ARG=linum19) :eval
#+RESULTS: seg19
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Notation "'attributes_cursor_hacspec_t'" := ((int32 × int16)) : hacspec_scope.

Definition has_policy_impl_for_policy_attributes_cursor_next_item
  (policy_attribute_items_54 : attributes_cursor_hacspec_t)
  (buf_55 : public_byte_seq)
  : (option (attributes_cursor_hacspec_t × (int8 × int8))) :=
  let '(current_position_56, remaining_items_57) :=
    policy_attribute_items_54 in 
  ifbnd (remaining_items_57) =.? (@repr WORDSIZE16 0) : bool
  thenbnd (bind (@None (attributes_cursor_hacspec_t × (int8 × int8))) (
      fun _ => Some (tt)))
  else (tt) >> (fun 'tt =>
  let '(tag_value_len_58, num_read_59) :=
    get_policy_section_hacspec (seq_new_ (default) (usize 2)) (
      current_position_56) in 
  let current_position_56 :=
    (current_position_56) .+ (num_read_59) in 
  ifbnd (seq_index (tag_value_len_58) (usize 1)) >.? (@repr WORDSIZE8 31) : bool
  thenbnd (bind (@None (attributes_cursor_hacspec_t × (int8 × int8))) (
      fun _ => Some (tt)))
  else (tt) >> (fun 'tt =>
  let '(buf_60, num_read_61) :=
    get_policy_section_hacspec (buf_55) (current_position_56) in 
  let current_position_56 :=
    (current_position_56) .+ (num_read_61) in 
  let remaining_items_57 :=
    (remaining_items_57) .- (@repr WORDSIZE16 1) in 
  @Some (attributes_cursor_hacspec_t × (int8 × int8)) ((
      (current_position_56, remaining_items_57),
      (
        seq_index (tag_value_len_58) (usize 0),
        seq_index (tag_value_len_58) (usize 1)
      )
    )))).

#+end_src

*** Policies iterator
#+NAME: linum20
#+CALL: next(ARG="0 6", linum=linum19) :exports none
#+NAME: seg20
#+CALL: split-file(ARG=linum20) :eval
#+RESULTS: seg20
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Notation "'policies_iterator_hacspec_t'" := ((int32 × int16)) : hacspec_scope.

Notation "'policy_attributes_cursor_hacspec_t'" := ((
  int32 ×
  int64 ×
  int64 ×
  attributes_cursor_hacspec_t
)) : hacspec_scope.

Definition iterator_impl_for_policies_iterator_next
  (policies_iterator_62 : policies_iterator_hacspec_t)
  : (option (policies_iterator_hacspec_t × policy_attributes_cursor_hacspec_t
    )) :=
  let '(pos_63, remaining_items_64) :=
    policies_iterator_62 in 
  ifbnd (remaining_items_64) =.? (@repr WORDSIZE16 0) : bool
  thenbnd (bind (@None (
        policies_iterator_hacspec_t ×
        policy_attributes_cursor_hacspec_t
      )) (fun _ => Some (tt)))
  else (tt) >> (fun 'tt =>
  let '(buf_65, _) :=
    get_policy_section_hacspec (seq_new_ (default) (((((usize 2) + (
                usize 4)) + (usize 8)) + (usize 8)) + (usize 2))) (pos_63) in 
  let skip_part_66 : public_byte_seq :=
    seq_slice_range (buf_65) ((usize 0, usize 2)) in 
  let ip_part_67 : public_byte_seq :=
    seq_slice_range (buf_65) ((usize 2, (usize 2) + (usize 4))) in 
  let created_at_part_68 : public_byte_seq :=
    seq_slice_range (buf_65) ((
        (usize 2) + (usize 4),
        ((usize 2) + (usize 4)) + (usize 8)
      )) in 
  let valid_to_part_69 : public_byte_seq :=
    seq_slice_range (buf_65) ((
        ((usize 2) + (usize 4)) + (usize 8),
        (((usize 2) + (usize 4)) + (usize 8)) + (usize 8)
      )) in 
  let len_part_70 : public_byte_seq :=
    seq_slice_range (buf_65) ((
        (((usize 2) + (usize 4)) + (usize 8)) + (usize 8),
        ((((usize 2) + (usize 4)) + (usize 8)) + (usize 8)) + (usize 2)
      )) in 
  let identity_provider_71 : int32 :=
    u32_from_le_bytes (array_from_seq (4) (ip_part_67)) in 
  let created_at_72 : int64 :=
    u64_from_le_bytes (array_from_seq (8) (created_at_part_68)) in 
  let valid_to_73 : int64 :=
    u64_from_le_bytes (array_from_seq (8) (valid_to_part_69)) in 
  let remaining_items_74 : int16 :=
    u16_from_le_bytes (array_from_seq (2) (len_part_70)) in 
  let attributes_start_75 : int32 :=
    (((((pos_63) .+ (@repr WORDSIZE32 2)) .+ (@repr WORDSIZE32 4)) .+ (
          @repr WORDSIZE32 8)) .+ (@repr WORDSIZE32 8)) .+ (
      @repr WORDSIZE32 2) in 
  let pos_63 :=
    ((pos_63) .+ (@cast _ uint32 _ (u16_from_le_bytes (array_from_seq (2) (
              skip_part_66))))) .+ (@repr WORDSIZE32 2) in 
  let remaining_items_74 :=
    (remaining_items_74) .- (@repr WORDSIZE16 1) in 
  @Some (policies_iterator_hacspec_t × policy_attributes_cursor_hacspec_t) ((
      (pos_63, remaining_items_74),
      (
        identity_provider_71,
        created_at_72,
        valid_to_73,
        (attributes_start_75, remaining_items_74)
      )
    ))).

#+end_src

*** External context
#+NAME: linum21
#+CALL: next(ARG="0 12", linum=linum20) :exports none
#+NAME: seg21
#+CALL: split-file(ARG=linum21) :eval
#+RESULTS: seg21
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition get_init_origin_hacspec
  (start_76 : public_byte_seq)
  : public_byte_seq :=
  start_76.

Definition get_receive_invoker_hacspec
  (start_77 : public_byte_seq)
  : public_byte_seq :=
  start_77.

Definition get_receive_self_address_hacspec
  (start_78 : public_byte_seq)
  : public_byte_seq :=
  start_78.

Definition get_receive_self_balance_hacspec  : int64 :=
  @repr WORDSIZE64 1.

Definition get_receive_sender_hacspec
  (start_79 : public_byte_seq)
  : public_byte_seq :=
  start_79.

Definition get_receive_owner_hacspec
  (start_80 : public_byte_seq)
  : public_byte_seq :=
  start_80.

#+end_src

*** Logger
#+NAME: linum22
#+CALL: next(ARG="0 2", linum=linum21) :exports none
#+NAME: seg22
#+CALL: split-file(ARG=linum22) :eval
#+RESULTS: seg22
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition log_event_hacspec
  (start_81 : public_byte_seq)
  : (public_byte_seq × int32) :=
  (start_81, @repr WORDSIZE32 1).

#+end_src

*** Action
#+NAME: linum23
#+CALL: next(ARG="0 -1", linum=linum22) :exports none
#+NAME: seg23
#+CALL: split-file(ARG=linum23) :eval
#+RESULTS: seg23
#+begin_src coq :tangle Concordium_Impls.v :results output silent
Definition accept_hacspec  : int32 :=
  @repr WORDSIZE32 1.

Definition simple_transfer_hacspec
  (buf_82 : public_byte_seq)
  (amount_83 : int64)
  : int32 :=
  @repr WORDSIZE32 1.

Definition send_hacspec
  (addr_index_84 : int64)
  (addr_subindex_85 : int64)
  (receive_name_86 : public_byte_seq)
  (amount_87 : int64)
  (parameter_88 : public_byte_seq)
  : int32 :=
  @repr WORDSIZE32 1.

Definition combine_and_hacspec (l_89 : int32) (r_90 : int32) : int32 :=
  @repr WORDSIZE32 1.

Definition combine_or_hacspec (l_91 : int32) (r_92 : int32) : int32 :=
  @repr WORDSIZE32 1.

#+end_src

