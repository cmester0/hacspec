#+TITLE: Concordium Smartcontract Infrastructure Implementations
#+AUTHOR: Lasse Letager Hansen

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+PROPERTY: header-args:coq  :session *Coq*

# C-c C-v t   -  export this files
# C-c C-v b   -  create results / run this file

* Concordium "Impls" specification
** Config
#+BEGIN_SRC toml :eval never
[package]
name = "concordium_impls"
version = "0.1.0"
authors = [""]
edition = "2018"

[lib]
path = "src/concordium_impls.rs"

[dependencies]
hacspec-lib = { path = "../../lib" }
hacspec-attributes = { path = "../../utils/attributes", version = "0.1.0-beta.1" , features = ["print_attributes", "hacspec_unsafe"] } # , features = ["hacspec_unsafe"] , , optional = true
# pearlite-syn = { path = "../../../../creusot/pearlite-syn" }
creusot-contracts = { path = "../../../../creusot/creusot-contracts" }

[features]
use_attributes = ["hacspec-attributes/print_attributes", "hacspec-attributes/hacspec_unsafe"]

[dev-dependencies]
hacspec-dev = { path = "../../utils/dev" }
criterion = "0.3"
rand = "0.8"
#+END_SRC

** Imports
#+BEGIN_SRC rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern crate hacspec_lib;

  use hacspec_lib::*;

  // #[cfg(feature = "hacspec_attributes")]
  #[cfg(feature = "hacspec")]
  use hacspec_attributes::*;

  #[cfg(not(feature = "hacspec"))]
  extern crate creusot_contracts;
  #[cfg(not(feature = "hacspec"))]
  use creusot_contracts::*;
#+END_SRC

** Rust code
*** Reject
The ~Rust~ definition for Reject is
#+begin_src rust :tangle no :eval never
/// An error message, signalling rejection of a smart contract invocation.
/// The client will see the error code as a reject reason; if a schema is
/// provided, the error message corresponding to the error code will be
/// displayed. The valid range for an error code is from i32::MIN to  -1.
#[derive(Eq, PartialEq, Debug)]
#[repr(transparent)]
pub struct Reject {
    pub error_code: crate::num::NonZeroI32,
}

/// Default error is i32::MIN.
impl Default for Reject {
    #[inline(always)]
    fn default() -> Self {
        Self {
            error_code: unsafe { crate::num::NonZeroI32::new_unchecked(i32::MIN) },
        }
    }
}

impl Reject {
    /// This returns `None` for all values >= 0 and `Some` otherwise.
    pub fn new(x: i32) -> Option<Self> {
        if x < 0 {
            let error_code = unsafe { crate::num::NonZeroI32::new_unchecked(x) };
            Some(Reject {
                error_code,
            })
        } else {
            None
        }
    }
}
#+end_src
# NonZeroI32 is located in rust/library/core/src/num/nonzero.rs
We modle reject as the underlying data, that is the src_rust[:eval never]{i32} error code. The default constructor is i32 min.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub type Reject = i32;

  #[cfg_attr(feature = "creusot", logic)]
  pub fn reject_impl_deafult() -> Reject {
      i32::MIN
  }
#+end_src

#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub type OptionReject = Option<Reject>;

  #[cfg_attr(feature = "creusot", logic)]
  pub fn new_reject_impl(x: i32) -> OptionReject {
      if x < 0i32 {
	  OptionReject::Some(x)
      } else {
	  Option::<i32>::None // OptionReject
      }
  }

#+end_src

**** Reject - From trait
#+begin_src rust :tangle no :eval never
  impl convert::From<()> for Reject {
      #[inline(always)]
      fn from(_: ()) -> Self {
	  Reject {
	      error_code: unsafe { num::NonZeroI32::new_unchecked(i32::MIN + 1) },
	  }
      }
  }

  impl convert::From<ParseError> for Reject {
      #[inline(always)]
      fn from(_: ParseError) -> Self {
	  Reject {
	      error_code: unsafe { num::NonZeroI32::new_unchecked(i32::MIN + 2) },
	  }
      }
  }
#+end_src

We modle the unsafe block with unchecked non zero as a precondition using requires giving us the hacspec equivalent
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg_attr(feature = "creusot", logic)]
  #[ensures(result != 0i32)]
  pub fn reject_impl_convert_from_unit() -> Reject {
      i32::MIN + 1i32
  }

  #[cfg_attr(feature = "creusot", logic)]
  #[ensures(result != 0i32)]
  pub fn reject_impl_convert_from_parse_error() -> Reject {
      i32::MIN + 2i32
  }
#+end_src
which we can insert as the definition of the from functions in the trait implementation by using a coerce function
#+begin_src rust :tangle no :eval never
  pub fn coerce_hacspec_to_rust_reject(hacspec_reject: ConcordiumImpls::Reject) {
      Reject {
	  error_code: hacspec_reject,
      }
  }
#+end_src
We define a log error type and function converting from it to the reject type
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  /// Errors that can occur during logging.
  #[derive(Copy, Clone)] // , Debug, Eq, PartialEq
  #[repr(u8)]
  pub enum LogError {
      /// The log is full.
      Full,
      /// The message to log was malformed (e.g., too long)
      Malformed,
  }

  #[cfg_attr(feature = "creusot", logic)]
  #[ensures(result != 0i32)]
  pub fn reject_impl_from_log_error(le: LogError) -> Reject {
      match le {
	  LogError::Full => i32::MIN + 3i32,
	  LogError::Malformed => i32::MIN + 4i32,
      }
  }

#+end_src
We define a type for new contract name errors and conversion from it to reject
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[derive(Clone)] // , Debug, PartialEq, Eq
  pub enum NewContractNameError {
      NewContractNameErrorMissingInitPrefix,
      NewContractNameErrorTooLong,
      NewContractNameErrorContainsDot,
      NewContractNameErrorInvalidCharacters,
  }

  #[cfg_attr(feature = "creusot", logic)]
  #[ensures(result != 0i32)]
  pub fn reject_impl_from_new_contract_name_error(nre: NewContractNameError) -> Reject {
      match nre {
	  NewContractNameError::NewContractNameErrorMissingInitPrefix => i32::MIN + 5i32,
	  NewContractNameError::NewContractNameErrorTooLong => i32::MIN + 6i32,
	  NewContractNameError::NewContractNameErrorContainsDot => i32::MIN + 9i32,
	  NewContractNameError::NewContractNameErrorInvalidCharacters => i32::MIN + 10i32,
      }
  }

#+end_src
We define a type for new receive name errors and conversion from it to reject
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[derive(Clone)] // , Debug, PartialEq, Eq
  pub enum NewReceiveNameError {
      NewReceiveNameErrorMissingDotSeparator,
      NewReceiveNameErrorTooLong,
      NewReceiveNameErrorInvalidCharacters,
  }

  #[cfg_attr(feature = "creusot", logic)]
  #[ensures(result != 0i32)]
  pub fn reject_impl_from_new_receive_name_error(nre: NewReceiveNameError) -> Reject {
      match nre {
	  NewReceiveNameError::NewReceiveNameErrorMissingDotSeparator => i32::MIN + 7i32,
	  NewReceiveNameError::NewReceiveNameErrorTooLong => i32::MIN + 8i32,
	  NewReceiveNameError::NewReceiveNameErrorInvalidCharacters => i32::MIN + 11i32,
      }
  }

#+end_src
*** Contract state
We define contract state as its inner state namely the current position of the src_rust[:eval never]{u32} type.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub type ContractState = u32;

#+end_src
**** Contract State -- Seek
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub type SeekResult = Result<(ContractState, u64), ()>;

  #[derive(Copy, Clone)] // , Debug, PartialEq, Eq
  pub enum SeekFrom {
      /// Sets the offset to the provided number of bytes.
      Start(u64),

      /// Sets the offset to the size of this object plus the specified number of
      /// bytes.
      ///
      /// It is possible to seek beyond the end of an object, but it's an error to
      /// seek before byte 0.
      End(i64),

      /// Sets the offset to the current position plus the specified number of
      /// bytes.
      ///
      /// It is possible to seek beyond the end of an object, but it's an error to
      /// seek before byte 0.
      Current(i64),
  }

  pub type U32Option = Option<u32>;
  pub type I64Option = Option<i64>;

  #[cfg_attr(feature = "creusot", trusted)]
  #[requires(forall<delta : i64> pos === SeekFrom::End(delta) ==> exists<b : u32> current_position.checked_add(delta as u32) == U32Option::Some(b))]
  pub fn contract_state_impl_seek(current_position: ContractState, pos: SeekFrom) -> SeekResult {
      match pos {
	  SeekFrom::Start(offset) => SeekResult::Ok((offset as u32, offset)),
	  SeekFrom::End(delta) => {
	      if delta >= 0_i64 {
		  match current_position.checked_add(delta as u32) {
		      U32Option::Some(b) => SeekResult::Ok((b, delta as u64)),
		      U32Option::None => SeekResult::Err(()),
		  }
	      } else {
		  match delta.checked_abs() {
		      I64Option::Some(b) =>
		      // {
		      // let new_pos = 4_u32 - (b as u32);
		      {
			  SeekResult::Ok(((4_u32 - (b as u32)), (4_u32 - (b as u32)) as u64))
		      }
		      // }
		      I64Option::None => SeekResult::Err(()),
		  }
	      }
	  }
	  SeekFrom::Current(delta) => {
	      if delta >= 0_i64 {
		  match current_position.checked_add(delta as u32) {
		      U32Option::Some(offset) => SeekResult::Ok((offset, offset as u64)),
		      U32Option::None => SeekResult::Err(()),
		  }
	      } else {
		  match delta.checked_abs() {
		      I64Option::Some(b) => match current_position.checked_sub(b as u32) {
			  U32Option::Some(offset) => SeekResult::Ok((offset, offset as u64)),
			  U32Option::None => SeekResult::Err(()),
		      },
		      I64Option::None => SeekResult::Err(()),
		  }
	      }
	  }
      }
  }
#+end_src
**** Contract State -- Load
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg(not(feature = "hacspec"))]
  extern "C" {
      pub(crate) fn load_state(start: *mut u8, length: u32, offset: u32) -> u32;
  }

  // #[cfg(feature = "hacspec")]
  // #[cfg_attr(feature = "creusot", trusted)]
  // #[requires(offset < buf.len())]
  #[cfg(feature = "hacspec")]
  #[ensures(result != (buf, 2u32))] // forall<b : u32> result = (buf,b) ==> 0u32 < offset + b
  fn load_state_hacspec(buf : PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      (buf, 1u32)
  }

  #[cfg(not(feature = "hacspec"))]
  fn load_state_hacspec(buf : PublicByteSeq, offset: u32) -> (PublicByteSeq, u32) {
      let mut temp_vec : Vec<u8> = (0..buf.len()).map(|i| {
	  buf.index(i).clone()
      }).collect();
      let temp = &mut temp_vec[..];
      let i = unsafe { load_state(temp.as_mut_ptr(), buf.len() as u32, offset) };
      (PublicByteSeq::from_native_slice(temp), i)
  }

#+end_src
**** Contract State -- Read
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg_attr(feature = "creusot", trusted)]
  pub fn contract_state_impl_read_read(
      current_position: ContractState,
      buf : PublicByteSeq // Seq<u8>
      // num_read: u32,
  ) -> (ContractState, usize) {
      let (buf, num_read) = load_state_hacspec(buf, current_position);
      (current_position + num_read, num_read as usize)
  }

  /// Read a u32 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  #[cfg_attr(feature = "creusot", logic)]
  pub fn contract_state_impl_read_read_u64(
      current_position: ContractState,
      num_read: u32,
  ) -> (ContractState, bool) {
      (current_position + num_read, num_read == 8_u32)
  }

  /// Read a u32 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  #[cfg_attr(feature = "creusot", logic)]
  pub fn contract_state_impl_read_read_u32(
      current_position: ContractState,
      num_read: u32,
  ) -> (ContractState, bool) {
      (current_position + num_read, num_read == 4_u32)
  }

  /// Read a u8 in little-endian format. This is optimized to not
  /// initialize a dummy value before calling an external function.
  #[cfg_attr(feature = "creusot", logic)]
  pub fn contract_state_impl_read_read_u8(
      current_position: ContractState,
      num_read: u32,
  ) -> (ContractState, bool) {
      (current_position + num_read, num_read == 1_u32)
  }

#+end_src
**** Contract State -- Write
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg_attr(feature = "creusot", logic)]
  pub fn write_impl_for_contract_state_test(current_position: ContractState, len: u32) -> bool {
      current_position.checked_add(len).is_none() // Check for overflow
  }

  #[cfg_attr(feature = "creusot", trusted)]
  pub fn write_impl_for_contract_state(
      current_position: ContractState,
      num_bytes: u32,
  ) -> (ContractState, usize) {
      (current_position + num_bytes, num_bytes as usize)
  }

#+end_src
**** Contract State -- Misc.
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  #[cfg_attr(feature = "creusot", logic)]
  pub fn has_contract_state_impl_for_contract_state_open() -> ContractState {
      0_u32
  }

  #[cfg_attr(feature = "creusot", logic)]
  pub fn has_contract_state_impl_for_contract_state_reserve_0(len: u32, cur_size: u32) -> bool {
      cur_size < len
  }
  #[cfg_attr(feature = "creusot", logic)]
  pub fn has_contract_state_impl_for_contract_state_reserve_1(res: u32) -> bool {
      res == 1_u32
  }

  #[cfg_attr(feature = "creusot", logic)]
  pub fn has_contract_state_impl_for_contract_state_truncate_0(cur_size: u32, new_size: u32) -> bool {
      cur_size > new_size
  }
  #[cfg_attr(feature = "creusot", logic)]
  pub fn has_contract_state_impl_for_contract_state_truncate_1(
      current_position: ContractState,
      new_size: u32,
  ) -> ContractState {
      if new_size < current_position {
	  new_size
      } else {
	  current_position
      }
  }

#+end_src
*** Parameter
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  pub type Parameter = u32;

  #[cfg_attr(feature = "creusot", trusted)]
  pub fn read_impl_for_parameter_read(
      current_position: Parameter,
      num_read: u32,
  ) -> (Parameter, usize) {
      (current_position + num_read, num_read as usize)
  }

#+end_src
*** AttributesCursor
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never
  // pub struct AttributeTag(pub u8);
  pub type AttributesCursor = (u32, u16);

  #[cfg_attr(feature = "creusot", trusted)]
  pub fn has_policy_impl_for_policy_attributes_cursor_next_test(
      policy_attribute_items: AttributesCursor,
  ) -> bool {
      let (_, remaining_items) = policy_attribute_items;
      remaining_items == 0_u16
  }

  #[cfg_attr(feature = "creusot", trusted)]
  pub fn has_policy_impl_for_policy_attributes_cursor_next_tag_invalid(
      policy_attribute_items: AttributesCursor,
      tag_value_len_1: u8,
      num_read: u32,
  ) -> (AttributesCursor, bool) {
      let (current_position, remaining_items) = policy_attribute_items;
      let policy_attribute_items = (current_position + num_read, remaining_items);
      (policy_attribute_items, tag_value_len_1 > 31_u8)
  }

  #[cfg_attr(feature = "creusot", trusted)]
  pub fn has_policy_impl_for_policy_attributes_cursor_next(
      policy_attribute_items: AttributesCursor,
      num_read: u32,
  ) -> AttributesCursor {
      let (current_position, remaining_items) = policy_attribute_items;
      (current_position + num_read, remaining_items - 1_u16)
  }
#+end_src
** Rust Tests
#+begin_src rust :tangle ../../examples/concordium_impls/src/concordium_impls.rs :eval never

#+end_src

** Resulting output
#+begin_src sh :eval no-export-query :results output silent
  cargo clean
#+end_src

#+begin_src sh :eval no-export-query :results output silent
  cd ../.. && cargo install --path language
#+end_src

#+begin_src sh :eval no-export-query :results output silent
  cd ../.. && cargo build
#+end_src

#+begin_src sh :eval never :results output silent
  cargo hacspec -o ConcordiumImpls.v concordium_impls --init
#+end_src

#+begin_src sh :results output silent
  cargo hacspec -o ConcordiumImpls.v concordium_impls --update
#+end_src

** Generation of backend output

#+name: split-file
#+begin_src python :wrap "src coq :tangle ConcordiumImpls.v :results output silent" :exports none :results code :var ARG="0 -1" :var FILENAME="ConcordiumImpls.v" :eval never
  import functools

  lower, upper = map(int, ARG.split())
  if upper != -1:
    upper = lower + upper

  def boundery(start, end, lines, i):
    test = lines[i][:len(start)] == start
    res_str = ""

    in_end = lambda i: (i < len(lines) and len(list(filter(lambda x: x in lines[i], end))) > 0)

    if test:
      # if end in lines[i]:
      if in_end(i):
	res_str = lines[i]
      else:
	while i < len(lines) and not in_end(i): # end not in lines[i]:
	  res_str += lines[i]
	  i += 1
	res_str += lines[i]
    return (test, res_str, i)

  lines = []
  with open(FILENAME) as f:
    lines = f.readlines()

  result = []
  i  = 0
  while i < len(lines) and (upper == -1 or upper > len(result)):
    a,b,c = functools.reduce(lambda b, a: b if b[0] else boundery(a[0], a[1], lines, b[2]),
			     [["(**", set({"**)"})],
			      ["From",set({".\n"})],
			      ["Require",set({".\n"})],
			      ["Import",set({".\n"})],
			      ["Open Scope",set({".\n"})],
			      ["Inductive",set({".\n"})],
			      ["Definition",set({".\n"})],
			      ["Instance",set({".\n"})],
			      ["Notation",set({".\n"})],
			      ["Theorem",set({".\n"})],
			      ["Global Instance",set({".\n"})],
			      ["Proof",set({"Admitted", "Qed"})],
			      ["QuickChick",set({".\n"})],
			      ],
			     (False, "", i))
    if a:
      result.append(b)
      i = c
    elif lines[i].isspace():
      space = ""
      while i < len(lines) and lines[i].isspace():
	space += lines[i]
	i += 1
      i -= 1
      result.append(space)
    else:
      result.append("ERR:" + lines[i])
    i += 1

  result_str = ""
  for s in (result[lower:] if upper == -1 else result[lower:upper]):
    result_str += s

  return result_str
#+end_src

#+NAME: next
#+begin_src python :var ARG="0 0" :var linum="0 0" :results output silent :exports none
  a,b = map(int, linum.split())
  c,d = map(int, ARG.split())
  print (a+b+c,d)
#+end_src

#+NAME: seginit
#+begin_src python :wrap "src coq :results output silent" :result code :exports none :var loc=(file-name-directory buffer-file-name)
  with open("../_CoqProject") as f:
      result = ""
      for l in f:
	  if l[:2] == "-R":
	      pre, post = l[3:].split()
	      result += "Add Rec LoadPath \"" + pre + "\" as " + post + ".\n"
	  # elif l[:4] == "src/":
	  #     result += "Load " + l[4:-2] + "\n"
      return "Reset Initial.\nCd \""+loc+"../\".\n" + result
#+end_src
#+RESULTS: seginit
#+begin_src coq :results output silent
Reset Initial.
Cd "/home/au538501/Documents/LocalHacspec/hacspec/coq/src/../".
Add Rec LoadPath "src/" as Hacspec.
#+end_src

*** The includes
#+NAME: linum0
#+CALL: next(ARG="0 9", linum="0 0") :exports none
#+NAME: seg0
#+CALL: split-file(ARG=linum0) :eval
#+RESULTS: seg0
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
(** This file was automatically generated using Hacspec **)
Require Import Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.
Require Import Hacspec.Lib.

#+end_src

*** Types and default implementations
#+NAME: linum1
#+CALL: next(ARG="0 2", linum=linum0) :exports none
#+NAME: seg1
#+CALL: split-file(ARG=linum1) :eval
#+RESULTS: seg1
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'reject'" := (int32) : hacspec_scope.

#+end_src

#+NAME: linum2
#+CALL: next(ARG="0 2", linum=linum1) :exports none
#+NAME: seg2
#+CALL: split-file(ARG=linum2) :eval
#+RESULTS: seg2
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition reject_impl_deafult  : reject :=
  min.

#+end_src

#+NAME: linum3
#+CALL: next(ARG="0 2", linum=linum2) :exports none
#+NAME: seg3
#+CALL: split-file(ARG=linum3) :eval
#+RESULTS: seg3
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'option_reject'" := ((option reject)) : hacspec_scope.

#+end_src

#+NAME: linum4
#+CALL: next(ARG="0 2", linum=linum3) :exports none
#+NAME: seg4
#+CALL: split-file(ARG=linum4) :eval
#+RESULTS: seg4
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition new_reject_impl (x_0 : int32) : option_reject :=
  (if ((x_0) <.? (@repr WORDSIZE32 0)):bool then (@Some reject (x_0)) else (
      @None int32)).

#+end_src

*** Error handling
#+NAME: linum5
#+CALL: next(ARG="0 5", linum=linum4) :exports none
#+NAME: seg5
#+CALL: split-file(ARG=linum5) :eval
#+RESULTS: seg5
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition reject_impl_convert_from_unit  : reject :=
  (min) .+ (@repr WORDSIZE32 1).

Theorem ensures_reject_impl_convert_from_unit : forall result_1 ,
@reject_impl_convert_from_unit  = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof. 
  intros ; subst.
  reflexivity.
Qed.


#+end_src

#+NAME: linum6
#+CALL: next(ARG="0 5", linum=linum5) :exports none
#+NAME: seg6
#+CALL: split-file(ARG=linum6) :eval
#+RESULTS: seg6
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition reject_impl_convert_from_parse_error  : reject :=
  (min) .+ (@repr WORDSIZE32 2).

Theorem ensures_reject_impl_convert_from_parse_error : forall result_1 ,
@reject_impl_convert_from_parse_error  = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof. 
  intros ; subst.
  reflexivity.
Qed.

#+end_src

#+NAME: linum7
#+CALL: next(ARG="0 7", linum=linum6) :exports none
#+NAME: seg7
#+CALL: split-file(ARG=linum7) :eval
#+RESULTS: seg7
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Inductive log_error :=
| Full : log_error
| Malformed : log_error.

Definition reject_impl_from_log_error (le_2 : log_error) : reject :=
  match le_2 with
  | Full => (min) .+ (@repr WORDSIZE32 3)
  | Malformed => (min) .+ (@repr WORDSIZE32 4)
  end.

Theorem ensures_reject_impl_from_log_error : forall result_1 (le_2 : log_error),
@reject_impl_from_log_error le_2 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.  
  intros ; subst.
  destruct le_2 ; reflexivity.
Qed.

#+end_src

#+NAME: linum8
#+CALL: next(ARG="0 7", linum=linum7) :exports none
#+NAME: seg8
#+CALL: split-file(ARG=linum8) :eval
#+RESULTS: seg8
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Inductive new_contract_name_error :=
| NewContractNameErrorMissingInitPrefix : new_contract_name_error
| NewContractNameErrorTooLong : new_contract_name_error
| NewContractNameErrorContainsDot : new_contract_name_error
| NewContractNameErrorInvalidCharacters : new_contract_name_error.

Definition reject_impl_from_new_contract_name_error
  (nre_3 : new_contract_name_error)
  : reject :=
  match nre_3 with
  | NewContractNameErrorMissingInitPrefix => (min) .+ (@repr WORDSIZE32 5)
  | NewContractNameErrorTooLong => (min) .+ (@repr WORDSIZE32 6)
  | NewContractNameErrorContainsDot => (min) .+ (@repr WORDSIZE32 9)
  | NewContractNameErrorInvalidCharacters => (min) .+ (@repr WORDSIZE32 10)
  end.

Theorem ensures_reject_impl_from_new_contract_name_error : forall result_1 (
  nre_3 : new_contract_name_error),
@reject_impl_from_new_contract_name_error nre_3 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof. 
  intros ; subst.
  destruct nre_3 ; reflexivity.
Qed.

#+end_src

#+NAME: linum9
#+CALL: next(ARG="0 7", linum=linum8) :exports none
#+NAME: seg9
#+CALL: split-file(ARG=linum9) :eval
#+RESULTS: seg9
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Inductive new_receive_name_error :=
| NewReceiveNameErrorMissingDotSeparator : new_receive_name_error
| NewReceiveNameErrorTooLong : new_receive_name_error
| NewReceiveNameErrorInvalidCharacters : new_receive_name_error.

Definition reject_impl_from_new_receive_name_error
  (nre_4 : new_receive_name_error)
  : reject :=
  match nre_4 with
  | NewReceiveNameErrorMissingDotSeparator => (min) .+ (@repr WORDSIZE32 7)
  | NewReceiveNameErrorTooLong => (min) .+ (@repr WORDSIZE32 8)
  | NewReceiveNameErrorInvalidCharacters => (min) .+ (@repr WORDSIZE32 11)
  end.

Theorem ensures_reject_impl_from_new_receive_name_error : forall result_1 (
  nre_4 : new_receive_name_error),
@reject_impl_from_new_receive_name_error nre_4 = result_1 ->
(result_1) !=.? (@repr WORDSIZE32 0).
Proof.
  intros ; subst.
  destruct nre_4 ; reflexivity.
Qed.

#+end_src

*** Contract state
#+NAME: linum10
#+CALL: next(ARG="0 2", linum=linum9) :exports none
#+NAME: seg10
#+CALL: split-file(ARG=linum10) :eval
#+RESULTS: seg10
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'contract_state'" := (int32) : hacspec_scope.

#+end_src

#+NAME: linum11
#+CALL: next(ARG="0 4", linum=linum10) :exports none
#+NAME: seg11
#+CALL: split-file(ARG=linum11) :eval
#+RESULTS: seg11
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'seek_result'" := ((result (contract_state × int64
  ) unit)) : hacspec_scope.

Inductive seek_from :=
| Start : int64 -> seek_from
| End : int64 -> seek_from
| Current : int64 -> seek_from.

#+end_src

#+NAME: linum12
#+CALL: next(ARG="0 4", linum=linum11) :exports none
#+NAME: seg12
#+CALL: split-file(ARG=linum12) :eval
#+RESULTS: seg12
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'uint32_option'" := ((option int32)) : hacspec_scope.

Notation "'iint64_option'" := ((option int64)) : hacspec_scope.

#+end_src

#+NAME: linum13
#+CALL: next(ARG="0 2", linum=linum12) :exports none
#+NAME: seg13
#+CALL: split-file(ARG=linum13) :eval
#+RESULTS: seg13
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition contract_state_impl_seek
  (current_position_5 : contract_state)
  (pos_6 : seek_from)
  `{forall delta_7 : int64,
  pos_6 = End (delta_7) ->
  exists b_8 : int32,
  (pub_uint32_checked_add (current_position_5) (@cast _ uint32 _ (
        delta_7))) =.? (@Some int32 (b_8))}
  : seek_result :=
  match pos_6 with
  | Start offset_9 => @Ok (contract_state × int64) unit ((
      @cast _ uint32 _ (offset_9),
      offset_9
    ))
  | End delta_10 => (if ((delta_10) >=.? (@repr WORDSIZE64 0)):bool then (
      match pub_uint32_checked_add (current_position_5) (@cast _ uint32 _ (
          delta_10)) with
      | Some b_11 => @Ok (contract_state × int64) unit ((
          b_11,
          @cast _ uint64 _ (delta_10)
        ))
      | None => @Err (contract_state × int64) unit (tt)
      end) else (match pub_int64_checked_abs (delta_10) with
      | Some b_12 => @Ok (contract_state × int64) unit ((
          (@repr WORDSIZE32 4) .- (@cast _ uint32 _ (b_12)),
          @cast _ uint64 _ ((@repr WORDSIZE32 4) .- (@cast _ uint32 _ (b_12)))
        ))
      | None => @Err (contract_state × int64) unit (tt)
      end))
  | Current delta_13 => (if ((delta_13) >=.? (@repr WORDSIZE64 0)):bool then (
      match pub_uint32_checked_add (current_position_5) (@cast _ uint32 _ (
          delta_13)) with
      | Some offset_14 => @Ok (contract_state × int64) unit ((
          offset_14,
          @cast _ uint64 _ (offset_14)
        ))
      | None => @Err (contract_state × int64) unit (tt)
      end) else (match pub_int64_checked_abs (delta_13) with
      | Some b_15 => match pub_uint32_checked_sub (current_position_5) (
        @cast _ uint32 _ (b_15)) with
      | Some offset_16 => @Ok (contract_state × int64) unit ((
          offset_16,
          @cast _ uint64 _ (offset_16)
        ))
      | None => @Err (contract_state × int64) unit (tt)
      end
      | None => @Err (contract_state × int64) unit (tt)
      end))
  end.

#+end_src

**** Contract state - Read Trait
#+NAME: linum14
#+CALL: next(ARG="0 5", linum=linum13) :exports none
#+NAME: seg14
#+CALL: split-file(ARG=linum14) :eval
#+RESULTS: seg14
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition load_state_hacspec
  (buf_17 : public_byte_seq)
  (offset_18 : int32)
  : (public_byte_seq × int32) :=
  (buf_17, @repr WORDSIZE32 1).

Theorem ensures_load_state_hacspec : forall result_1 (
  buf_17 : public_byte_seq) (offset_18 : int32),
@load_state_hacspec buf_17 offset_18 = result_1 ->
(result_1) !=.? ((buf_17, @repr WORDSIZE32 2)).
Proof.
  intros ; subst.
  unfold negb.
  cbn.
  rewrite list_eqdec_refl.
  cbn.
  rewrite (@eq_false WORDSIZE32 (repr 1) (repr 2)) ; easy.
Qed.  

#+end_src

#+NAME: linum15
#+CALL: next(ARG="0 8", linum=linum14) :exports none
#+NAME: seg15
#+CALL: split-file(ARG=linum15) :eval
#+RESULTS: seg15
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition contract_state_impl_read_read
  (current_position_19 : contract_state)
  (buf_20 : public_byte_seq)
  : (contract_state × uint_size) :=
  let '(buf_21, num_read_22) :=
    load_state_hacspec (buf_20) (current_position_19) in 
  ((current_position_19) .+ (num_read_22), @cast _ uint32 _ (num_read_22)).

Definition contract_state_impl_read_read_u64
  (current_position_23 : contract_state)
  (num_read_24 : int32)
  : (contract_state × bool) :=
  (
    (current_position_23) .+ (num_read_24),
    (num_read_24) =.? (@repr WORDSIZE32 8)
  ).

Definition contract_state_impl_read_read_u32
  (current_position_25 : contract_state)
  (num_read_26 : int32)
  : (contract_state × bool) :=
  (
    (current_position_25) .+ (num_read_26),
    (num_read_26) =.? (@repr WORDSIZE32 4)
  ).

Definition contract_state_impl_read_read_u8
  (current_position_27 : contract_state)
  (num_read_28 : int32)
  : (contract_state × bool) :=
  (
    (current_position_27) .+ (num_read_28),
    (num_read_28) =.? (@repr WORDSIZE32 1)
  ).

#+end_src

**** Contract state - Write Trait
#+NAME: linum16
#+CALL: next(ARG="0 4", linum=linum15) :exports none
#+NAME: seg16
#+CALL: split-file(ARG=linum16) :eval
#+RESULTS: seg16
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition write_impl_for_contract_state_test
  (current_position_29 : contract_state)
  (len_30 : int32)
  : bool :=
  option_is_none (pub_uint32_checked_add (current_position_29) (len_30)).

Definition write_impl_for_contract_state
  (current_position_31 : contract_state)
  (num_bytes_32 : int32)
  : (contract_state × uint_size) :=
  ((current_position_31) .+ (num_bytes_32), @cast _ uint32 _ (num_bytes_32)).

#+end_src

**** Contract State - Misc.
#+NAME: linum17
#+CALL: next(ARG="0 10", linum=linum16) :exports none
#+NAME: seg17
#+CALL: split-file(ARG=linum17) :eval
#+RESULTS: seg17
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Definition has_contract_state_impl_for_contract_state_open  : contract_state :=
  @repr WORDSIZE32 0.

Definition has_contract_state_impl_for_contract_state_reserve_0
  (len_33 : int32)
  (cur_size_34 : int32)
  : bool :=
  (cur_size_34) <.? (len_33).

Definition has_contract_state_impl_for_contract_state_reserve_1
  (res_35 : int32)
  : bool :=
  (res_35) =.? (@repr WORDSIZE32 1).

Definition has_contract_state_impl_for_contract_state_truncate_0
  (cur_size_36 : int32)
  (new_size_37 : int32)
  : bool :=
  (cur_size_36) >.? (new_size_37).

Definition has_contract_state_impl_for_contract_state_truncate_1
  (current_position_38 : contract_state)
  (new_size_39 : int32)
  : contract_state :=
  (if ((new_size_39) <.? (current_position_38)):bool then (new_size_39) else (
      current_position_38)).

#+end_src

*** Parameter
#+NAME: linum18
#+CALL: next(ARG="0 4", linum=linum17) :exports none
#+NAME: seg18
#+CALL: split-file(ARG=linum18) :eval
#+RESULTS: seg18
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'parameter'" := (int32) : hacspec_scope.

Definition read_impl_for_parameter_read
  (current_position_40 : parameter)
  (num_read_41 : int32)
  : (parameter × uint_size) :=
  ((current_position_40) .+ (num_read_41), @cast _ uint32 _ (num_read_41)).

#+end_src

*** Attributes Cursor
#+NAME: linum19
#+CALL: next(ARG="0 -1", linum=linum18) :exports none
#+NAME: seg19
#+CALL: split-file(ARG=linum19) :eval
#+RESULTS: seg19
#+begin_src coq :tangle ConcordiumImpls.v :results output silent
Notation "'attributes_cursor'" := ((int32 × int16)) : hacspec_scope.

Definition has_policy_impl_for_policy_attributes_cursor_next_test
  (policy_attribute_items_42 : attributes_cursor)
  : bool :=
  let '(_, remaining_items_43) :=
    policy_attribute_items_42 in 
  (remaining_items_43) =.? (@repr WORDSIZE16 0).

Definition has_policy_impl_for_policy_attributes_cursor_next_tag_invalid
  (policy_attribute_items_44 : attributes_cursor)
  (tag_value_len_1_45 : int8)
  (num_read_46 : int32)
  : (attributes_cursor × bool) :=
  let '(current_position_47, remaining_items_48) :=
    policy_attribute_items_44 in 
  let policy_attribute_items_49 : (int32 × int16) :=
    ((current_position_47) .+ (num_read_46), remaining_items_48) in 
  (policy_attribute_items_49, (tag_value_len_1_45) >.? (@repr WORDSIZE8 31)).

Definition has_policy_impl_for_policy_attributes_cursor_next
  (policy_attribute_items_50 : attributes_cursor)
  (num_read_51 : int32)
  : attributes_cursor :=
  let '(current_position_52, remaining_items_53) :=
    policy_attribute_items_50 in 
  (
    (current_position_52) .+ (num_read_51),
    (remaining_items_53) .- (@repr WORDSIZE16 1)
  ).

#+end_src
